; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\stm32f1xx_hal_tim.o --asm_dir=.\air_slave\ --list_dir=.\air_slave\ --depend=.\stm32f1xx_hal_tim.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I.\RTE\_air_slave -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=525 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=.\stm32f1xx_hal_tim.crf ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_tim.c]
                          THUMB

                          AREA ||i.HAL_TIM_Base_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_DeInit PROC
;;;243      */
;;;244    HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;245    {
000002  4604              MOV      r4,r0
;;;246      /* Check the parameters */
;;;247      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;248    
;;;249      htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f884003d          STRB     r0,[r4,#0x3d]
;;;250    
;;;251      /* Disable the TIM Peripheral Clock */
;;;252      __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L1.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L1.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L1.38|
;;;253    
;;;254      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;255      HAL_TIM_Base_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_Base_MspDeInit
;;;256    
;;;257      /* Change TIM state */
;;;258      htim->State = HAL_TIM_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  f884003d          STRB     r0,[r4,#0x3d]
;;;259    
;;;260      /* Release Lock */
;;;261      __HAL_UNLOCK(htim);
000032  f884003c          STRB     r0,[r4,#0x3c]
;;;262    
;;;263      return HAL_OK;
;;;264    }
000036  bd10              POP      {r4,pc}
;;;265    
                          ENDP


                          AREA ||i.HAL_TIM_Base_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_GetState PROC
;;;4386     */
;;;4387   HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
000000  f890003d          LDRB     r0,[r0,#0x3d]
;;;4388   {
;;;4389     return htim->State;
;;;4390   }
000004  4770              BX       lr
;;;4391   
                          ENDP


                          AREA ||i.HAL_TIM_Base_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Init PROC
;;;203      */
;;;204    HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;205    {
000002  0004              MOVS     r4,r0
000004  d003              BEQ      |L3.14|
;;;206      /* Check the TIM handle allocation */
;;;207      if(htim == NULL)
;;;208      {
;;;209        return HAL_ERROR;
;;;210      }
;;;211    
;;;212      /* Check the parameters */
;;;213      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;214      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;215      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;216      assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;217    
;;;218      if(htim->State == HAL_TIM_STATE_RESET)
000006  f894003d          LDRB     r0,[r4,#0x3d]
00000a  b110              CBZ      r0,|L3.18|
00000c  e007              B        |L3.30|
                  |L3.14|
00000e  2001              MOVS     r0,#1                 ;209
;;;219      {
;;;220        /* Allocate lock resource and initialize it */
;;;221        htim->Lock = HAL_UNLOCKED;
;;;222        
;;;223        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;224        HAL_TIM_Base_MspInit(htim);
;;;225      }
;;;226    
;;;227      /* Set the TIM state */
;;;228      htim->State= HAL_TIM_STATE_BUSY;
;;;229    
;;;230      /* Set the Time Base configuration */
;;;231      TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;232    
;;;233      /* Initialize the TIM state*/
;;;234      htim->State= HAL_TIM_STATE_READY;
;;;235    
;;;236      return HAL_OK;
;;;237    }
000010  bd10              POP      {r4,pc}
                  |L3.18|
000012  2000              MOVS     r0,#0                 ;221
000014  f884003c          STRB     r0,[r4,#0x3c]         ;221
000018  4620              MOV      r0,r4                 ;224
00001a  f7fffffe          BL       HAL_TIM_Base_MspInit
                  |L3.30|
00001e  2002              MOVS     r0,#2                 ;228
000020  f884003d          STRB     r0,[r4,#0x3d]         ;228
000024  1d21              ADDS     r1,r4,#4              ;231
000026  6820              LDR      r0,[r4,#0]            ;231
000028  f7fffffe          BL       TIM_Base_SetConfig
00002c  2001              MOVS     r0,#1                 ;234
00002e  f884003d          STRB     r0,[r4,#0x3d]         ;234
000032  2000              MOVS     r0,#0                 ;236
000034  bd10              POP      {r4,pc}
;;;238    
                          ENDP


                          AREA ||i.HAL_TIM_Base_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_MspDeInit PROC
;;;284      */
;;;285    __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;286    {
;;;287      /* Prevent unused argument(s) compilation warning */
;;;288      UNUSED(htim);
;;;289      /* NOTE : This function Should not be modified, when the callback is needed,
;;;290                the HAL_TIM_Base_MspDeInit could be implemented in the user file
;;;291       */
;;;292    }
;;;293    
                          ENDP


                          AREA ||i.HAL_TIM_Base_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_MspInit PROC
;;;270      */
;;;271    __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;272    {
;;;273      /* Prevent unused argument(s) compilation warning */
;;;274      UNUSED(htim);
;;;275      /* NOTE : This function Should not be modified, when the callback is needed,
;;;276                the HAL_TIM_Base_MspInit could be implemented in the user file
;;;277       */
;;;278    }
;;;279    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Start PROC
;;;299    */
;;;300    HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
000000  2102              MOVS     r1,#2
;;;301    {
;;;302      /* Check the parameters */
;;;303      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;304    
;;;305      /* Set the TIM state */
;;;306      htim->State= HAL_TIM_STATE_BUSY;
000002  f880103d          STRB     r1,[r0,#0x3d]
;;;307    
;;;308      /* Enable the Peripheral */
;;;309      __HAL_TIM_ENABLE(htim);
000006  6801              LDR      r1,[r0,#0]
000008  680a              LDR      r2,[r1,#0]
00000a  f0420201          ORR      r2,r2,#1
00000e  600a              STR      r2,[r1,#0]
;;;310    
;;;311      /* Change the TIM state*/
;;;312      htim->State= HAL_TIM_STATE_READY;
000010  2101              MOVS     r1,#1
000012  f880103d          STRB     r1,[r0,#0x3d]
;;;313    
;;;314      /* Return function status */
;;;315      return HAL_OK;
000016  2000              MOVS     r0,#0
;;;316    }
000018  4770              BX       lr
;;;317    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Base_Start_DMA PROC
;;;386    */
;;;387    HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;388    {
000002  4604              MOV      r4,r0
;;;389      /* Check the parameters */
;;;390      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
;;;391    
;;;392      if((htim->State == HAL_TIM_STATE_BUSY))
000004  f890003d          LDRB     r0,[r0,#0x3d]
000008  2802              CMP      r0,#2
00000a  d005              BEQ      |L7.24|
;;;393      {
;;;394         return HAL_BUSY;
;;;395      }
;;;396      else if((htim->State == HAL_TIM_STATE_READY))
00000c  f894003d          LDRB     r0,[r4,#0x3d]
000010  2801              CMP      r0,#1
000012  d105              BNE      |L7.32|
;;;397      {
;;;398        if((pData == 0U) && (Length > 0U))
000014  b909              CBNZ     r1,|L7.26|
000016  b102              CBZ      r2,|L7.26|
                  |L7.24|
;;;399        {
;;;400          return HAL_ERROR;
;;;401        }
;;;402        else
;;;403        {
;;;404          htim->State = HAL_TIM_STATE_BUSY;
;;;405        }
;;;406      }
;;;407      /* Set the DMA Period elapsed callback */
;;;408      htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;409    
;;;410      /* Set the DMA error callback */
;;;411      htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;412    
;;;413      /* Enable the DMA channel */
;;;414      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length);
;;;415    
;;;416      /* Enable the TIM Update DMA request */
;;;417      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
;;;418    
;;;419      /* Enable the Peripheral */
;;;420      __HAL_TIM_ENABLE(htim);
;;;421    
;;;422      /* Return function status */
;;;423      return HAL_OK;
;;;424    }
000018  bd70              POP      {r4-r6,pc}
                  |L7.26|
00001a  2002              MOVS     r0,#2                 ;404
00001c  f884003d          STRB     r0,[r4,#0x3d]         ;404
                  |L7.32|
000020  6a23              LDR      r3,[r4,#0x20]         ;408
000022  480c              LDR      r0,|L7.84|
000024  6298              STR      r0,[r3,#0x28]         ;411
000026  6a23              LDR      r3,[r4,#0x20]         ;411
000028  480b              LDR      r0,|L7.88|
00002a  6318              STR      r0,[r3,#0x30]         ;414
00002c  6825              LDR      r5,[r4,#0]            ;414
00002e  4613              MOV      r3,r2                 ;414
000030  f105022c          ADD      r2,r5,#0x2c           ;414
000034  6a20              LDR      r0,[r4,#0x20]         ;414
000036  f7fffffe          BL       HAL_DMA_Start_IT
00003a  6820              LDR      r0,[r4,#0]            ;417
00003c  68c1              LDR      r1,[r0,#0xc]          ;417
00003e  f4417180          ORR      r1,r1,#0x100          ;417
000042  60c1              STR      r1,[r0,#0xc]          ;417
000044  6820              LDR      r0,[r4,#0]            ;420
000046  6801              LDR      r1,[r0,#0]            ;420
000048  f0410101          ORR      r1,r1,#1              ;420
00004c  6001              STR      r1,[r0,#0]            ;420
00004e  2000              MOVS     r0,#0                 ;423
000050  bd70              POP      {r4-r6,pc}
;;;425    
                          ENDP

000052  0000              DCW      0x0000
                  |L7.84|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L7.88|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_Base_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Start_IT PROC
;;;345    */
;;;346    HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
000000  6801              LDR      r1,[r0,#0]
;;;347    {
;;;348      /* Check the parameters */
;;;349      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;350    
;;;351       /* Enable the TIM Update interrupt */
;;;352       __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
000002  68ca              LDR      r2,[r1,#0xc]
000004  f0420201          ORR      r2,r2,#1
000008  60ca              STR      r2,[r1,#0xc]
;;;353    
;;;354       /* Enable the Peripheral */
;;;355      __HAL_TIM_ENABLE(htim);
00000a  6800              LDR      r0,[r0,#0]
00000c  6801              LDR      r1,[r0,#0]
00000e  f0410101          ORR      r1,r1,#1
000012  6001              STR      r1,[r0,#0]
;;;356    
;;;357      /* Return function status */
;;;358      return HAL_OK;
000014  2000              MOVS     r0,#0
;;;359    }
000016  4770              BX       lr
;;;360    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop PROC
;;;322    */
;;;323    HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
000000  2102              MOVS     r1,#2
;;;324    {
;;;325      /* Check the parameters */
;;;326      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;327    
;;;328      /* Set the TIM state */
;;;329      htim->State= HAL_TIM_STATE_BUSY;
000002  f880103d          STRB     r1,[r0,#0x3d]
;;;330    
;;;331      /* Disable the Peripheral */
;;;332      __HAL_TIM_DISABLE(htim);
000006  6801              LDR      r1,[r0,#0]
000008  6a0a              LDR      r2,[r1,#0x20]
00000a  f2411311          MOV      r3,#0x1111
00000e  421a              TST      r2,r3
000010  d107              BNE      |L9.34|
000012  6a0a              LDR      r2,[r1,#0x20]
000014  109b              ASRS     r3,r3,#2
000016  421a              TST      r2,r3
000018  d103              BNE      |L9.34|
00001a  680a              LDR      r2,[r1,#0]
00001c  f0220201          BIC      r2,r2,#1
000020  600a              STR      r2,[r1,#0]
                  |L9.34|
;;;333    
;;;334      /* Change the TIM state*/
;;;335      htim->State= HAL_TIM_STATE_READY;
000022  2101              MOVS     r1,#1
000024  f880103d          STRB     r1,[r0,#0x3d]
;;;336    
;;;337      /* Return function status */
;;;338      return HAL_OK;
000028  2000              MOVS     r0,#0
;;;339    }
00002a  4770              BX       lr
;;;340    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop_DMA PROC
;;;430    */
;;;431    HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
000000  6801              LDR      r1,[r0,#0]
;;;432    {
;;;433      /* Check the parameters */
;;;434      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
;;;435    
;;;436      /* Disable the TIM Update DMA request */
;;;437      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
000002  68ca              LDR      r2,[r1,#0xc]
000004  f4227280          BIC      r2,r2,#0x100
000008  60ca              STR      r2,[r1,#0xc]
;;;438    
;;;439      /* Disable the Peripheral */
;;;440      __HAL_TIM_DISABLE(htim);
00000a  6801              LDR      r1,[r0,#0]
00000c  6a0a              LDR      r2,[r1,#0x20]
00000e  f2411311          MOV      r3,#0x1111
000012  421a              TST      r2,r3
000014  d107              BNE      |L10.38|
000016  6a0a              LDR      r2,[r1,#0x20]
000018  109b              ASRS     r3,r3,#2
00001a  421a              TST      r2,r3
00001c  d103              BNE      |L10.38|
00001e  680a              LDR      r2,[r1,#0]
000020  f0220201          BIC      r2,r2,#1
000024  600a              STR      r2,[r1,#0]
                  |L10.38|
;;;441    
;;;442      /* Change the htim state */
;;;443      htim->State = HAL_TIM_STATE_READY;
000026  2101              MOVS     r1,#1
000028  f880103d          STRB     r1,[r0,#0x3d]
;;;444    
;;;445      /* Return function status */
;;;446      return HAL_OK;
00002c  2000              MOVS     r0,#0
;;;447    }
00002e  4770              BX       lr
;;;448    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop_IT PROC
;;;365    */
;;;366    HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
000000  6801              LDR      r1,[r0,#0]
;;;367    {
;;;368      /* Check the parameters */
;;;369      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;370      /* Disable the TIM Update interrupt */
;;;371      __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
000002  68ca              LDR      r2,[r1,#0xc]
000004  f0220201          BIC      r2,r2,#1
000008  60ca              STR      r2,[r1,#0xc]
;;;372    
;;;373      /* Disable the Peripheral */
;;;374      __HAL_TIM_DISABLE(htim);
00000a  6800              LDR      r0,[r0,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L11.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L11.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L11.38|
;;;375    
;;;376      /* Return function status */
;;;377      return HAL_OK;
000026  2000              MOVS     r0,#0
;;;378    }
000028  4770              BX       lr
;;;379    
                          ENDP


                          AREA ||i.HAL_TIM_ConfigClockSource||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigClockSource PROC
;;;3918     */ 
;;;3919   HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)
000000  b570              PUSH     {r4-r6,lr}
;;;3920   {
000002  4604              MOV      r4,r0
;;;3921     uint32_t tmpsmcr = 0U;
;;;3922   
;;;3923     /* Process Locked */
;;;3924     __HAL_LOCK(htim);
000004  f890003c          LDRB     r0,[r0,#0x3c]
000008  2801              CMP      r0,#1
00000a  d017              BEQ      |L12.60|
00000c  2501              MOVS     r5,#1
00000e  f884503c          STRB     r5,[r4,#0x3c]
;;;3925   
;;;3926     htim->State = HAL_TIM_STATE_BUSY;
000012  2002              MOVS     r0,#2
000014  f884003d          STRB     r0,[r4,#0x3d]
;;;3927   
;;;3928     /* Check the parameters */
;;;3929     assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
;;;3930   
;;;3931     /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
;;;3932     tmpsmcr = htim->Instance->SMCR;
000018  6820              LDR      r0,[r4,#0]
00001a  6882              LDR      r2,[r0,#8]
;;;3933     tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
00001c  f0220277          BIC      r2,r2,#0x77
;;;3934     tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
000020  f422427f          BIC      r2,r2,#0xff00
;;;3935     htim->Instance->SMCR = tmpsmcr;
000024  6082              STR      r2,[r0,#8]
;;;3936   
;;;3937     switch (sClockSourceConfig->ClockSource)
000026  6808              LDR      r0,[r1,#0]
000028  2850              CMP      r0,#0x50
00002a  d037              BEQ      |L12.156|
00002c  dc0d              BGT      |L12.74|
00002e  2820              CMP      r0,#0x20
000030  d059              BEQ      |L12.230|
000032  dc05              BGT      |L12.64|
000034  b388              CBZ      r0,|L12.154|
000036  2810              CMP      r0,#0x10
000038  d141              BNE      |L12.190|
00003a  e051              B        |L12.224|
                  |L12.60|
00003c  2002              MOVS     r0,#2                 ;3924
;;;3938     {
;;;3939     case TIM_CLOCKSOURCE_INTERNAL:
;;;3940       {
;;;3941         assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;3942         /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;3943         htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3944       }
;;;3945       break;
;;;3946   
;;;3947     case TIM_CLOCKSOURCE_ETRMODE1:
;;;3948       {
;;;3949         /* Check whether or not the timer instance supports external trigger input mode 1 (ETRF)*/
;;;3950         assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
;;;3951   
;;;3952         /* Check ETR input conditioning related parameters */
;;;3953         assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
;;;3954         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;3955         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;3956         
;;;3957         /* Configure the ETR Clock source */
;;;3958         TIM_ETR_SetConfig(htim->Instance,
;;;3959                           sClockSourceConfig->ClockPrescaler,
;;;3960                           sClockSourceConfig->ClockPolarity,
;;;3961                           sClockSourceConfig->ClockFilter);
;;;3962         /* Get the TIMx SMCR register value */
;;;3963         tmpsmcr = htim->Instance->SMCR;
;;;3964         /* Reset the SMS and TS Bits */
;;;3965         tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
;;;3966         /* Select the External clock mode1 and the ETRF trigger */
;;;3967         tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
;;;3968         /* Write to TIMx SMCR */
;;;3969         htim->Instance->SMCR = tmpsmcr;
;;;3970       }
;;;3971       break;
;;;3972   
;;;3973     case TIM_CLOCKSOURCE_ETRMODE2:
;;;3974       {
;;;3975         /* Check whether or not the timer instance supports external trigger input mode 2 (ETRF)*/
;;;3976         assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
;;;3977   
;;;3978         /* Check ETR input conditioning related parameters */
;;;3979         assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
;;;3980         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;3981         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;3982         
;;;3983         /* Configure the ETR Clock source */
;;;3984         TIM_ETR_SetConfig(htim->Instance,
;;;3985                           sClockSourceConfig->ClockPrescaler,
;;;3986                           sClockSourceConfig->ClockPolarity,
;;;3987                           sClockSourceConfig->ClockFilter);
;;;3988         /* Enable the External clock mode2 */
;;;3989         htim->Instance->SMCR |= TIM_SMCR_ECE;
;;;3990       }
;;;3991       break;
;;;3992   
;;;3993     case TIM_CLOCKSOURCE_TI1:
;;;3994       {
;;;3995         /* Check whether or not the timer instance supports external clock mode 1 */
;;;3996         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;3997   
;;;3998         /* Check TI1 input conditioning related parameters */
;;;3999         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4000         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4001         
;;;4002         TIM_TI1_ConfigInputStage(htim->Instance,
;;;4003                                  sClockSourceConfig->ClockPolarity,
;;;4004                                  sClockSourceConfig->ClockFilter);
;;;4005         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
;;;4006       }
;;;4007       break;
;;;4008     case TIM_CLOCKSOURCE_TI2:
;;;4009       {
;;;4010         /* Check whether or not the timer instance supports external clock mode 1 (ETRF)*/
;;;4011         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;4012   
;;;4013          /* Check TI2 input conditioning related parameters */
;;;4014         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4015         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4016   
;;;4017         TIM_TI2_ConfigInputStage(htim->Instance,
;;;4018                                  sClockSourceConfig->ClockPolarity,
;;;4019                                  sClockSourceConfig->ClockFilter);
;;;4020         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
;;;4021       }
;;;4022       break;
;;;4023     case TIM_CLOCKSOURCE_TI1ED:
;;;4024       {
;;;4025         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4026         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;4027   
;;;4028         /* Check TI1 input conditioning related parameters */
;;;4029         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4030         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4031   
;;;4032         TIM_TI1_ConfigInputStage(htim->Instance,
;;;4033                                  sClockSourceConfig->ClockPolarity,
;;;4034                                  sClockSourceConfig->ClockFilter);
;;;4035         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
;;;4036       }
;;;4037       break;
;;;4038     case TIM_CLOCKSOURCE_ITR0:
;;;4039       {
;;;4040         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4041         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4042   
;;;4043         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR0);
;;;4044       }
;;;4045       break;
;;;4046     case TIM_CLOCKSOURCE_ITR1:
;;;4047       {
;;;4048         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4049         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4050   
;;;4051         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR1);
;;;4052       }
;;;4053       break;
;;;4054     case TIM_CLOCKSOURCE_ITR2:
;;;4055       {
;;;4056         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4057         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4058   
;;;4059         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR2);
;;;4060       }
;;;4061       break;
;;;4062     case TIM_CLOCKSOURCE_ITR3:
;;;4063       {
;;;4064         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4065         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4066   
;;;4067         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR3);
;;;4068       }
;;;4069       break;
;;;4070   
;;;4071     default:
;;;4072       break;
;;;4073     }
;;;4074     htim->State = HAL_TIM_STATE_READY;
;;;4075   
;;;4076     __HAL_UNLOCK(htim);
;;;4077   
;;;4078     return HAL_OK;
;;;4079   }
00003e  bd70              POP      {r4-r6,pc}
                  |L12.64|
000040  2830              CMP      r0,#0x30              ;3937
000042  d053              BEQ      |L12.236|
000044  2840              CMP      r0,#0x40              ;3937
000046  d13a              BNE      |L12.190|
000048  e03f              B        |L12.202|
                  |L12.74|
00004a  2860              CMP      r0,#0x60              ;3937
00004c  d02e              BEQ      |L12.172|
00004e  2870              CMP      r0,#0x70              ;3937
000050  d00b              BEQ      |L12.106|
000052  f5b05f80          CMP      r0,#0x1000            ;3937
000056  d003              BEQ      |L12.96|
000058  f5b05f00          CMP      r0,#0x2000            ;3937
00005c  d12f              BNE      |L12.190|
00005e  e010              B        |L12.130|
                  |L12.96|
000060  6820              LDR      r0,[r4,#0]            ;3943
000062  6881              LDR      r1,[r0,#8]            ;3943
000064  f0210107          BIC      r1,r1,#7              ;3943
000068  e015              B        |L12.150|
                  |L12.106|
00006a  68cb              LDR      r3,[r1,#0xc]          ;3958
00006c  e9d12101          LDRD     r2,r1,[r1,#4]         ;3958
000070  6820              LDR      r0,[r4,#0]            ;3958
000072  f7fffffe          BL       TIM_ETR_SetConfig
000076  6821              LDR      r1,[r4,#0]            ;3963
000078  6888              LDR      r0,[r1,#8]            ;3963
00007a  f0400077          ORR      r0,r0,#0x77           ;3967
00007e  6088              STR      r0,[r1,#8]            ;3969
000080  e01d              B        |L12.190|
                  |L12.130|
000082  68cb              LDR      r3,[r1,#0xc]          ;3984
000084  e9d12101          LDRD     r2,r1,[r1,#4]         ;3984
000088  6820              LDR      r0,[r4,#0]            ;3984
00008a  f7fffffe          BL       TIM_ETR_SetConfig
00008e  6820              LDR      r0,[r4,#0]            ;3989
000090  6881              LDR      r1,[r0,#8]            ;3989
000092  f4414180          ORR      r1,r1,#0x4000         ;3989
                  |L12.150|
000096  6081              STR      r1,[r0,#8]            ;3943
000098  e011              B        |L12.190|
                  |L12.154|
00009a  e01e              B        |L12.218|
                  |L12.156|
00009c  68ca              LDR      r2,[r1,#0xc]          ;4002
00009e  6849              LDR      r1,[r1,#4]            ;4002
0000a0  6820              LDR      r0,[r4,#0]            ;4002
0000a2  f7fffffe          BL       TIM_TI1_ConfigInputStage
0000a6  2150              MOVS     r1,#0x50              ;4005
0000a8  6820              LDR      r0,[r4,#0]            ;4007
0000aa  e006              B        |L12.186|
                  |L12.172|
0000ac  68ca              LDR      r2,[r1,#0xc]          ;4017
0000ae  6849              LDR      r1,[r1,#4]            ;4017
0000b0  6820              LDR      r0,[r4,#0]            ;4017
0000b2  f7fffffe          BL       TIM_TI2_ConfigInputStage
0000b6  2160              MOVS     r1,#0x60              ;4020
0000b8  6820              LDR      r0,[r4,#0]            ;4020
                  |L12.186|
0000ba  f7fffffe          BL       TIM_ITRx_SetConfig
                  |L12.190|
0000be  f884503d          STRB     r5,[r4,#0x3d]         ;4074
0000c2  2000              MOVS     r0,#0                 ;4076
0000c4  f884003c          STRB     r0,[r4,#0x3c]         ;4076
0000c8  bd70              POP      {r4-r6,pc}
                  |L12.202|
0000ca  68ca              LDR      r2,[r1,#0xc]          ;4032
0000cc  6849              LDR      r1,[r1,#4]            ;4032
0000ce  6820              LDR      r0,[r4,#0]            ;4032
0000d0  f7fffffe          BL       TIM_TI1_ConfigInputStage
0000d4  2140              MOVS     r1,#0x40              ;4035
0000d6  6820              LDR      r0,[r4,#0]            ;4037
0000d8  e7ef              B        |L12.186|
                  |L12.218|
0000da  2100              MOVS     r1,#0                 ;4043
0000dc  6820              LDR      r0,[r4,#0]            ;4045
0000de  e7ec              B        |L12.186|
                  |L12.224|
0000e0  2110              MOVS     r1,#0x10              ;4051
0000e2  6820              LDR      r0,[r4,#0]            ;4053
0000e4  e7e9              B        |L12.186|
                  |L12.230|
0000e6  2120              MOVS     r1,#0x20              ;4059
0000e8  6820              LDR      r0,[r4,#0]            ;4061
0000ea  e7e6              B        |L12.186|
                  |L12.236|
0000ec  2130              MOVS     r1,#0x30              ;4067
0000ee  6820              LDR      r0,[r4,#0]            ;4069
0000f0  e7e3              B        |L12.186|
;;;4080   
                          ENDP


                          AREA ||i.HAL_TIM_ConfigOCrefClear||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigOCrefClear PROC
;;;3797     */ 
;;;3798   HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim, TIM_ClearInputConfigTypeDef * sClearInputConfig, uint32_t Channel)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3799   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;3800     uint32_t tmpsmcr = 0U;
;;;3801   
;;;3802     /* Check the parameters */
;;;3803     assert_param(IS_TIM_OCXREF_CLEAR_INSTANCE(htim->Instance));
;;;3804     assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
;;;3805     assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
;;;3806     assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
;;;3807     assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
;;;3808   
;;;3809     /* Process Locked */
;;;3810     __HAL_LOCK(htim);
000008  f894103c          LDRB     r1,[r4,#0x3c]
00000c  2000              MOVS     r0,#0                 ;3800
00000e  4617              MOV      r7,r2                 ;3799
000010  2901              CMP      r1,#1
000012  d00a              BEQ      |L13.42|
000014  2601              MOVS     r6,#1
000016  f884603c          STRB     r6,[r4,#0x3c]
;;;3811   
;;;3812     htim->State = HAL_TIM_STATE_BUSY;
00001a  2102              MOVS     r1,#2
00001c  f884103d          STRB     r1,[r4,#0x3d]
000020  6869              LDR      r1,[r5,#4]            ;3810
000022  b129              CBZ      r1,|L13.48|
;;;3813   
;;;3814     switch (sClearInputConfig->ClearInputSource)
000024  2901              CMP      r1,#1
000026  d10c              BNE      |L13.66|
000028  e005              B        |L13.54|
                  |L13.42|
00002a  2002              MOVS     r0,#2                 ;3810
                  |L13.44|
;;;3815     {
;;;3816       case TIM_CLEARINPUTSOURCE_NONE:
;;;3817       {
;;;3818   
;;;3819         /* Clear the ETR Bits */
;;;3820         tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
;;;3821   
;;;3822         /* Set TIMx_SMCR */
;;;3823         htim->Instance->SMCR = tmpsmcr;
;;;3824      }
;;;3825       break;
;;;3826   
;;;3827       case TIM_CLEARINPUTSOURCE_ETR:
;;;3828       {
;;;3829         TIM_ETR_SetConfig(htim->Instance,
;;;3830                           sClearInputConfig->ClearInputPrescaler,
;;;3831                           sClearInputConfig->ClearInputPolarity,
;;;3832                           sClearInputConfig->ClearInputFilter);
;;;3833   
;;;3834       }
;;;3835       break;
;;;3836       default:
;;;3837       break;
;;;3838     }
;;;3839   
;;;3840     switch (Channel)
;;;3841     {
;;;3842       case TIM_CHANNEL_1:
;;;3843         {
;;;3844           if(sClearInputConfig->ClearInputState != RESET)
;;;3845           {
;;;3846             /* Enable the Ocref clear feature for Channel 1 */
;;;3847             htim->Instance->CCMR1 |= TIM_CCMR1_OC1CE;
;;;3848           }
;;;3849           else
;;;3850           {
;;;3851             /* Disable the Ocref clear feature for Channel 1 */
;;;3852           htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1CE;
;;;3853           }
;;;3854         }
;;;3855         break;
;;;3856       case TIM_CHANNEL_2:
;;;3857         {
;;;3858           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3859           if(sClearInputConfig->ClearInputState != RESET)
;;;3860           {
;;;3861             /* Enable the Ocref clear feature for Channel 2 */
;;;3862             htim->Instance->CCMR1 |= TIM_CCMR1_OC2CE;
;;;3863           }
;;;3864           else
;;;3865           {
;;;3866             /* Disable the Ocref clear feature for Channel 2 */
;;;3867             htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2CE;
;;;3868           }
;;;3869         }
;;;3870       break;
;;;3871       case TIM_CHANNEL_3:
;;;3872         {
;;;3873           assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3874           if(sClearInputConfig->ClearInputState != RESET)
;;;3875           {
;;;3876             /* Enable the Ocref clear feature for Channel 3 */
;;;3877             htim->Instance->CCMR2 |= TIM_CCMR2_OC3CE;
;;;3878           }
;;;3879           else
;;;3880           {
;;;3881             /* Disable the Ocref clear feature for Channel 3 */
;;;3882           htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3CE;
;;;3883           }
;;;3884         }
;;;3885       break;
;;;3886       case TIM_CHANNEL_4:
;;;3887         {
;;;3888           assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3889           if(sClearInputConfig->ClearInputState != RESET)
;;;3890           {
;;;3891             /* Enable the Ocref clear feature for Channel 4 */
;;;3892             htim->Instance->CCMR2 |= TIM_CCMR2_OC4CE;
;;;3893           }
;;;3894           else
;;;3895           {
;;;3896             /* Disable the Ocref clear feature for Channel 4 */
;;;3897           htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4CE;
;;;3898           }
;;;3899         }
;;;3900       break;
;;;3901       default:
;;;3902       break;
;;;3903     }
;;;3904   
;;;3905     htim->State = HAL_TIM_STATE_READY;
;;;3906   
;;;3907     __HAL_UNLOCK(htim);
;;;3908   
;;;3909     return HAL_OK;
;;;3910   }
00002c  e8bd81f0          POP      {r4-r8,pc}
                  |L13.48|
000030  6821              LDR      r1,[r4,#0]            ;3823
000032  6088              STR      r0,[r1,#8]            ;3823
000034  e005              B        |L13.66|
                  |L13.54|
000036  e9d52102          LDRD     r2,r1,[r5,#8]         ;3829
00003a  692b              LDR      r3,[r5,#0x10]         ;3829
00003c  6820              LDR      r0,[r4,#0]            ;3829
00003e  f7fffffe          BL       TIM_ETR_SetConfig
                  |L13.66|
000042  b137              CBZ      r7,|L13.82|
000044  2f04              CMP      r7,#4                 ;3840
000046  d00f              BEQ      |L13.104|
000048  2f08              CMP      r7,#8                 ;3840
00004a  d019              BEQ      |L13.128|
00004c  2f0c              CMP      r7,#0xc               ;3840
00004e  d12d              BNE      |L13.172|
000050  e021              B        |L13.150|
                  |L13.82|
000052  6828              LDR      r0,[r5,#0]            ;3844
000054  2800              CMP      r0,#0                 ;3844
000056  6820              LDR      r0,[r4,#0]            ;3852
000058  6981              LDR      r1,[r0,#0x18]         ;3852
00005a  d002              BEQ      |L13.98|
00005c  f0410180          ORR      r1,r1,#0x80           ;3847
000060  e00c              B        |L13.124|
                  |L13.98|
000062  f0210180          BIC      r1,r1,#0x80           ;3852
000066  e009              B        |L13.124|
                  |L13.104|
000068  6828              LDR      r0,[r5,#0]            ;3859
00006a  2800              CMP      r0,#0                 ;3859
00006c  6820              LDR      r0,[r4,#0]            ;3867
00006e  6981              LDR      r1,[r0,#0x18]         ;3867
000070  d002              BEQ      |L13.120|
000072  f4414100          ORR      r1,r1,#0x8000         ;3862
000076  e001              B        |L13.124|
                  |L13.120|
000078  f4214100          BIC      r1,r1,#0x8000         ;3867
                  |L13.124|
00007c  6181              STR      r1,[r0,#0x18]         ;3862
00007e  e015              B        |L13.172|
                  |L13.128|
000080  6828              LDR      r0,[r5,#0]            ;3874
000082  2800              CMP      r0,#0                 ;3874
000084  6820              LDR      r0,[r4,#0]            ;3882
000086  69c1              LDR      r1,[r0,#0x1c]         ;3882
000088  d002              BEQ      |L13.144|
00008a  f0410180          ORR      r1,r1,#0x80           ;3877
00008e  e00c              B        |L13.170|
                  |L13.144|
000090  f0210180          BIC      r1,r1,#0x80           ;3882
000094  e009              B        |L13.170|
                  |L13.150|
000096  6828              LDR      r0,[r5,#0]            ;3889
000098  2800              CMP      r0,#0                 ;3889
00009a  6820              LDR      r0,[r4,#0]            ;3897
00009c  69c1              LDR      r1,[r0,#0x1c]         ;3897
00009e  d002              BEQ      |L13.166|
0000a0  f4414100          ORR      r1,r1,#0x8000         ;3892
0000a4  e001              B        |L13.170|
                  |L13.166|
0000a6  f4214100          BIC      r1,r1,#0x8000         ;3897
                  |L13.170|
0000aa  61c1              STR      r1,[r0,#0x1c]         ;3892
                  |L13.172|
0000ac  f884603d          STRB     r6,[r4,#0x3d]         ;3905
0000b0  2000              MOVS     r0,#0                 ;3907
0000b2  f884003c          STRB     r0,[r4,#0x3c]         ;3907
0000b6  e7b9              B        |L13.44|
;;;3911   
                          ENDP


                          AREA ||i.HAL_TIM_ConfigTI1Input||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigTI1Input PROC
;;;4092     */
;;;4093   HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
000000  6802              LDR      r2,[r0,#0]
;;;4094   {
;;;4095     uint32_t tmpcr2 = 0U;
;;;4096   
;;;4097     /* Check the parameters */
;;;4098     assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;4099     assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
;;;4100   
;;;4101     /* Get the TIMx CR2 register value */
;;;4102     tmpcr2 = htim->Instance->CR2;
000002  6850              LDR      r0,[r2,#4]
;;;4103   
;;;4104     /* Reset the TI1 selection */
;;;4105     tmpcr2 &= ~TIM_CR2_TI1S;
000004  f0200080          BIC      r0,r0,#0x80
;;;4106   
;;;4107     /* Set the the TI1 selection */
;;;4108     tmpcr2 |= TI1_Selection;
000008  4308              ORRS     r0,r0,r1
;;;4109   
;;;4110     /* Write to TIMxCR2 */
;;;4111     htim->Instance->CR2 = tmpcr2;
00000a  6050              STR      r0,[r2,#4]
;;;4112   
;;;4113     return HAL_OK;
00000c  2000              MOVS     r0,#0
;;;4114   }
00000e  4770              BX       lr
;;;4115   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_ReadStart||, CODE, READONLY, ALIGN=2

                  HAL_TIM_DMABurst_ReadStart PROC
;;;3556     */
;;;3557   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3558                                                uint32_t  *BurstBuffer, uint32_t  BurstLength)
;;;3559   {
000004  4604              MOV      r4,r0
;;;3560     /* Check the parameters */
;;;3561     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;3562     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;3563     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3564     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;3565   
;;;3566     if((htim->State == HAL_TIM_STATE_BUSY))
000006  f890003d          LDRB     r0,[r0,#0x3d]
00000a  9d06              LDR      r5,[sp,#0x18]
00000c  469c              MOV      r12,r3                ;3559
00000e  4616              MOV      r6,r2                 ;3559
000010  4688              MOV      r8,r1                 ;3559
000012  2802              CMP      r0,#2
000014  d007              BEQ      |L15.38|
;;;3567     {
;;;3568        return HAL_BUSY;
;;;3569     }
;;;3570     else if((htim->State == HAL_TIM_STATE_READY))
000016  f894003d          LDRB     r0,[r4,#0x3d]
00001a  2801              CMP      r0,#1
00001c  d108              BNE      |L15.48|
;;;3571     {
;;;3572       if((BurstBuffer == 0U) && (BurstLength > 0U))
00001e  f1bc0f00          CMP      r12,#0
000022  d102              BNE      |L15.42|
000024  b10d              CBZ      r5,|L15.42|
                  |L15.38|
;;;3573       {
;;;3574         return HAL_ERROR;
;;;3575       }
;;;3576       else
;;;3577       {
;;;3578         htim->State = HAL_TIM_STATE_BUSY;
;;;3579       }
;;;3580     }
;;;3581     switch(BurstRequestSrc)
;;;3582     {
;;;3583       case TIM_DMA_UPDATE:
;;;3584       {
;;;3585         /* Set the DMA Period elapsed callback */
;;;3586         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;3587   
;;;3588         /* Set the DMA error callback */
;;;3589         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;3590   
;;;3591         /* Enable the DMA channel */
;;;3592          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
;;;3593       }
;;;3594       break;
;;;3595       case TIM_DMA_CC1:
;;;3596       {
;;;3597         /* Set the DMA Period elapsed callback */
;;;3598         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback =  TIM_DMACaptureCplt;
;;;3599   
;;;3600         /* Set the DMA error callback */
;;;3601         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;3602   
;;;3603         /* Enable the DMA channel */
;;;3604         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
;;;3605       }
;;;3606       break;
;;;3607       case TIM_DMA_CC2:
;;;3608       {
;;;3609         /* Set the DMA Period elapsed callback */
;;;3610         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback =  TIM_DMACaptureCplt;
;;;3611   
;;;3612         /* Set the DMA error callback */
;;;3613         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;3614   
;;;3615         /* Enable the DMA channel */
;;;3616         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
;;;3617       }
;;;3618       break;
;;;3619       case TIM_DMA_CC3:
;;;3620       {
;;;3621         /* Set the DMA Period elapsed callback */
;;;3622         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback =  TIM_DMACaptureCplt;
;;;3623   
;;;3624         /* Set the DMA error callback */
;;;3625         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;3626   
;;;3627         /* Enable the DMA channel */
;;;3628         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
;;;3629       }
;;;3630       break;
;;;3631       case TIM_DMA_CC4:
;;;3632       {
;;;3633         /* Set the DMA Period elapsed callback */
;;;3634         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback =  TIM_DMACaptureCplt;
;;;3635   
;;;3636         /* Set the DMA error callback */
;;;3637         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;3638   
;;;3639         /* Enable the DMA channel */
;;;3640         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
;;;3641       }
;;;3642       break;
;;;3643       case TIM_DMA_COM:
;;;3644       {
;;;3645         /* Set the DMA Period elapsed callback */
;;;3646         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
;;;3647   
;;;3648         /* Set the DMA error callback */
;;;3649         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
;;;3650   
;;;3651         /* Enable the DMA channel */
;;;3652         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
;;;3653       }
;;;3654       break;
;;;3655       case TIM_DMA_TRIGGER:
;;;3656       {
;;;3657         /* Set the DMA Period elapsed callback */
;;;3658         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;3659   
;;;3660         /* Set the DMA error callback */
;;;3661         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
;;;3662   
;;;3663         /* Enable the DMA channel */
;;;3664         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
;;;3665       }
;;;3666       break;
;;;3667       default:
;;;3668       break;
;;;3669     }
;;;3670   
;;;3671     /* configure the DMA Burst Mode */
;;;3672     htim->Instance->DCR = BurstBaseAddress | BurstLength;
;;;3673   
;;;3674     /* Enable the TIM DMA Request */
;;;3675     __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
;;;3676   
;;;3677     htim->State = HAL_TIM_STATE_READY;
;;;3678   
;;;3679     /* Return function status */
;;;3680     return HAL_OK;
;;;3681   }
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L15.42|
00002a  2002              MOVS     r0,#2                 ;3578
00002c  f884003d          STRB     r0,[r4,#0x3d]         ;3578
                  |L15.48|
000030  2701              MOVS     r7,#1                 ;3574
000032  482f              LDR      r0,|L15.240|
000034  492f              LDR      r1,|L15.244|
000036  eb072315          ADD      r3,r7,r5,LSR #8       ;3592
00003a  f5b66f00          CMP      r6,#0x800             ;3581
00003e  d039              BEQ      |L15.180|
000040  dc09              BGT      |L15.86|
000042  f5b67f80          CMP      r6,#0x100             ;3581
000046  d010              BEQ      |L15.106|
000048  f5b67f00          CMP      r6,#0x200             ;3581
00004c  d015              BEQ      |L15.122|
00004e  f5b66f80          CMP      r6,#0x400             ;3581
000052  d11c              BNE      |L15.142|
000054  e027              B        |L15.166|
                  |L15.86|
000056  f5b65f80          CMP      r6,#0x1000            ;3581
00005a  d032              BEQ      |L15.194|
00005c  f5b65f00          CMP      r6,#0x2000            ;3581
000060  d036              BEQ      |L15.208|
000062  f5b64f80          CMP      r6,#0x4000            ;3581
000066  d112              BNE      |L15.142|
000068  e03a              B        |L15.224|
                  |L15.106|
00006a  6a22              LDR      r2,[r4,#0x20]         ;3586
00006c  4922              LDR      r1,|L15.248|
00006e  6291              STR      r1,[r2,#0x28]         ;3589
000070  6a21              LDR      r1,[r4,#0x20]         ;3589
000072  6308              STR      r0,[r1,#0x30]         ;3592
000074  6821              LDR      r1,[r4,#0]            ;3594
000076  6a20              LDR      r0,[r4,#0x20]         ;3594
000078  e005              B        |L15.134|
                  |L15.122|
00007a  6a62              LDR      r2,[r4,#0x24]         ;3598
00007c  6291              STR      r1,[r2,#0x28]         ;3601
00007e  6a61              LDR      r1,[r4,#0x24]         ;3601
000080  6308              STR      r0,[r1,#0x30]         ;3604
000082  6821              LDR      r1,[r4,#0]            ;3604
000084  6a60              LDR      r0,[r4,#0x24]         ;3604
                  |L15.134|
000086  4662              MOV      r2,r12                ;3592
000088  314c              ADDS     r1,r1,#0x4c           ;3592
00008a  f7fffffe          BL       HAL_DMA_Start_IT
                  |L15.142|
00008e  6821              LDR      r1,[r4,#0]            ;3672
000090  ea480005          ORR      r0,r8,r5              ;3672
000094  6488              STR      r0,[r1,#0x48]         ;3672
000096  6820              LDR      r0,[r4,#0]            ;3675
000098  68c1              LDR      r1,[r0,#0xc]          ;3675
00009a  4331              ORRS     r1,r1,r6              ;3675
00009c  60c1              STR      r1,[r0,#0xc]          ;3675
00009e  f884703d          STRB     r7,[r4,#0x3d]         ;3677
0000a2  2000              MOVS     r0,#0                 ;3680
0000a4  e7bf              B        |L15.38|
                  |L15.166|
0000a6  6aa2              LDR      r2,[r4,#0x28]         ;3610
0000a8  6291              STR      r1,[r2,#0x28]         ;3613
0000aa  6aa1              LDR      r1,[r4,#0x28]         ;3613
0000ac  6308              STR      r0,[r1,#0x30]         ;3616
0000ae  6821              LDR      r1,[r4,#0]            ;3618
0000b0  6aa0              LDR      r0,[r4,#0x28]         ;3618
0000b2  e7e8              B        |L15.134|
                  |L15.180|
0000b4  6ae2              LDR      r2,[r4,#0x2c]         ;3622
0000b6  6291              STR      r1,[r2,#0x28]         ;3625
0000b8  6ae1              LDR      r1,[r4,#0x2c]         ;3625
0000ba  6308              STR      r0,[r1,#0x30]         ;3628
0000bc  6821              LDR      r1,[r4,#0]            ;3630
0000be  6ae0              LDR      r0,[r4,#0x2c]         ;3630
0000c0  e7e1              B        |L15.134|
                  |L15.194|
0000c2  6b22              LDR      r2,[r4,#0x30]         ;3634
0000c4  6291              STR      r1,[r2,#0x28]         ;3637
0000c6  6b21              LDR      r1,[r4,#0x30]         ;3637
0000c8  6308              STR      r0,[r1,#0x30]         ;3640
0000ca  6821              LDR      r1,[r4,#0]            ;3642
0000cc  6b20              LDR      r0,[r4,#0x30]         ;3642
0000ce  e7da              B        |L15.134|
                  |L15.208|
0000d0  6b62              LDR      r2,[r4,#0x34]         ;3646
0000d2  490a              LDR      r1,|L15.252|
0000d4  6291              STR      r1,[r2,#0x28]         ;3649
0000d6  6b61              LDR      r1,[r4,#0x34]         ;3649
0000d8  6308              STR      r0,[r1,#0x30]         ;3652
0000da  6821              LDR      r1,[r4,#0]            ;3654
0000dc  6b60              LDR      r0,[r4,#0x34]         ;3654
0000de  e7d2              B        |L15.134|
                  |L15.224|
0000e0  6ba2              LDR      r2,[r4,#0x38]         ;3658
0000e2  4907              LDR      r1,|L15.256|
0000e4  6291              STR      r1,[r2,#0x28]         ;3661
0000e6  6ba1              LDR      r1,[r4,#0x38]         ;3661
0000e8  6308              STR      r0,[r1,#0x30]         ;3664
0000ea  6821              LDR      r1,[r4,#0]            ;3666
0000ec  6ba0              LDR      r0,[r4,#0x38]         ;3666
0000ee  e7ca              B        |L15.134|
;;;3682   
                          ENDP

                  |L15.240|
                          DCD      TIM_DMAError
                  |L15.244|
                          DCD      TIM_DMACaptureCplt
                  |L15.248|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L15.252|
                          DCD      TIMEx_DMACommutationCplt
                  |L15.256|
                          DCD      TIM_DMATriggerCplt

                          AREA ||i.HAL_TIM_DMABurst_ReadStop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_ReadStop PROC
;;;3688     */
;;;3689   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
000000  b570              PUSH     {r4-r6,lr}
;;;3690   {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;3691     /* Check the parameters */
;;;3692     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3693   
;;;3694     /* Abort the DMA transfer (at least disable the DMA channel) */
;;;3695     switch(BurstRequestSrc)
000006  f5b16f00          CMP      r1,#0x800
00000a  d021              BEQ      |L16.80|
00000c  dc09              BGT      |L16.34|
00000e  f5b57f80          CMP      r5,#0x100
000012  d010              BEQ      |L16.54|
000014  f5b57f00          CMP      r5,#0x200
000018  d00f              BEQ      |L16.58|
00001a  f5b56f80          CMP      r5,#0x400
00001e  d10f              BNE      |L16.64|
000020  e014              B        |L16.76|
                  |L16.34|
000022  f5b55f80          CMP      r5,#0x1000
000026  d015              BEQ      |L16.84|
000028  f5b55f00          CMP      r5,#0x2000
00002c  d014              BEQ      |L16.88|
00002e  f5b54f80          CMP      r5,#0x4000
000032  d105              BNE      |L16.64|
000034  e012              B        |L16.92|
                  |L16.54|
;;;3696     {
;;;3697       case TIM_DMA_UPDATE:
;;;3698       {
;;;3699         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
;;;3700       }
;;;3701       break;
000036  6a20              LDR      r0,[r4,#0x20]
000038  e000              B        |L16.60|
                  |L16.58|
;;;3702       case TIM_DMA_CC1:
;;;3703       {
;;;3704         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
00003a  6a60              LDR      r0,[r4,#0x24]
                  |L16.60|
00003c  f7fffffe          BL       HAL_DMA_Abort
                  |L16.64|
;;;3705       }
;;;3706       break;
;;;3707       case TIM_DMA_CC2:
;;;3708       {
;;;3709         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
;;;3710       }
;;;3711       break;
;;;3712       case TIM_DMA_CC3:
;;;3713       {
;;;3714         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
;;;3715       }
;;;3716       break;
;;;3717       case TIM_DMA_CC4:
;;;3718       {
;;;3719         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
;;;3720       }
;;;3721       break;
;;;3722       case TIM_DMA_COM:
;;;3723       {
;;;3724         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
;;;3725       }
;;;3726       break;
;;;3727       case TIM_DMA_TRIGGER:
;;;3728       {
;;;3729         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
;;;3730       }
;;;3731       break;
;;;3732       default:
;;;3733       break;
;;;3734     }
;;;3735   
;;;3736     /* Disable the TIM Update DMA request */
;;;3737     __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
000040  6820              LDR      r0,[r4,#0]
000042  68c1              LDR      r1,[r0,#0xc]
000044  43a9              BICS     r1,r1,r5
000046  60c1              STR      r1,[r0,#0xc]
;;;3738   
;;;3739     /* Return function status */
;;;3740     return HAL_OK;
000048  2000              MOVS     r0,#0
;;;3741   }
00004a  bd70              POP      {r4-r6,pc}
                  |L16.76|
00004c  6aa0              LDR      r0,[r4,#0x28]         ;3711
00004e  e7f5              B        |L16.60|
                  |L16.80|
000050  6ae0              LDR      r0,[r4,#0x2c]         ;3716
000052  e7f3              B        |L16.60|
                  |L16.84|
000054  6b20              LDR      r0,[r4,#0x30]         ;3721
000056  e7f1              B        |L16.60|
                  |L16.88|
000058  6b60              LDR      r0,[r4,#0x34]         ;3726
00005a  e7ef              B        |L16.60|
                  |L16.92|
00005c  6ba0              LDR      r0,[r4,#0x38]         ;3731
00005e  e7ed              B        |L16.60|
;;;3742   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_WriteStart||, CODE, READONLY, ALIGN=2

                  HAL_TIM_DMABurst_WriteStart PROC
;;;3333     */
;;;3334   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3335                                                 uint32_t* BurstBuffer, uint32_t  BurstLength)
;;;3336   {
000004  4604              MOV      r4,r0
;;;3337     /* Check the parameters */
;;;3338     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;3339     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;3340     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3341     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;3342   
;;;3343     if((htim->State == HAL_TIM_STATE_BUSY))
000006  f890003d          LDRB     r0,[r0,#0x3d]
00000a  9d06              LDR      r5,[sp,#0x18]
00000c  469c              MOV      r12,r3                ;3336
00000e  4616              MOV      r6,r2                 ;3336
000010  4688              MOV      r8,r1                 ;3336
000012  2802              CMP      r0,#2
000014  d007              BEQ      |L17.38|
;;;3344     {
;;;3345        return HAL_BUSY;
;;;3346     }
;;;3347     else if((htim->State == HAL_TIM_STATE_READY))
000016  f894003d          LDRB     r0,[r4,#0x3d]
00001a  2801              CMP      r0,#1
00001c  d108              BNE      |L17.48|
;;;3348     {
;;;3349       if((BurstBuffer == 0U) && (BurstLength > 0U))
00001e  f1bc0f00          CMP      r12,#0
000022  d102              BNE      |L17.42|
000024  b10d              CBZ      r5,|L17.42|
                  |L17.38|
;;;3350       {
;;;3351         return HAL_ERROR;
;;;3352       }
;;;3353       else
;;;3354       {
;;;3355         htim->State = HAL_TIM_STATE_BUSY;
;;;3356       }
;;;3357     }
;;;3358     switch(BurstRequestSrc)
;;;3359     {
;;;3360       case TIM_DMA_UPDATE:
;;;3361       {
;;;3362         /* Set the DMA Period elapsed callback */
;;;3363         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;3364   
;;;3365         /* Set the DMA error callback */
;;;3366         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;3367   
;;;3368         /* Enable the DMA channel */
;;;3369         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
;;;3370       }
;;;3371       break;
;;;3372       case TIM_DMA_CC1:
;;;3373       {
;;;3374         /* Set the DMA Period elapsed callback */
;;;3375         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback =  TIM_DMADelayPulseCplt;
;;;3376   
;;;3377         /* Set the DMA error callback */
;;;3378         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;3379   
;;;3380         /* Enable the DMA channel */
;;;3381         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
;;;3382       }
;;;3383       break;
;;;3384       case TIM_DMA_CC2:
;;;3385       {
;;;3386         /* Set the DMA Period elapsed callback */
;;;3387         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback =  TIM_DMADelayPulseCplt;
;;;3388   
;;;3389         /* Set the DMA error callback */
;;;3390         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;3391   
;;;3392         /* Enable the DMA channel */
;;;3393         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
;;;3394       }
;;;3395       break;
;;;3396       case TIM_DMA_CC3:
;;;3397       {
;;;3398         /* Set the DMA Period elapsed callback */
;;;3399         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback =  TIM_DMADelayPulseCplt;
;;;3400   
;;;3401         /* Set the DMA error callback */
;;;3402         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;3403   
;;;3404         /* Enable the DMA channel */
;;;3405         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
;;;3406       }
;;;3407       break;
;;;3408       case TIM_DMA_CC4:
;;;3409       {
;;;3410         /* Set the DMA Period elapsed callback */
;;;3411         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback =  TIM_DMADelayPulseCplt;
;;;3412   
;;;3413         /* Set the DMA error callback */
;;;3414         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;3415   
;;;3416         /* Enable the DMA channel */
;;;3417         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
;;;3418       }
;;;3419       break;
;;;3420       case TIM_DMA_COM:
;;;3421       {
;;;3422         /* Set the DMA Period elapsed callback */
;;;3423         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
;;;3424   
;;;3425         /* Set the DMA error callback */
;;;3426         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
;;;3427   
;;;3428         /* Enable the DMA channel */
;;;3429         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
;;;3430       }
;;;3431       break;
;;;3432       case TIM_DMA_TRIGGER:
;;;3433       {
;;;3434         /* Set the DMA Period elapsed callback */
;;;3435         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;3436   
;;;3437         /* Set the DMA error callback */
;;;3438         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
;;;3439   
;;;3440         /* Enable the DMA channel */
;;;3441         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
;;;3442       }
;;;3443       break;
;;;3444       default:
;;;3445       break;
;;;3446     }
;;;3447      /* configure the DMA Burst Mode */
;;;3448      htim->Instance->DCR = BurstBaseAddress | BurstLength;
;;;3449   
;;;3450      /* Enable the TIM DMA Request */
;;;3451      __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
;;;3452   
;;;3453      htim->State = HAL_TIM_STATE_READY;
;;;3454   
;;;3455     /* Return function status */
;;;3456     return HAL_OK;
;;;3457   }
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L17.42|
00002a  2002              MOVS     r0,#2                 ;3355
00002c  f884003d          STRB     r0,[r4,#0x3d]         ;3355
                  |L17.48|
000030  2701              MOVS     r7,#1                 ;3351
000032  482f              LDR      r0,|L17.240|
000034  492f              LDR      r1,|L17.244|
000036  eb072315          ADD      r3,r7,r5,LSR #8       ;3369
00003a  f5b66f00          CMP      r6,#0x800             ;3358
00003e  d039              BEQ      |L17.180|
000040  dc09              BGT      |L17.86|
000042  f5b67f80          CMP      r6,#0x100             ;3358
000046  d010              BEQ      |L17.106|
000048  f5b67f00          CMP      r6,#0x200             ;3358
00004c  d015              BEQ      |L17.122|
00004e  f5b66f80          CMP      r6,#0x400             ;3358
000052  d11c              BNE      |L17.142|
000054  e027              B        |L17.166|
                  |L17.86|
000056  f5b65f80          CMP      r6,#0x1000            ;3358
00005a  d032              BEQ      |L17.194|
00005c  f5b65f00          CMP      r6,#0x2000            ;3358
000060  d036              BEQ      |L17.208|
000062  f5b64f80          CMP      r6,#0x4000            ;3358
000066  d112              BNE      |L17.142|
000068  e03a              B        |L17.224|
                  |L17.106|
00006a  6a22              LDR      r2,[r4,#0x20]         ;3363
00006c  4922              LDR      r1,|L17.248|
00006e  6291              STR      r1,[r2,#0x28]         ;3366
000070  6a21              LDR      r1,[r4,#0x20]         ;3366
000072  6308              STR      r0,[r1,#0x30]         ;3369
000074  6822              LDR      r2,[r4,#0]            ;3371
000076  6a20              LDR      r0,[r4,#0x20]         ;3371
000078  e005              B        |L17.134|
                  |L17.122|
00007a  6a62              LDR      r2,[r4,#0x24]         ;3375
00007c  6291              STR      r1,[r2,#0x28]         ;3378
00007e  6a61              LDR      r1,[r4,#0x24]         ;3378
000080  6308              STR      r0,[r1,#0x30]         ;3381
000082  6822              LDR      r2,[r4,#0]            ;3381
000084  6a60              LDR      r0,[r4,#0x24]         ;3381
                  |L17.134|
000086  4661              MOV      r1,r12                ;3369
000088  324c              ADDS     r2,r2,#0x4c           ;3369
00008a  f7fffffe          BL       HAL_DMA_Start_IT
                  |L17.142|
00008e  6821              LDR      r1,[r4,#0]            ;3448
000090  ea480005          ORR      r0,r8,r5              ;3448
000094  6488              STR      r0,[r1,#0x48]         ;3448
000096  6820              LDR      r0,[r4,#0]            ;3451
000098  68c1              LDR      r1,[r0,#0xc]          ;3451
00009a  4331              ORRS     r1,r1,r6              ;3451
00009c  60c1              STR      r1,[r0,#0xc]          ;3451
00009e  f884703d          STRB     r7,[r4,#0x3d]         ;3453
0000a2  2000              MOVS     r0,#0                 ;3456
0000a4  e7bf              B        |L17.38|
                  |L17.166|
0000a6  6aa2              LDR      r2,[r4,#0x28]         ;3387
0000a8  6291              STR      r1,[r2,#0x28]         ;3390
0000aa  6aa1              LDR      r1,[r4,#0x28]         ;3390
0000ac  6308              STR      r0,[r1,#0x30]         ;3393
0000ae  6822              LDR      r2,[r4,#0]            ;3395
0000b0  6aa0              LDR      r0,[r4,#0x28]         ;3395
0000b2  e7e8              B        |L17.134|
                  |L17.180|
0000b4  6ae2              LDR      r2,[r4,#0x2c]         ;3399
0000b6  6291              STR      r1,[r2,#0x28]         ;3402
0000b8  6ae1              LDR      r1,[r4,#0x2c]         ;3402
0000ba  6308              STR      r0,[r1,#0x30]         ;3405
0000bc  6822              LDR      r2,[r4,#0]            ;3407
0000be  6ae0              LDR      r0,[r4,#0x2c]         ;3407
0000c0  e7e1              B        |L17.134|
                  |L17.194|
0000c2  6b22              LDR      r2,[r4,#0x30]         ;3411
0000c4  6291              STR      r1,[r2,#0x28]         ;3414
0000c6  6b21              LDR      r1,[r4,#0x30]         ;3414
0000c8  6308              STR      r0,[r1,#0x30]         ;3417
0000ca  6822              LDR      r2,[r4,#0]            ;3419
0000cc  6b20              LDR      r0,[r4,#0x30]         ;3419
0000ce  e7da              B        |L17.134|
                  |L17.208|
0000d0  6b62              LDR      r2,[r4,#0x34]         ;3423
0000d2  490a              LDR      r1,|L17.252|
0000d4  6291              STR      r1,[r2,#0x28]         ;3426
0000d6  6b61              LDR      r1,[r4,#0x34]         ;3426
0000d8  6308              STR      r0,[r1,#0x30]         ;3429
0000da  6822              LDR      r2,[r4,#0]            ;3431
0000dc  6b60              LDR      r0,[r4,#0x34]         ;3431
0000de  e7d2              B        |L17.134|
                  |L17.224|
0000e0  6ba2              LDR      r2,[r4,#0x38]         ;3435
0000e2  4907              LDR      r1,|L17.256|
0000e4  6291              STR      r1,[r2,#0x28]         ;3438
0000e6  6ba1              LDR      r1,[r4,#0x38]         ;3438
0000e8  6308              STR      r0,[r1,#0x30]         ;3441
0000ea  6822              LDR      r2,[r4,#0]            ;3443
0000ec  6ba0              LDR      r0,[r4,#0x38]         ;3443
0000ee  e7ca              B        |L17.134|
;;;3458   
                          ENDP

                  |L17.240|
                          DCD      TIM_DMAError
                  |L17.244|
                          DCD      TIM_DMADelayPulseCplt
                  |L17.248|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L17.252|
                          DCD      TIMEx_DMACommutationCplt
                  |L17.256|
                          DCD      TIM_DMATriggerCplt

                          AREA ||i.HAL_TIM_DMABurst_WriteStop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_WriteStop PROC
;;;3464     */
;;;3465   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
000000  b570              PUSH     {r4-r6,lr}
;;;3466   {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;3467     /* Check the parameters */
;;;3468     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3469   
;;;3470     /* Abort the DMA transfer (at least disable the DMA channel) */
;;;3471     switch(BurstRequestSrc)
000006  f5b16f00          CMP      r1,#0x800
00000a  d021              BEQ      |L18.80|
00000c  dc09              BGT      |L18.34|
00000e  f5b57f80          CMP      r5,#0x100
000012  d010              BEQ      |L18.54|
000014  f5b57f00          CMP      r5,#0x200
000018  d00f              BEQ      |L18.58|
00001a  f5b56f80          CMP      r5,#0x400
00001e  d10f              BNE      |L18.64|
000020  e014              B        |L18.76|
                  |L18.34|
000022  f5b55f80          CMP      r5,#0x1000
000026  d015              BEQ      |L18.84|
000028  f5b55f00          CMP      r5,#0x2000
00002c  d014              BEQ      |L18.88|
00002e  f5b54f80          CMP      r5,#0x4000
000032  d105              BNE      |L18.64|
000034  e012              B        |L18.92|
                  |L18.54|
;;;3472     {
;;;3473       case TIM_DMA_UPDATE:
;;;3474       {
;;;3475         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
;;;3476       }
;;;3477       break;
000036  6a20              LDR      r0,[r4,#0x20]
000038  e000              B        |L18.60|
                  |L18.58|
;;;3478       case TIM_DMA_CC1:
;;;3479       {
;;;3480         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
00003a  6a60              LDR      r0,[r4,#0x24]
                  |L18.60|
00003c  f7fffffe          BL       HAL_DMA_Abort
                  |L18.64|
;;;3481       }
;;;3482       break;
;;;3483       case TIM_DMA_CC2:
;;;3484       {
;;;3485         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
;;;3486       }
;;;3487       break;
;;;3488       case TIM_DMA_CC3:
;;;3489       {
;;;3490         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
;;;3491       }
;;;3492       break;
;;;3493       case TIM_DMA_CC4:
;;;3494       {
;;;3495         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
;;;3496       }
;;;3497       break;
;;;3498       case TIM_DMA_COM:
;;;3499       {
;;;3500         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
;;;3501       }
;;;3502       break;
;;;3503       case TIM_DMA_TRIGGER:
;;;3504       {
;;;3505         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
;;;3506       }
;;;3507       break;
;;;3508       default:
;;;3509       break;
;;;3510     }
;;;3511   
;;;3512     /* Disable the TIM Update DMA request */
;;;3513     __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
000040  6820              LDR      r0,[r4,#0]
000042  68c1              LDR      r1,[r0,#0xc]
000044  43a9              BICS     r1,r1,r5
000046  60c1              STR      r1,[r0,#0xc]
;;;3514   
;;;3515     /* Return function status */
;;;3516     return HAL_OK;
000048  2000              MOVS     r0,#0
;;;3517   }
00004a  bd70              POP      {r4-r6,pc}
                  |L18.76|
00004c  6aa0              LDR      r0,[r4,#0x28]         ;3487
00004e  e7f5              B        |L18.60|
                  |L18.80|
000050  6ae0              LDR      r0,[r4,#0x2c]         ;3492
000052  e7f3              B        |L18.60|
                  |L18.84|
000054  6b20              LDR      r0,[r4,#0x30]         ;3497
000056  e7f1              B        |L18.60|
                  |L18.88|
000058  6b60              LDR      r0,[r4,#0x34]         ;3502
00005a  e7ef              B        |L18.60|
                  |L18.92|
00005c  6ba0              LDR      r0,[r4,#0x38]         ;3507
00005e  e7ed              B        |L18.60|
;;;3518   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_DeInit PROC
;;;2342     */
;;;2343   HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;2344   {
000002  4604              MOV      r4,r0
;;;2345     /* Check the parameters */
;;;2346     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2347   
;;;2348     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f884003d          STRB     r0,[r4,#0x3d]
;;;2349   
;;;2350     /* Disable the TIM Peripheral Clock */
;;;2351     __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L19.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L19.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L19.38|
;;;2352   
;;;2353     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;2354     HAL_TIM_Encoder_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_Encoder_MspDeInit
;;;2355   
;;;2356     /* Change TIM state */
;;;2357     htim->State = HAL_TIM_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  f884003d          STRB     r0,[r4,#0x3d]
;;;2358   
;;;2359     /* Release Lock */
;;;2360     __HAL_UNLOCK(htim);
000032  f884003c          STRB     r0,[r4,#0x3c]
;;;2361   
;;;2362     return HAL_OK;
;;;2363   }
000036  bd10              POP      {r4,pc}
;;;2364   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_GetState PROC
;;;4436     */
;;;4437   HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
000000  f890003d          LDRB     r0,[r0,#0x3d]
;;;4438   {
;;;4439     return htim->State;
;;;4440   }
000004  4770              BX       lr
;;;4441   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Init PROC
;;;2249     */
;;;2250   HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef* sConfig)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2251   {
000004  460d              MOV      r5,r1
000006  0004              MOVS     r4,r0
000008  d003              BEQ      |L21.18|
;;;2252     uint32_t tmpsmcr = 0U;
;;;2253     uint32_t tmpccmr1 = 0U;
;;;2254     uint32_t tmpccer = 0U;
;;;2255   
;;;2256     /* Check the TIM handle allocation */
;;;2257     if(htim == NULL)
;;;2258     {
;;;2259       return HAL_ERROR;
;;;2260     }
;;;2261   
;;;2262     /* Check the parameters */
;;;2263     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2264     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;2265     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;2266     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;2267     assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
;;;2268     assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
;;;2269     assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
;;;2270     assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
;;;2271     assert_param(IS_TIM_IC_POLARITY(sConfig->IC2Polarity));
;;;2272     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
;;;2273     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
;;;2274     assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
;;;2275     assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
;;;2276   
;;;2277     if(htim->State == HAL_TIM_STATE_RESET)
00000a  f894003d          LDRB     r0,[r4,#0x3d]
00000e  b118              CBZ      r0,|L21.24|
000010  e008              B        |L21.36|
                  |L21.18|
000012  2001              MOVS     r0,#1                 ;2259
                  |L21.20|
;;;2278     {
;;;2279       /* Allocate lock resource and initialize it */
;;;2280       htim->Lock = HAL_UNLOCKED;
;;;2281       
;;;2282       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;2283       HAL_TIM_Encoder_MspInit(htim);
;;;2284     }
;;;2285   
;;;2286     /* Set the TIM state */
;;;2287     htim->State= HAL_TIM_STATE_BUSY;
;;;2288   
;;;2289     /* Reset the SMS bits */
;;;2290     htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;2291   
;;;2292     /* Configure the Time base in the Encoder Mode */
;;;2293     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;2294   
;;;2295     /* Get the TIMx SMCR register value */
;;;2296     tmpsmcr = htim->Instance->SMCR;
;;;2297   
;;;2298     /* Get the TIMx CCMR1 register value */
;;;2299     tmpccmr1 = htim->Instance->CCMR1;
;;;2300   
;;;2301     /* Get the TIMx CCER register value */
;;;2302     tmpccer = htim->Instance->CCER;
;;;2303   
;;;2304     /* Set the encoder Mode */
;;;2305     tmpsmcr |= sConfig->EncoderMode;
;;;2306   
;;;2307     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;2308     tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
;;;2309     tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
;;;2310   
;;;2311     /* Set the the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
;;;2312     tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
;;;2313     tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
;;;2314     tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8U);
;;;2315     tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
;;;2316   
;;;2317     /* Set the TI1 and the TI2 Polarities */
;;;2318     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
;;;2319     tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
;;;2320     tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
;;;2321   
;;;2322     /* Write to TIMx SMCR */
;;;2323     htim->Instance->SMCR = tmpsmcr;
;;;2324   
;;;2325     /* Write to TIMx CCMR1 */
;;;2326     htim->Instance->CCMR1 = tmpccmr1;
;;;2327   
;;;2328     /* Write to TIMx CCER */
;;;2329     htim->Instance->CCER = tmpccer;
;;;2330   
;;;2331     /* Initialize the TIM state*/
;;;2332     htim->State= HAL_TIM_STATE_READY;
;;;2333   
;;;2334     return HAL_OK;
;;;2335   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L21.24|
000018  2000              MOVS     r0,#0                 ;2280
00001a  f884003c          STRB     r0,[r4,#0x3c]         ;2280
00001e  4620              MOV      r0,r4                 ;2283
000020  f7fffffe          BL       HAL_TIM_Encoder_MspInit
                  |L21.36|
000024  2002              MOVS     r0,#2                 ;2287
000026  f884003d          STRB     r0,[r4,#0x3d]         ;2287
00002a  6820              LDR      r0,[r4,#0]            ;2290
00002c  6881              LDR      r1,[r0,#8]            ;2290
00002e  f0210107          BIC      r1,r1,#7              ;2290
000032  6081              STR      r1,[r0,#8]            ;2290
000034  1d21              ADDS     r1,r4,#4              ;2293
000036  6820              LDR      r0,[r4,#0]            ;2293
000038  f7fffffe          BL       TIM_Base_SetConfig
00003c  6822              LDR      r2,[r4,#0]            ;2296
00003e  6890              LDR      r0,[r2,#8]            ;2296
000040  6991              LDR      r1,[r2,#0x18]         ;2299
000042  6a16              LDR      r6,[r2,#0x20]         ;2302
000044  682b              LDR      r3,[r5,#0]            ;2305
000046  69af              LDR      r7,[r5,#0x18]         ;2309
000048  4303              ORRS     r3,r3,r0              ;2305
00004a  f2403003          MOV      r0,#0x303             ;2308
00004e  4381              BICS     r1,r1,r0              ;2308
000050  ea412107          ORR      r1,r1,r7,LSL #8       ;2309
000054  68a8              LDR      r0,[r5,#8]            ;2309
000056  69ef              LDR      r7,[r5,#0x1c]         ;2314
000058  4308              ORRS     r0,r0,r1              ;2309
00005a  f64f41fc          MOV      r1,#0xfcfc            ;2312
00005e  4388              BICS     r0,r0,r1              ;2312
000060  68e9              LDR      r1,[r5,#0xc]          ;2314
000062  ea402007          ORR      r0,r0,r7,LSL #8       ;2314
000066  4301              ORRS     r1,r1,r0              ;2314
000068  6928              LDR      r0,[r5,#0x10]         ;2315
00006a  6a2f              LDR      r7,[r5,#0x20]         ;2315
00006c  0100              LSLS     r0,r0,#4              ;2315
00006e  ea403007          ORR      r0,r0,r7,LSL #12      ;2315
000072  4308              ORRS     r0,r0,r1              ;2315
000074  6869              LDR      r1,[r5,#4]            ;2320
000076  696d              LDR      r5,[r5,#0x14]         ;2320
000078  f02606aa          BIC      r6,r6,#0xaa           ;2319
00007c  ea461505          ORR      r5,r6,r5,LSL #4       ;2320
000080  4329              ORRS     r1,r1,r5              ;2320
000082  6093              STR      r3,[r2,#8]            ;2323
000084  6822              LDR      r2,[r4,#0]            ;2326
000086  6190              STR      r0,[r2,#0x18]         ;2326
000088  6820              LDR      r0,[r4,#0]            ;2329
00008a  6201              STR      r1,[r0,#0x20]         ;2329
00008c  2001              MOVS     r0,#1                 ;2332
00008e  f884003d          STRB     r0,[r4,#0x3d]         ;2332
000092  2000              MOVS     r0,#0                 ;2334
000094  e7be              B        |L21.20|
;;;2336   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_MspDeInit PROC
;;;2383     */
;;;2384   __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2385   {
;;;2386     /* Prevent unused argument(s) compilation warning */
;;;2387     UNUSED(htim);
;;;2388     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2389               the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
;;;2390      */
;;;2391   }
;;;2392   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_MspInit PROC
;;;2369     */
;;;2370   __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2371   {
;;;2372     /* Prevent unused argument(s) compilation warning */
;;;2373     UNUSED(htim);
;;;2374     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2375               the HAL_TIM_Encoder_MspInit could be implemented in the user file
;;;2376      */
;;;2377   }
;;;2378   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Start PROC
;;;2402   */
;;;2403   HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;2404   {
000002  4604              MOV      r4,r0
;;;2405     /* Check the parameters */
;;;2406     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2407   
;;;2408     /* Enable the encoder interface channels */
;;;2409     switch (Channel)
;;;2410     {
;;;2411       case TIM_CHANNEL_1:
;;;2412     {
;;;2413       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000004  6800              LDR      r0,[r0,#0]
000006  b191              CBZ      r1,|L24.46|
000008  2904              CMP      r1,#4                 ;2409
00000a  d004              BEQ      |L24.22|
;;;2414         break;
;;;2415     }
;;;2416       case TIM_CHANNEL_2:
;;;2417     {
;;;2418       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2419         break;
;;;2420     }
;;;2421       default :
;;;2422     {
;;;2423        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
00000c  2201              MOVS     r2,#1
00000e  2100              MOVS     r1,#0
000010  f7fffffe          BL       TIM_CCxChannelCmd
;;;2424        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000014  6820              LDR      r0,[r4,#0]
                  |L24.22|
000016  2201              MOVS     r2,#1                 ;2418
000018  f05f0104          MOVS.W   r1,#4                 ;2418
                  |L24.28|
00001c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2425        break;
;;;2426       }
;;;2427     }
;;;2428     /* Enable the Peripheral */
;;;2429     __HAL_TIM_ENABLE(htim);
000020  6820              LDR      r0,[r4,#0]
000022  6801              LDR      r1,[r0,#0]
000024  f0410101          ORR      r1,r1,#1
000028  6001              STR      r1,[r0,#0]
;;;2430   
;;;2431     /* Return function status */
;;;2432     return HAL_OK;
00002a  2000              MOVS     r0,#0
;;;2433   }
00002c  bd10              POP      {r4,pc}
                  |L24.46|
00002e  2201              MOVS     r2,#1                 ;2413
000030  2100              MOVS     r1,#0                 ;2413
000032  e7f3              B        |L24.28|
;;;2434   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Start_DMA PROC
;;;2590   */
;;;2591   HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1, uint32_t *pData2, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2592   {
000004  4604              MOV      r4,r0
;;;2593     /* Check the parameters */
;;;2594     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2595   
;;;2596     if((htim->State == HAL_TIM_STATE_BUSY))
000006  f890003d          LDRB     r0,[r0,#0x3d]
00000a  9f06              LDR      r7,[sp,#0x18]
00000c  4698              MOV      r8,r3                 ;2592
00000e  2802              CMP      r0,#2
000010  d009              BEQ      |L25.38|
;;;2597     {
;;;2598        return HAL_BUSY;
;;;2599     }
;;;2600     else if((htim->State == HAL_TIM_STATE_READY))
000012  f894003d          LDRB     r0,[r4,#0x3d]
000016  2801              CMP      r0,#1
000018  d10a              BNE      |L25.48|
;;;2601     {
;;;2602       if((((pData1 == 0U) || (pData2 == 0U) )) && (Length > 0U))
00001a  b112              CBZ      r2,|L25.34|
00001c  f1b80f00          CMP      r8,#0
000020  d103              BNE      |L25.42|
                  |L25.34|
000022  b117              CBZ      r7,|L25.42|
;;;2603       {
;;;2604         return HAL_ERROR;
000024  2001              MOVS     r0,#1
                  |L25.38|
;;;2605       }
;;;2606       else
;;;2607       {
;;;2608         htim->State = HAL_TIM_STATE_BUSY;
;;;2609       }
;;;2610     }
;;;2611   
;;;2612     switch (Channel)
;;;2613     {
;;;2614       case TIM_CHANNEL_1:
;;;2615       {
;;;2616         /* Set the DMA Period elapsed callback */
;;;2617         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2618   
;;;2619         /* Set the DMA error callback */
;;;2620         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;2621   
;;;2622         /* Enable the DMA channel */
;;;2623         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t )pData1, Length);
;;;2624   
;;;2625         /* Enable the TIM Input Capture DMA request */
;;;2626         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;2627   
;;;2628         /* Enable the Peripheral */
;;;2629         __HAL_TIM_ENABLE(htim);
;;;2630   
;;;2631         /* Enable the Capture compare channel */
;;;2632         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2633       }
;;;2634       break;
;;;2635   
;;;2636       case TIM_CHANNEL_2:
;;;2637       {
;;;2638         /* Set the DMA Period elapsed callback */
;;;2639         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2640   
;;;2641         /* Set the DMA error callback */
;;;2642         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError;
;;;2643         /* Enable the DMA channel */
;;;2644         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
;;;2645   
;;;2646         /* Enable the TIM Input Capture  DMA request */
;;;2647         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;2648   
;;;2649         /* Enable the Peripheral */
;;;2650         __HAL_TIM_ENABLE(htim);
;;;2651   
;;;2652         /* Enable the Capture compare channel */
;;;2653         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2654       }
;;;2655       break;
;;;2656   
;;;2657       case TIM_CHANNEL_ALL:
;;;2658       {
;;;2659         /* Set the DMA Period elapsed callback */
;;;2660         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2661   
;;;2662         /* Set the DMA error callback */
;;;2663         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;2664   
;;;2665         /* Enable the DMA channel */
;;;2666         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length);
;;;2667   
;;;2668         /* Set the DMA Period elapsed callback */
;;;2669         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2670   
;;;2671         /* Set the DMA error callback */
;;;2672         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;2673   
;;;2674         /* Enable the DMA channel */
;;;2675         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
;;;2676   
;;;2677        /* Enable the Peripheral */
;;;2678         __HAL_TIM_ENABLE(htim);
;;;2679   
;;;2680         /* Enable the Capture compare channel */
;;;2681         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2682         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2683   
;;;2684         /* Enable the TIM Input Capture  DMA request */
;;;2685         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;2686         /* Enable the TIM Input Capture  DMA request */
;;;2687         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;2688       }
;;;2689       break;
;;;2690   
;;;2691       default:
;;;2692       break;
;;;2693     }
;;;2694     /* Return function status */
;;;2695     return HAL_OK;
;;;2696   }
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L25.42|
00002a  2002              MOVS     r0,#2                 ;2608
00002c  f884003d          STRB     r0,[r4,#0x3d]         ;2608
                  |L25.48|
000030  4d35              LDR      r5,|L25.264|
000032  4e36              LDR      r6,|L25.268|
000034  b121              CBZ      r1,|L25.64|
000036  2904              CMP      r1,#4                 ;2612
000038  d01a              BEQ      |L25.112|
00003a  2918              CMP      r1,#0x18              ;2612
00003c  d161              BNE      |L25.258|
00003e  e032              B        |L25.166|
                  |L25.64|
000040  6a60              LDR      r0,[r4,#0x24]         ;2617
000042  463b              MOV      r3,r7                 ;2623
000044  6285              STR      r5,[r0,#0x28]         ;2620
000046  6a60              LDR      r0,[r4,#0x24]         ;2620
000048  6306              STR      r6,[r0,#0x30]         ;2623
00004a  6821              LDR      r1,[r4,#0]            ;2623
00004c  6a60              LDR      r0,[r4,#0x24]         ;2623
00004e  3134              ADDS     r1,r1,#0x34           ;2623
000050  f7fffffe          BL       HAL_DMA_Start_IT
000054  6820              LDR      r0,[r4,#0]            ;2626
000056  68c1              LDR      r1,[r0,#0xc]          ;2626
000058  f4417100          ORR      r1,r1,#0x200          ;2626
00005c  60c1              STR      r1,[r0,#0xc]          ;2626
00005e  6820              LDR      r0,[r4,#0]            ;2629
000060  6801              LDR      r1,[r0,#0]            ;2629
000062  f0410101          ORR      r1,r1,#1              ;2629
000066  6001              STR      r1,[r0,#0]            ;2629
000068  2201              MOVS     r2,#1                 ;2632
00006a  2100              MOVS     r1,#0                 ;2632
00006c  6820              LDR      r0,[r4,#0]            ;2634
00006e  e017              B        |L25.160|
                  |L25.112|
000070  6aa0              LDR      r0,[r4,#0x28]         ;2639
000072  463b              MOV      r3,r7                 ;2644
000074  4642              MOV      r2,r8                 ;2644
000076  6285              STR      r5,[r0,#0x28]         ;2642
000078  6aa0              LDR      r0,[r4,#0x28]         ;2642
00007a  6306              STR      r6,[r0,#0x30]         ;2644
00007c  6821              LDR      r1,[r4,#0]            ;2644
00007e  6aa0              LDR      r0,[r4,#0x28]         ;2644
000080  3138              ADDS     r1,r1,#0x38           ;2644
000082  f7fffffe          BL       HAL_DMA_Start_IT
000086  6820              LDR      r0,[r4,#0]            ;2647
000088  68c1              LDR      r1,[r0,#0xc]          ;2647
00008a  f4416180          ORR      r1,r1,#0x400          ;2647
00008e  60c1              STR      r1,[r0,#0xc]          ;2647
000090  6820              LDR      r0,[r4,#0]            ;2650
000092  6801              LDR      r1,[r0,#0]            ;2650
000094  f0410101          ORR      r1,r1,#1              ;2650
000098  6001              STR      r1,[r0,#0]            ;2650
00009a  2201              MOVS     r2,#1                 ;2653
00009c  2104              MOVS     r1,#4                 ;2653
00009e  6820              LDR      r0,[r4,#0]            ;2653
                  |L25.160|
0000a0  f7fffffe          BL       TIM_CCxChannelCmd
0000a4  e02d              B        |L25.258|
                  |L25.166|
0000a6  6a60              LDR      r0,[r4,#0x24]         ;2660
0000a8  463b              MOV      r3,r7                 ;2666
0000aa  6285              STR      r5,[r0,#0x28]         ;2663
0000ac  6a60              LDR      r0,[r4,#0x24]         ;2663
0000ae  6306              STR      r6,[r0,#0x30]         ;2666
0000b0  6821              LDR      r1,[r4,#0]            ;2666
0000b2  6a60              LDR      r0,[r4,#0x24]         ;2666
0000b4  3134              ADDS     r1,r1,#0x34           ;2666
0000b6  f7fffffe          BL       HAL_DMA_Start_IT
0000ba  6aa0              LDR      r0,[r4,#0x28]         ;2669
0000bc  463b              MOV      r3,r7                 ;2675
0000be  4642              MOV      r2,r8                 ;2675
0000c0  6285              STR      r5,[r0,#0x28]         ;2672
0000c2  6aa0              LDR      r0,[r4,#0x28]         ;2672
0000c4  6306              STR      r6,[r0,#0x30]         ;2675
0000c6  6821              LDR      r1,[r4,#0]            ;2675
0000c8  6aa0              LDR      r0,[r4,#0x28]         ;2675
0000ca  3138              ADDS     r1,r1,#0x38           ;2675
0000cc  f7fffffe          BL       HAL_DMA_Start_IT
0000d0  6820              LDR      r0,[r4,#0]            ;2678
0000d2  6801              LDR      r1,[r0,#0]            ;2678
0000d4  f0410101          ORR      r1,r1,#1              ;2678
0000d8  6001              STR      r1,[r0,#0]            ;2678
0000da  2201              MOVS     r2,#1                 ;2681
0000dc  2100              MOVS     r1,#0                 ;2681
0000de  6820              LDR      r0,[r4,#0]            ;2681
0000e0  f7fffffe          BL       TIM_CCxChannelCmd
0000e4  2201              MOVS     r2,#1                 ;2682
0000e6  2104              MOVS     r1,#4                 ;2682
0000e8  6820              LDR      r0,[r4,#0]            ;2682
0000ea  f7fffffe          BL       TIM_CCxChannelCmd
0000ee  6820              LDR      r0,[r4,#0]            ;2685
0000f0  68c1              LDR      r1,[r0,#0xc]          ;2685
0000f2  f4417100          ORR      r1,r1,#0x200          ;2685
0000f6  60c1              STR      r1,[r0,#0xc]          ;2685
0000f8  6820              LDR      r0,[r4,#0]            ;2687
0000fa  68c1              LDR      r1,[r0,#0xc]          ;2687
0000fc  f4416180          ORR      r1,r1,#0x400          ;2687
000100  60c1              STR      r1,[r0,#0xc]          ;2687
                  |L25.258|
000102  2000              MOVS     r0,#0                 ;2695
000104  e78f              B        |L25.38|
;;;2697   
                          ENDP

000106  0000              DCW      0x0000
                  |L25.264|
                          DCD      TIM_DMACaptureCplt
                  |L25.268|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_Encoder_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Start_IT PROC
;;;2488   */
;;;2489   HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;2490   {
000002  4604              MOV      r4,r0
;;;2491     /* Check the parameters */
;;;2492     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2493   
;;;2494     /* Enable the encoder interface channels */
;;;2495     /* Enable the capture compare Interrupts 1 and/or 2 */
;;;2496     switch (Channel)
;;;2497     {
;;;2498       case TIM_CHANNEL_1:
;;;2499     {
;;;2500       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000004  6800              LDR      r0,[r0,#0]
000006  b189              CBZ      r1,|L26.44|
000008  2904              CMP      r1,#4                 ;2496
;;;2501       __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
;;;2502         break;
;;;2503     }
;;;2504       case TIM_CHANNEL_2:
;;;2505     {
;;;2506       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
00000a  f04f0201          MOV      r2,#1
00000e  d016              BEQ      |L26.62|
;;;2507       __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
;;;2508         break;
;;;2509     }
;;;2510       default :
;;;2511     {
;;;2512        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000010  2100              MOVS     r1,#0
000012  f7fffffe          BL       TIM_CCxChannelCmd
;;;2513        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000016  2201              MOVS     r2,#1
000018  2104              MOVS     r1,#4
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2514        __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000020  6820              LDR      r0,[r4,#0]
000022  68c1              LDR      r1,[r0,#0xc]
000024  f0410102          ORR      r1,r1,#2
000028  60c1              STR      r1,[r0,#0xc]
;;;2515        __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
;;;2516        break;
00002a  e00b              B        |L26.68|
                  |L26.44|
00002c  2201              MOVS     r2,#1                 ;2500
00002e  2100              MOVS     r1,#0                 ;2500
000030  f7fffffe          BL       TIM_CCxChannelCmd
000034  6820              LDR      r0,[r4,#0]            ;2501
000036  68c1              LDR      r1,[r0,#0xc]          ;2501
000038  f0410102          ORR      r1,r1,#2              ;2501
00003c  e006              B        |L26.76|
                  |L26.62|
00003e  2104              MOVS     r1,#4                 ;2506
000040  f7fffffe          BL       TIM_CCxChannelCmd
                  |L26.68|
000044  6820              LDR      r0,[r4,#0]            ;2515
000046  68c1              LDR      r1,[r0,#0xc]          ;2515
000048  f0410104          ORR      r1,r1,#4              ;2515
                  |L26.76|
00004c  60c1              STR      r1,[r0,#0xc]          ;2501
;;;2517       }
;;;2518     }
;;;2519   
;;;2520     /* Enable the Peripheral */
;;;2521     __HAL_TIM_ENABLE(htim);
00004e  6820              LDR      r0,[r4,#0]
000050  6801              LDR      r1,[r0,#0]
000052  f0410101          ORR      r1,r1,#1
000056  6001              STR      r1,[r0,#0]
;;;2522   
;;;2523     /* Return function status */
;;;2524     return HAL_OK;
000058  2000              MOVS     r0,#0
;;;2525   }
00005a  bd10              POP      {r4,pc}
;;;2526   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Stop PROC
;;;2444   */
;;;2445   HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;2446   {
000002  4604              MOV      r4,r0
;;;2447     /* Check the parameters */
;;;2448       assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2449   
;;;2450      /* Disable the Input Capture channels 1 and 2
;;;2451       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
;;;2452     switch (Channel)
;;;2453     {
;;;2454       case TIM_CHANNEL_1:
;;;2455     {
;;;2456        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000004  6800              LDR      r0,[r0,#0]
000006  b1d9              CBZ      r1,|L27.64|
000008  2904              CMP      r1,#4                 ;2452
00000a  d004              BEQ      |L27.22|
;;;2457         break;
;;;2458     }
;;;2459       case TIM_CHANNEL_2:
;;;2460     {
;;;2461       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
;;;2462         break;
;;;2463     }
;;;2464       default :
;;;2465     {
;;;2466       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
00000c  2200              MOVS     r2,#0
00000e  4611              MOV      r1,r2
000010  f7fffffe          BL       TIM_CCxChannelCmd
;;;2467       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000014  6820              LDR      r0,[r4,#0]
                  |L27.22|
000016  2200              MOVS     r2,#0                 ;2461
000018  f05f0104          MOVS.W   r1,#4                 ;2461
                  |L27.28|
00001c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2468        break;
;;;2469       }
;;;2470     }
;;;2471   
;;;2472     /* Disable the Peripheral */
;;;2473     __HAL_TIM_DISABLE(htim);
000020  6820              LDR      r0,[r4,#0]
000022  6a01              LDR      r1,[r0,#0x20]
000024  f2411211          MOV      r2,#0x1111
000028  4211              TST      r1,r2
00002a  d107              BNE      |L27.60|
00002c  6a01              LDR      r1,[r0,#0x20]
00002e  1092              ASRS     r2,r2,#2
000030  4211              TST      r1,r2
000032  d103              BNE      |L27.60|
000034  6801              LDR      r1,[r0,#0]
000036  f0210101          BIC      r1,r1,#1
00003a  6001              STR      r1,[r0,#0]
                  |L27.60|
;;;2474   
;;;2475     /* Return function status */
;;;2476     return HAL_OK;
00003c  2000              MOVS     r0,#0
;;;2477   }
00003e  bd10              POP      {r4,pc}
                  |L27.64|
000040  2200              MOVS     r2,#0                 ;2456
000042  4611              MOV      r1,r2                 ;2456
000044  e7ea              B        |L27.28|
;;;2478   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop_DMA PROC
;;;2707   */
;;;2708   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;2709   {
000002  4604              MOV      r4,r0
;;;2710     /* Check the parameters */
;;;2711     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2712   
;;;2713     /* Disable the Input Capture channels 1 and 2
;;;2714       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
;;;2715     if(Channel == TIM_CHANNEL_1)
;;;2716     {
;;;2717       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000004  6800              LDR      r0,[r0,#0]
000006  b341              CBZ      r1,|L28.90|
;;;2718   
;;;2719       /* Disable the capture compare DMA Request 1 */
;;;2720       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
;;;2721     }
;;;2722     else if(Channel == TIM_CHANNEL_2)
000008  2904              CMP      r1,#4
;;;2723     {
;;;2724       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
;;;2725   
;;;2726       /* Disable the capture compare DMA Request 2 */
;;;2727       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
;;;2728     }
;;;2729     else
;;;2730     {
;;;2731       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
00000a  f04f0200          MOV      r2,#0
00000e  d02d              BEQ      |L28.108|
000010  2100              MOVS     r1,#0
000012  f7fffffe          BL       TIM_CCxChannelCmd
;;;2732       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000016  2200              MOVS     r2,#0
000018  2104              MOVS     r1,#4
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2733   
;;;2734       /* Disable the capture compare DMA Request 1 and 2 */
;;;2735       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000020  6820              LDR      r0,[r4,#0]
000022  68c1              LDR      r1,[r0,#0xc]
000024  f4217100          BIC      r1,r1,#0x200
000028  60c1              STR      r1,[r0,#0xc]
                  |L28.42|
00002a  6820              LDR      r0,[r4,#0]            ;2727
00002c  68c1              LDR      r1,[r0,#0xc]          ;2727
00002e  f4216180          BIC      r1,r1,#0x400          ;2727
                  |L28.50|
000032  60c1              STR      r1,[r0,#0xc]          ;2727
;;;2736       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
;;;2737     }
;;;2738   
;;;2739     /* Disable the Peripheral */
;;;2740     __HAL_TIM_DISABLE(htim);
000034  6820              LDR      r0,[r4,#0]
000036  6a01              LDR      r1,[r0,#0x20]
000038  f2411211          MOV      r2,#0x1111
00003c  4211              TST      r1,r2
00003e  d107              BNE      |L28.80|
000040  6a01              LDR      r1,[r0,#0x20]
000042  1092              ASRS     r2,r2,#2
000044  4211              TST      r1,r2
000046  d103              BNE      |L28.80|
000048  6801              LDR      r1,[r0,#0]
00004a  f0210101          BIC      r1,r1,#1
00004e  6001              STR      r1,[r0,#0]
                  |L28.80|
;;;2741   
;;;2742     /* Change the htim state */
;;;2743     htim->State = HAL_TIM_STATE_READY;
000050  2001              MOVS     r0,#1
000052  f884003d          STRB     r0,[r4,#0x3d]
;;;2744   
;;;2745     /* Return function status */
;;;2746     return HAL_OK;
000056  2000              MOVS     r0,#0
;;;2747   }
000058  bd10              POP      {r4,pc}
                  |L28.90|
00005a  2200              MOVS     r2,#0                 ;2717
00005c  4611              MOV      r1,r2                 ;2717
00005e  f7fffffe          BL       TIM_CCxChannelCmd
000062  6820              LDR      r0,[r4,#0]            ;2720
000064  68c1              LDR      r1,[r0,#0xc]          ;2720
000066  f4217100          BIC      r1,r1,#0x200          ;2720
00006a  e7e2              B        |L28.50|
                  |L28.108|
00006c  2104              MOVS     r1,#4                 ;2724
00006e  f7fffffe          BL       TIM_CCxChannelCmd
000072  e7da              B        |L28.42|
;;;2748   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop_IT PROC
;;;2536   */
;;;2537   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;2538   {
000002  4604              MOV      r4,r0
;;;2539     /* Check the parameters */
;;;2540     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2541   
;;;2542     /* Disable the Input Capture channels 1 and 2
;;;2543       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
;;;2544     if(Channel == TIM_CHANNEL_1)
;;;2545     {
;;;2546       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000004  6800              LDR      r0,[r0,#0]
000006  b341              CBZ      r1,|L29.90|
;;;2547   
;;;2548       /* Disable the capture compare Interrupts 1 */
;;;2549     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
;;;2550     }
;;;2551     else if(Channel == TIM_CHANNEL_2)
000008  2904              CMP      r1,#4
;;;2552     {
;;;2553       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
;;;2554   
;;;2555       /* Disable the capture compare Interrupts 2 */
;;;2556     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
;;;2557     }
;;;2558     else
;;;2559     {
;;;2560       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
00000a  f04f0200          MOV      r2,#0
00000e  d02d              BEQ      |L29.108|
000010  2100              MOVS     r1,#0
000012  f7fffffe          BL       TIM_CCxChannelCmd
;;;2561       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000016  2200              MOVS     r2,#0
000018  2104              MOVS     r1,#4
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2562   
;;;2563       /* Disable the capture compare Interrupts 1 and 2 */
;;;2564       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000020  6820              LDR      r0,[r4,#0]
000022  68c1              LDR      r1,[r0,#0xc]
000024  f0210102          BIC      r1,r1,#2
000028  60c1              STR      r1,[r0,#0xc]
                  |L29.42|
00002a  6820              LDR      r0,[r4,#0]            ;2556
00002c  68c1              LDR      r1,[r0,#0xc]          ;2556
00002e  f0210104          BIC      r1,r1,#4              ;2556
                  |L29.50|
000032  60c1              STR      r1,[r0,#0xc]          ;2556
;;;2565       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
;;;2566     }
;;;2567   
;;;2568     /* Disable the Peripheral */
;;;2569     __HAL_TIM_DISABLE(htim);
000034  6820              LDR      r0,[r4,#0]
000036  6a01              LDR      r1,[r0,#0x20]
000038  f2411211          MOV      r2,#0x1111
00003c  4211              TST      r1,r2
00003e  d107              BNE      |L29.80|
000040  6a01              LDR      r1,[r0,#0x20]
000042  1092              ASRS     r2,r2,#2
000044  4211              TST      r1,r2
000046  d103              BNE      |L29.80|
000048  6801              LDR      r1,[r0,#0]
00004a  f0210101          BIC      r1,r1,#1
00004e  6001              STR      r1,[r0,#0]
                  |L29.80|
;;;2570   
;;;2571     /* Change the htim state */
;;;2572     htim->State = HAL_TIM_STATE_READY;
000050  2001              MOVS     r0,#1
000052  f884003d          STRB     r0,[r4,#0x3d]
;;;2573   
;;;2574     /* Return function status */
;;;2575     return HAL_OK;
000056  2000              MOVS     r0,#0
;;;2576   }
000058  bd10              POP      {r4,pc}
                  |L29.90|
00005a  2200              MOVS     r2,#0                 ;2546
00005c  4611              MOV      r1,r2                 ;2546
00005e  f7fffffe          BL       TIM_CCxChannelCmd
000062  6820              LDR      r0,[r4,#0]            ;2549
000064  68c1              LDR      r1,[r0,#0xc]          ;2549
000066  f0210102          BIC      r1,r1,#2              ;2549
00006a  e7e2              B        |L29.50|
                  |L29.108|
00006c  2104              MOVS     r1,#4                 ;2553
00006e  f7fffffe          BL       TIM_CCxChannelCmd
000072  e7da              B        |L29.42|
;;;2577   
                          ENDP


                          AREA ||i.HAL_TIM_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ErrorCallback PROC
;;;4353     */
;;;4354   __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4355   {
;;;4356     /* Prevent unused argument(s) compilation warning */
;;;4357     UNUSED(htim);
;;;4358     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4359               the HAL_TIM_ErrorCallback could be implemented in the user file
;;;4360      */
;;;4361   }
;;;4362   
                          ENDP


                          AREA ||i.HAL_TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  HAL_TIM_GenerateEvent PROC
;;;3760   
;;;3761   HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
000000  f890203c          LDRB     r2,[r0,#0x3c]
;;;3762   {
;;;3763     /* Check the parameters */
;;;3764     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;3765     assert_param(IS_TIM_EVENT_SOURCE(EventSource));
;;;3766   
;;;3767     /* Process Locked */
;;;3768     __HAL_LOCK(htim);
000004  2a01              CMP      r2,#1
000006  d00c              BEQ      |L31.34|
000008  2201              MOVS     r2,#1
00000a  f8002f3c          STRB     r2,[r0,#0x3c]!
;;;3769   
;;;3770     /* Change the TIM state */
;;;3771     htim->State = HAL_TIM_STATE_BUSY;
00000e  2302              MOVS     r3,#2
000010  7043              STRB     r3,[r0,#1]
;;;3772   
;;;3773     /* Set the event sources */
;;;3774     htim->Instance->EGR = EventSource;
000012  f8503c3c          LDR      r3,[r0,#-0x3c]
000016  6159              STR      r1,[r3,#0x14]
;;;3775   
;;;3776     /* Change the TIM state */
;;;3777     htim->State = HAL_TIM_STATE_READY;
000018  7042              STRB     r2,[r0,#1]
;;;3778   
;;;3779     __HAL_UNLOCK(htim);
00001a  2100              MOVS     r1,#0
00001c  7001              STRB     r1,[r0,#0]
;;;3780   
;;;3781     /* Return function status */
;;;3782     return HAL_OK;
00001e  4608              MOV      r0,r1
;;;3783   }
000020  4770              BX       lr
                  |L31.34|
000022  2002              MOVS     r0,#2                 ;3768
000024  4770              BX       lr
;;;3784   
                          ENDP


                          AREA ||i.HAL_TIM_IC_CaptureCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_CaptureCallback PROC
;;;4311     */
;;;4312   __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4313   {
;;;4314     /* Prevent unused argument(s) compilation warning */
;;;4315     UNUSED(htim);
;;;4316     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4317               the __HAL_TIM_IC_CaptureCallback could be implemented in the user file
;;;4318      */
;;;4319   }
;;;4320   
                          ENDP


                          AREA ||i.HAL_TIM_IC_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_ConfigChannel PROC
;;;3001     */
;;;3002   HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef* sConfig, uint32_t Channel)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3003   {
000004  4604              MOV      r4,r0
;;;3004     /* Check the parameters */
;;;3005     assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3006     assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
;;;3007     assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
;;;3008     assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
;;;3009     assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
;;;3010   
;;;3011     __HAL_LOCK(htim);
000006  f890003c          LDRB     r0,[r0,#0x3c]
00000a  460d              MOV      r5,r1                 ;3003
00000c  2801              CMP      r0,#1
00000e  d03b              BEQ      |L33.136|
000010  2601              MOVS     r6,#1
000012  f884603c          STRB     r6,[r4,#0x3c]
;;;3012   
;;;3013     htim->State = HAL_TIM_STATE_BUSY;
000016  2002              MOVS     r0,#2
000018  f884003d          STRB     r0,[r4,#0x3d]
00001c  b39a              CBZ      r2,|L33.134|
;;;3014   
;;;3015     if (Channel == TIM_CHANNEL_1)
;;;3016     {
;;;3017       /* TI1 Configuration */
;;;3018       TIM_TI1_SetConfig(htim->Instance,
;;;3019                  sConfig->ICPolarity,
;;;3020                  sConfig->ICSelection,
;;;3021                  sConfig->ICFilter);
;;;3022   
;;;3023       /* Reset the IC1PSC Bits */
;;;3024       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;3025   
;;;3026       /* Set the IC1PSC value */
;;;3027       htim->Instance->CCMR1 |= sConfig->ICPrescaler;
;;;3028     }
;;;3029     else if (Channel == TIM_CHANNEL_2)
00001e  2a04              CMP      r2,#4
000020  d044              BEQ      |L33.172|
;;;3030     {
;;;3031       /* TI2 Configuration */
;;;3032       assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3033   
;;;3034       TIM_TI2_SetConfig(htim->Instance,
;;;3035                         sConfig->ICPolarity,
;;;3036                         sConfig->ICSelection,
;;;3037                         sConfig->ICFilter);
;;;3038   
;;;3039       /* Reset the IC2PSC Bits */
;;;3040       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;3041   
;;;3042       /* Set the IC2PSC value */
;;;3043       htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);
;;;3044     }
;;;3045     else if (Channel == TIM_CHANNEL_3)
000022  6820              LDR      r0,[r4,#0]
000024  2a08              CMP      r2,#8
000026  d053              BEQ      |L33.208|
;;;3046     {
;;;3047       /* TI3 Configuration */
;;;3048       assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3049   
;;;3050       TIM_TI3_SetConfig(htim->Instance,
;;;3051                  sConfig->ICPolarity,
;;;3052                  sConfig->ICSelection,
;;;3053                  sConfig->ICFilter);
;;;3054   
;;;3055       /* Reset the IC3PSC Bits */
;;;3056       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
;;;3057   
;;;3058       /* Set the IC3PSC value */
;;;3059       htim->Instance->CCMR2 |= sConfig->ICPrescaler;
;;;3060     }
;;;3061     else
;;;3062     {
;;;3063       /* TI4 Configuration */
;;;3064       assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3065   
;;;3066       TIM_TI4_SetConfig(htim->Instance,
000028  e9d52700          LDRD     r2,r7,[r5,#0]
00002c  68e9              LDR      r1,[r5,#0xc]
00002e  6a03              LDR      r3,[r0,#0x20]
000030  f4235380          BIC      r3,r3,#0x1000
000034  6203              STR      r3,[r0,#0x20]
000036  f8d0c01c          LDR      r12,[r0,#0x1c]
00003a  6a03              LDR      r3,[r0,#0x20]
00003c  f42c7c40          BIC      r12,r12,#0x300
000040  ea4c2707          ORR      r7,r12,r7,LSL #8
000044  f64f7cff          MOV      r12,#0xffff
000048  f4274770          BIC      r7,r7,#0xf000
00004c  ea0c3101          AND      r1,r12,r1,LSL #12
000050  4339              ORRS     r1,r1,r7
000052  0377              LSLS     r7,r6,#13
000054  f4235300          BIC      r3,r3,#0x2000
000058  ea073202          AND      r2,r7,r2,LSL #12
00005c  431a              ORRS     r2,r2,r3
00005e  61c1              STR      r1,[r0,#0x1c]
000060  6202              STR      r2,[r0,#0x20]
;;;3067                  sConfig->ICPolarity,
;;;3068                  sConfig->ICSelection,
;;;3069                  sConfig->ICFilter);
;;;3070   
;;;3071       /* Reset the IC4PSC Bits */
;;;3072       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
000062  6820              LDR      r0,[r4,#0]
000064  69c1              LDR      r1,[r0,#0x1c]
000066  f4216140          BIC      r1,r1,#0xc00
00006a  61c1              STR      r1,[r0,#0x1c]
;;;3073   
;;;3074       /* Set the IC4PSC value */
;;;3075       htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
00006c  6820              LDR      r0,[r4,#0]
00006e  69c1              LDR      r1,[r0,#0x1c]
000070  68aa              LDR      r2,[r5,#8]
000072  ea412102          ORR      r1,r1,r2,LSL #8
                  |L33.118|
000076  61c1              STR      r1,[r0,#0x1c]         ;3059
                  |L33.120|
;;;3076     }
;;;3077   
;;;3078     htim->State = HAL_TIM_STATE_READY;
000078  f884603d          STRB     r6,[r4,#0x3d]
;;;3079   
;;;3080     __HAL_UNLOCK(htim);
00007c  2000              MOVS     r0,#0
00007e  f884003c          STRB     r0,[r4,#0x3c]
                  |L33.130|
;;;3081   
;;;3082     return HAL_OK;
;;;3083   }
000082  e8bd81f0          POP      {r4-r8,pc}
                  |L33.134|
000086  e001              B        |L33.140|
                  |L33.136|
000088  2002              MOVS     r0,#2                 ;3011
00008a  e7fa              B        |L33.130|
                  |L33.140|
00008c  e9d51200          LDRD     r1,r2,[r5,#0]         ;3018
000090  68eb              LDR      r3,[r5,#0xc]          ;3018
000092  6820              LDR      r0,[r4,#0]            ;3018
000094  f7fffffe          BL       TIM_TI1_SetConfig
000098  6820              LDR      r0,[r4,#0]            ;3024
00009a  6981              LDR      r1,[r0,#0x18]         ;3024
00009c  f021010c          BIC      r1,r1,#0xc            ;3024
0000a0  6181              STR      r1,[r0,#0x18]         ;3024
0000a2  6820              LDR      r0,[r4,#0]            ;3027
0000a4  6981              LDR      r1,[r0,#0x18]         ;3027
0000a6  68aa              LDR      r2,[r5,#8]            ;3027
0000a8  4311              ORRS     r1,r1,r2              ;3027
0000aa  e00f              B        |L33.204|
                  |L33.172|
0000ac  e9d51200          LDRD     r1,r2,[r5,#0]         ;3034
0000b0  68eb              LDR      r3,[r5,#0xc]          ;3034
0000b2  6820              LDR      r0,[r4,#0]            ;3034
0000b4  f7fffffe          BL       TIM_TI2_SetConfig
0000b8  6820              LDR      r0,[r4,#0]            ;3040
0000ba  6981              LDR      r1,[r0,#0x18]         ;3040
0000bc  f4216140          BIC      r1,r1,#0xc00          ;3040
0000c0  6181              STR      r1,[r0,#0x18]         ;3040
0000c2  6820              LDR      r0,[r4,#0]            ;3043
0000c4  6981              LDR      r1,[r0,#0x18]         ;3043
0000c6  68aa              LDR      r2,[r5,#8]            ;3043
0000c8  ea412102          ORR      r1,r1,r2,LSL #8       ;3043
                  |L33.204|
0000cc  6181              STR      r1,[r0,#0x18]         ;3043
0000ce  e7d3              B        |L33.120|
                  |L33.208|
0000d0  e9d52c00          LDRD     r2,r12,[r5,#0]        ;3043
0000d4  7b2f              LDRB     r7,[r5,#0xc]          ;3050
0000d6  6a01              LDR      r1,[r0,#0x20]         ;3050
0000d8  f4217180          BIC      r1,r1,#0x100          ;3050
0000dc  6201              STR      r1,[r0,#0x20]         ;3050
0000de  69c1              LDR      r1,[r0,#0x1c]         ;3050
0000e0  6a03              LDR      r3,[r0,#0x20]         ;3050
0000e2  f0210103          BIC      r1,r1,#3              ;3050
0000e6  ea41010c          ORR      r1,r1,r12             ;3050
0000ea  f0210cf0          BIC      r12,r1,#0xf0          ;3050
0000ee  0739              LSLS     r1,r7,#28             ;3050
0000f0  f44f6720          MOV      r7,#0xa00             ;3050
0000f4  ea4c6111          ORR      r1,r12,r1,LSR #24     ;3050
0000f8  f4236320          BIC      r3,r3,#0xa00          ;3050
0000fc  ea072202          AND      r2,r7,r2,LSL #8       ;3050
000100  431a              ORRS     r2,r2,r3              ;3050
000102  61c1              STR      r1,[r0,#0x1c]         ;3050
000104  6202              STR      r2,[r0,#0x20]         ;3050
000106  6820              LDR      r0,[r4,#0]            ;3056
000108  69c1              LDR      r1,[r0,#0x1c]         ;3056
00010a  f021010c          BIC      r1,r1,#0xc            ;3056
00010e  61c1              STR      r1,[r0,#0x1c]         ;3056
000110  6820              LDR      r0,[r4,#0]            ;3059
000112  69c1              LDR      r1,[r0,#0x1c]         ;3059
000114  68aa              LDR      r2,[r5,#8]            ;3059
000116  4311              ORRS     r1,r1,r2              ;3059
000118  e7ad              B        |L33.118|
;;;3084   
                          ENDP


                          AREA ||i.HAL_TIM_IC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_DeInit PROC
;;;1532     */
;;;1533   HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1534   {
000002  4604              MOV      r4,r0
;;;1535     /* Check the parameters */
;;;1536     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1537   
;;;1538     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f884003d          STRB     r0,[r4,#0x3d]
;;;1539   
;;;1540     /* Disable the TIM Peripheral Clock */
;;;1541     __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L34.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L34.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L34.38|
;;;1542   
;;;1543     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1544     HAL_TIM_IC_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_IC_MspDeInit
;;;1545   
;;;1546     /* Change TIM state */
;;;1547     htim->State = HAL_TIM_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  f884003d          STRB     r0,[r4,#0x3d]
;;;1548   
;;;1549     /* Release Lock */
;;;1550     __HAL_UNLOCK(htim);
000032  f884003c          STRB     r0,[r4,#0x3c]
;;;1551   
;;;1552     return HAL_OK;
;;;1553   }
000036  bd10              POP      {r4,pc}
;;;1554   
                          ENDP


                          AREA ||i.HAL_TIM_IC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_GetState PROC
;;;4416     */
;;;4417   HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
000000  f890003d          LDRB     r0,[r0,#0x3d]
;;;4418   {
;;;4419     return htim->State;
;;;4420   }
000004  4770              BX       lr
;;;4421   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Init PROC
;;;1492     */
;;;1493   HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1494   {
000002  0004              MOVS     r4,r0
000004  d003              BEQ      |L36.14|
;;;1495     /* Check the TIM handle allocation */
;;;1496     if(htim == NULL)
;;;1497     {
;;;1498       return HAL_ERROR;
;;;1499     }
;;;1500   
;;;1501     /* Check the parameters */
;;;1502     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1503     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1504     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;1505     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;1506   
;;;1507     if(htim->State == HAL_TIM_STATE_RESET)
000006  f894003d          LDRB     r0,[r4,#0x3d]
00000a  b110              CBZ      r0,|L36.18|
00000c  e007              B        |L36.30|
                  |L36.14|
00000e  2001              MOVS     r0,#1                 ;1498
;;;1508     {
;;;1509       /* Allocate lock resource and initialize it */
;;;1510       htim->Lock = HAL_UNLOCKED;
;;;1511       
;;;1512       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1513       HAL_TIM_IC_MspInit(htim);
;;;1514     }
;;;1515   
;;;1516     /* Set the TIM state */
;;;1517     htim->State= HAL_TIM_STATE_BUSY;
;;;1518   
;;;1519     /* Init the base time for the input capture */
;;;1520     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;1521   
;;;1522     /* Initialize the TIM state*/
;;;1523     htim->State= HAL_TIM_STATE_READY;
;;;1524   
;;;1525     return HAL_OK;
;;;1526   }
000010  bd10              POP      {r4,pc}
                  |L36.18|
000012  2000              MOVS     r0,#0                 ;1510
000014  f884003c          STRB     r0,[r4,#0x3c]         ;1510
000018  4620              MOV      r0,r4                 ;1513
00001a  f7fffffe          BL       HAL_TIM_IC_MspInit
                  |L36.30|
00001e  2002              MOVS     r0,#2                 ;1517
000020  f884003d          STRB     r0,[r4,#0x3d]         ;1517
000024  1d21              ADDS     r1,r4,#4              ;1520
000026  6820              LDR      r0,[r4,#0]            ;1520
000028  f7fffffe          BL       TIM_Base_SetConfig
00002c  2001              MOVS     r0,#1                 ;1523
00002e  f884003d          STRB     r0,[r4,#0x3d]         ;1523
000032  2000              MOVS     r0,#0                 ;1525
000034  bd10              POP      {r4,pc}
;;;1527   
                          ENDP


                          AREA ||i.HAL_TIM_IC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_MspDeInit PROC
;;;1573     */
;;;1574   __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1575   {
;;;1576     /* Prevent unused argument(s) compilation warning */
;;;1577     UNUSED(htim);
;;;1578     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1579               the HAL_TIM_IC_MspDeInit could be implemented in the user file
;;;1580      */
;;;1581   }
;;;1582   
                          ENDP


                          AREA ||i.HAL_TIM_IC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_MspInit PROC
;;;1559     */
;;;1560   __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1561   {
;;;1562     /* Prevent unused argument(s) compilation warning */
;;;1563     UNUSED(htim);
;;;1564     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1565               the HAL_TIM_IC_MspInit could be implemented in the user file
;;;1566      */
;;;1567   }
;;;1568   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Start PROC
;;;1593   */
;;;1594   HAL_StatusTypeDef HAL_TIM_IC_Start (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1595   {
000002  4604              MOV      r4,r0
;;;1596     /* Check the parameters */
;;;1597     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1598   
;;;1599     /* Enable the Input Capture channel */
;;;1600     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2201              MOVS     r2,#1
000008  f7fffffe          BL       TIM_CCxChannelCmd
;;;1601   
;;;1602     /* Enable the Peripheral */
;;;1603     __HAL_TIM_ENABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  6801              LDR      r1,[r0,#0]
000010  f0410101          ORR      r1,r1,#1
000014  6001              STR      r1,[r0,#0]
;;;1604   
;;;1605     /* Return function status */
;;;1606     return HAL_OK;
000016  2000              MOVS     r0,#0
;;;1607   }
000018  bd10              POP      {r4,pc}
;;;1608   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_IC_Start_DMA PROC
;;;1766   */
;;;1767   HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;1768   {
000002  4604              MOV      r4,r0
;;;1769     /* Check the parameters */
;;;1770     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1771     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;1772   
;;;1773     if((htim->State == HAL_TIM_STATE_BUSY))
000004  f890003d          LDRB     r0,[r0,#0x3d]
000008  460e              MOV      r6,r1                 ;1768
00000a  2802              CMP      r0,#2
00000c  d005              BEQ      |L40.26|
;;;1774     {
;;;1775        return HAL_BUSY;
;;;1776     }
;;;1777     else if((htim->State == HAL_TIM_STATE_READY))
00000e  f894003d          LDRB     r0,[r4,#0x3d]
000012  2801              CMP      r0,#1
000014  d105              BNE      |L40.34|
;;;1778     {
;;;1779       if((pData == 0U) && (Length > 0U))
000016  b90a              CBNZ     r2,|L40.28|
000018  b103              CBZ      r3,|L40.28|
                  |L40.26|
;;;1780       {
;;;1781         return HAL_ERROR;
;;;1782       }
;;;1783       else
;;;1784       {
;;;1785         htim->State = HAL_TIM_STATE_BUSY;
;;;1786       }
;;;1787     }
;;;1788   
;;;1789     switch (Channel)
;;;1790     {
;;;1791       case TIM_CHANNEL_1:
;;;1792       {
;;;1793         /* Set the DMA Period elapsed callback */
;;;1794         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1795   
;;;1796         /* Set the DMA error callback */
;;;1797         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;1798   
;;;1799         /* Enable the DMA channel */
;;;1800         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length);
;;;1801   
;;;1802         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1803         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1804       }
;;;1805       break;
;;;1806   
;;;1807       case TIM_CHANNEL_2:
;;;1808       {
;;;1809         /* Set the DMA Period elapsed callback */
;;;1810         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1811   
;;;1812         /* Set the DMA error callback */
;;;1813         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;1814   
;;;1815         /* Enable the DMA channel */
;;;1816         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length);
;;;1817   
;;;1818         /* Enable the TIM Capture/Compare 2  DMA request */
;;;1819         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1820       }
;;;1821       break;
;;;1822   
;;;1823       case TIM_CHANNEL_3:
;;;1824       {
;;;1825         /* Set the DMA Period elapsed callback */
;;;1826         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1827   
;;;1828         /* Set the DMA error callback */
;;;1829         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;1830   
;;;1831         /* Enable the DMA channel */
;;;1832         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length);
;;;1833   
;;;1834         /* Enable the TIM Capture/Compare 3  DMA request */
;;;1835         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1836       }
;;;1837       break;
;;;1838   
;;;1839       case TIM_CHANNEL_4:
;;;1840       {
;;;1841         /* Set the DMA Period elapsed callback */
;;;1842         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1843   
;;;1844         /* Set the DMA error callback */
;;;1845         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;1846   
;;;1847         /* Enable the DMA channel */
;;;1848         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length);
;;;1849   
;;;1850         /* Enable the TIM Capture/Compare 4  DMA request */
;;;1851         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1852       }
;;;1853       break;
;;;1854   
;;;1855       default:
;;;1856       break;
;;;1857     }
;;;1858   
;;;1859     /* Enable the Input Capture channel */
;;;1860     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1861   
;;;1862     /* Enable the Peripheral */
;;;1863     __HAL_TIM_ENABLE(htim);
;;;1864   
;;;1865     /* Return function status */
;;;1866     return HAL_OK;
;;;1867   }
00001a  bd70              POP      {r4-r6,pc}
                  |L40.28|
00001c  2002              MOVS     r0,#2                 ;1785
00001e  f884003d          STRB     r0,[r4,#0x3d]         ;1785
                  |L40.34|
000022  4827              LDR      r0,|L40.192|
000024  4d27              LDR      r5,|L40.196|
000026  b136              CBZ      r6,|L40.54|
000028  2e04              CMP      r6,#4                 ;1789
00002a  d012              BEQ      |L40.82|
00002c  2e08              CMP      r6,#8                 ;1789
00002e  d02a              BEQ      |L40.134|
000030  2e0c              CMP      r6,#0xc               ;1789
000032  d11c              BNE      |L40.110|
000034  e035              B        |L40.162|
                  |L40.54|
000036  6a61              LDR      r1,[r4,#0x24]         ;1794
000038  6288              STR      r0,[r1,#0x28]         ;1797
00003a  6a60              LDR      r0,[r4,#0x24]         ;1797
00003c  6305              STR      r5,[r0,#0x30]         ;1800
00003e  6821              LDR      r1,[r4,#0]            ;1800
000040  6a60              LDR      r0,[r4,#0x24]         ;1800
000042  3134              ADDS     r1,r1,#0x34           ;1800
000044  f7fffffe          BL       HAL_DMA_Start_IT
000048  6820              LDR      r0,[r4,#0]            ;1803
00004a  68c1              LDR      r1,[r0,#0xc]          ;1803
00004c  f4417100          ORR      r1,r1,#0x200          ;1803
000050  e00c              B        |L40.108|
                  |L40.82|
000052  6aa1              LDR      r1,[r4,#0x28]         ;1810
000054  6288              STR      r0,[r1,#0x28]         ;1813
000056  6aa0              LDR      r0,[r4,#0x28]         ;1813
000058  6305              STR      r5,[r0,#0x30]         ;1816
00005a  6821              LDR      r1,[r4,#0]            ;1816
00005c  6aa0              LDR      r0,[r4,#0x28]         ;1816
00005e  3138              ADDS     r1,r1,#0x38           ;1816
000060  f7fffffe          BL       HAL_DMA_Start_IT
000064  6820              LDR      r0,[r4,#0]            ;1819
000066  68c1              LDR      r1,[r0,#0xc]          ;1819
000068  f4416180          ORR      r1,r1,#0x400          ;1819
                  |L40.108|
00006c  60c1              STR      r1,[r0,#0xc]          ;1803
                  |L40.110|
00006e  2201              MOVS     r2,#1                 ;1860
000070  4631              MOV      r1,r6                 ;1860
000072  6820              LDR      r0,[r4,#0]            ;1860
000074  f7fffffe          BL       TIM_CCxChannelCmd
000078  6820              LDR      r0,[r4,#0]            ;1863
00007a  6801              LDR      r1,[r0,#0]            ;1863
00007c  f0410101          ORR      r1,r1,#1              ;1863
000080  6001              STR      r1,[r0,#0]            ;1863
000082  2000              MOVS     r0,#0                 ;1866
000084  bd70              POP      {r4-r6,pc}
                  |L40.134|
000086  6ae1              LDR      r1,[r4,#0x2c]         ;1826
000088  6288              STR      r0,[r1,#0x28]         ;1829
00008a  6ae0              LDR      r0,[r4,#0x2c]         ;1829
00008c  6305              STR      r5,[r0,#0x30]         ;1832
00008e  6821              LDR      r1,[r4,#0]            ;1832
000090  6ae0              LDR      r0,[r4,#0x2c]         ;1832
000092  313c              ADDS     r1,r1,#0x3c           ;1832
000094  f7fffffe          BL       HAL_DMA_Start_IT
000098  6820              LDR      r0,[r4,#0]            ;1835
00009a  68c1              LDR      r1,[r0,#0xc]          ;1835
00009c  f4416100          ORR      r1,r1,#0x800          ;1835
0000a0  e7e4              B        |L40.108|
                  |L40.162|
0000a2  6b21              LDR      r1,[r4,#0x30]         ;1842
0000a4  6288              STR      r0,[r1,#0x28]         ;1845
0000a6  6b20              LDR      r0,[r4,#0x30]         ;1845
0000a8  6305              STR      r5,[r0,#0x30]         ;1848
0000aa  6821              LDR      r1,[r4,#0]            ;1848
0000ac  6b20              LDR      r0,[r4,#0x30]         ;1848
0000ae  3140              ADDS     r1,r1,#0x40           ;1848
0000b0  f7fffffe          BL       HAL_DMA_Start_IT
0000b4  6820              LDR      r0,[r4,#0]            ;1851
0000b6  68c1              LDR      r1,[r0,#0xc]          ;1851
0000b8  f4415180          ORR      r1,r1,#0x1000         ;1851
0000bc  e7d6              B        |L40.108|
;;;1868   
                          ENDP

0000be  0000              DCW      0x0000
                  |L40.192|
                          DCD      TIM_DMACaptureCplt
                  |L40.196|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_IC_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Start_IT PROC
;;;1645   */
;;;1646   HAL_StatusTypeDef HAL_TIM_IC_Start_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1647   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L41.22|
;;;1648     /* Check the parameters */
;;;1649     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1650   
;;;1651     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L41.30|
00000c  2908              CMP      r1,#8
00000e  d015              BEQ      |L41.60|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L41.38|
000014  e016              B        |L41.68|
                  |L41.22|
;;;1652     {
;;;1653       case TIM_CHANNEL_1:
;;;1654       {
;;;1655         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1656         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0400002          ORR      r0,r0,#2
;;;1657       }
;;;1658       break;
00001c  e002              B        |L41.36|
                  |L41.30|
;;;1659   
;;;1660       case TIM_CHANNEL_2:
;;;1661       {
;;;1662         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1663         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0400004          ORR      r0,r0,#4
                  |L41.36|
000024  60d0              STR      r0,[r2,#0xc]          ;1656
                  |L41.38|
;;;1664       }
;;;1665       break;
;;;1666   
;;;1667       case TIM_CHANNEL_3:
;;;1668       {
;;;1669         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1670         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
;;;1671       }
;;;1672       break;
;;;1673   
;;;1674       case TIM_CHANNEL_4:
;;;1675       {
;;;1676         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1677         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
;;;1678       }
;;;1679       break;
;;;1680   
;;;1681       default:
;;;1682       break;
;;;1683     }
;;;1684     /* Enable the Input Capture channel */
;;;1685     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000026  2201              MOVS     r2,#1
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;1686   
;;;1687     /* Enable the Peripheral */
;;;1688     __HAL_TIM_ENABLE(htim);
00002e  6820              LDR      r0,[r4,#0]
000030  6801              LDR      r1,[r0,#0]
000032  f0410101          ORR      r1,r1,#1
000036  6001              STR      r1,[r0,#0]
;;;1689   
;;;1690     /* Return function status */
;;;1691     return HAL_OK;
000038  2000              MOVS     r0,#0
;;;1692   }
00003a  bd10              POP      {r4,pc}
                  |L41.60|
00003c  68d0              LDR      r0,[r2,#0xc]          ;1670
00003e  f0400008          ORR      r0,r0,#8              ;1670
000042  e7ef              B        |L41.36|
                  |L41.68|
000044  68d0              LDR      r0,[r2,#0xc]          ;1677
000046  f0400010          ORR      r0,r0,#0x10           ;1677
00004a  e7eb              B        |L41.36|
;;;1693   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop PROC
;;;1619   */
;;;1620   HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1621   {
000002  4604              MOV      r4,r0
;;;1622     /* Check the parameters */
;;;1623     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1624   
;;;1625     /* Disable the Input Capture channel */
;;;1626     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2200              MOVS     r2,#0
000008  f7fffffe          BL       TIM_CCxChannelCmd
;;;1627   
;;;1628     /* Disable the Peripheral */
;;;1629     __HAL_TIM_DISABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  6a01              LDR      r1,[r0,#0x20]
000010  f2411211          MOV      r2,#0x1111
000014  4211              TST      r1,r2
000016  d107              BNE      |L42.40|
000018  6a01              LDR      r1,[r0,#0x20]
00001a  1092              ASRS     r2,r2,#2
00001c  4211              TST      r1,r2
00001e  d103              BNE      |L42.40|
000020  6801              LDR      r1,[r0,#0]
000022  f0210101          BIC      r1,r1,#1
000026  6001              STR      r1,[r0,#0]
                  |L42.40|
;;;1630   
;;;1631     /* Return function status */
;;;1632     return HAL_OK;
000028  2000              MOVS     r0,#0
;;;1633   }
00002a  bd10              POP      {r4,pc}
;;;1634   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop_DMA PROC
;;;1879   */
;;;1880   HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1881   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L43.22|
;;;1882     /* Check the parameters */
;;;1883     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1884     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;1885   
;;;1886     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L43.30|
00000c  2908              CMP      r1,#8
00000e  d021              BEQ      |L43.84|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L43.38|
000014  e022              B        |L43.92|
                  |L43.22|
;;;1887     {
;;;1888       case TIM_CHANNEL_1:
;;;1889       {
;;;1890         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1891         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f4207000          BIC      r0,r0,#0x200
;;;1892       }
;;;1893       break;
00001c  e002              B        |L43.36|
                  |L43.30|
;;;1894   
;;;1895       case TIM_CHANNEL_2:
;;;1896       {
;;;1897         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1898         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f4206080          BIC      r0,r0,#0x400
                  |L43.36|
000024  60d0              STR      r0,[r2,#0xc]          ;1891
                  |L43.38|
;;;1899       }
;;;1900       break;
;;;1901   
;;;1902       case TIM_CHANNEL_3:
;;;1903       {
;;;1904         /* Disable the TIM Capture/Compare 3  DMA request */
;;;1905         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
;;;1906       }
;;;1907       break;
;;;1908   
;;;1909       case TIM_CHANNEL_4:
;;;1910       {
;;;1911         /* Disable the TIM Capture/Compare 4  DMA request */
;;;1912         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
;;;1913       }
;;;1914       break;
;;;1915   
;;;1916       default:
;;;1917       break;
;;;1918     }
;;;1919   
;;;1920     /* Disable the Input Capture channel */
;;;1921     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000026  2200              MOVS     r2,#0
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;1922   
;;;1923     /* Disable the Peripheral */
;;;1924     __HAL_TIM_DISABLE(htim);
00002e  6820              LDR      r0,[r4,#0]
000030  6a01              LDR      r1,[r0,#0x20]
000032  f2411211          MOV      r2,#0x1111
000036  4211              TST      r1,r2
000038  d107              BNE      |L43.74|
00003a  6a01              LDR      r1,[r0,#0x20]
00003c  1092              ASRS     r2,r2,#2
00003e  4211              TST      r1,r2
000040  d103              BNE      |L43.74|
000042  6801              LDR      r1,[r0,#0]
000044  f0210101          BIC      r1,r1,#1
000048  6001              STR      r1,[r0,#0]
                  |L43.74|
;;;1925   
;;;1926     /* Change the htim state */
;;;1927     htim->State = HAL_TIM_STATE_READY;
00004a  2001              MOVS     r0,#1
00004c  f884003d          STRB     r0,[r4,#0x3d]
;;;1928   
;;;1929     /* Return function status */
;;;1930     return HAL_OK;
000050  2000              MOVS     r0,#0
;;;1931   }
000052  bd10              POP      {r4,pc}
                  |L43.84|
000054  68d0              LDR      r0,[r2,#0xc]          ;1905
000056  f4206000          BIC      r0,r0,#0x800          ;1905
00005a  e7e3              B        |L43.36|
                  |L43.92|
00005c  68d0              LDR      r0,[r2,#0xc]          ;1912
00005e  f4205080          BIC      r0,r0,#0x1000         ;1912
000062  e7df              B        |L43.36|
;;;1932   /**
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop_IT PROC
;;;1704   */
;;;1705   HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1706   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L44.22|
;;;1707     /* Check the parameters */
;;;1708     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1709   
;;;1710     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L44.30|
00000c  2908              CMP      r1,#8
00000e  d01e              BEQ      |L44.78|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L44.38|
000014  e01f              B        |L44.86|
                  |L44.22|
;;;1711     {
;;;1712       case TIM_CHANNEL_1:
;;;1713       {
;;;1714         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1715         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0200002          BIC      r0,r0,#2
;;;1716       }
;;;1717       break;
00001c  e002              B        |L44.36|
                  |L44.30|
;;;1718   
;;;1719       case TIM_CHANNEL_2:
;;;1720       {
;;;1721         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1722         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0200004          BIC      r0,r0,#4
                  |L44.36|
000024  60d0              STR      r0,[r2,#0xc]          ;1715
                  |L44.38|
;;;1723       }
;;;1724       break;
;;;1725   
;;;1726       case TIM_CHANNEL_3:
;;;1727       {
;;;1728         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1729         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
;;;1730       }
;;;1731       break;
;;;1732   
;;;1733       case TIM_CHANNEL_4:
;;;1734       {
;;;1735         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1736         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
;;;1737       }
;;;1738       break;
;;;1739   
;;;1740       default:
;;;1741       break;
;;;1742     }
;;;1743   
;;;1744     /* Disable the Input Capture channel */
;;;1745     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000026  2200              MOVS     r2,#0
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;1746   
;;;1747     /* Disable the Peripheral */
;;;1748     __HAL_TIM_DISABLE(htim);
00002e  6820              LDR      r0,[r4,#0]
000030  6a01              LDR      r1,[r0,#0x20]
000032  f2411211          MOV      r2,#0x1111
000036  4211              TST      r1,r2
000038  d107              BNE      |L44.74|
00003a  6a01              LDR      r1,[r0,#0x20]
00003c  1092              ASRS     r2,r2,#2
00003e  4211              TST      r1,r2
000040  d103              BNE      |L44.74|
000042  6801              LDR      r1,[r0,#0]
000044  f0210101          BIC      r1,r1,#1
000048  6001              STR      r1,[r0,#0]
                  |L44.74|
;;;1749   
;;;1750     /* Return function status */
;;;1751     return HAL_OK;
00004a  2000              MOVS     r0,#0
;;;1752   }
00004c  bd10              POP      {r4,pc}
                  |L44.78|
00004e  68d0              LDR      r0,[r2,#0xc]          ;1729
000050  f0200008          BIC      r0,r0,#8              ;1729
000054  e7e6              B        |L44.36|
                  |L44.86|
000056  68d0              LDR      r0,[r2,#0xc]          ;1736
000058  f0200010          BIC      r0,r0,#0x10           ;1736
00005c  e7e2              B        |L44.36|
;;;1753   
                          ENDP


                          AREA ||i.HAL_TIM_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IRQHandler PROC
;;;2769     */
;;;2770   void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
000000  b570              PUSH     {r4-r6,lr}
;;;2771   {
000002  4604              MOV      r4,r0
;;;2772     /* Capture compare 1 event */
;;;2773     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
000004  6800              LDR      r0,[r0,#0]
000006  6901              LDR      r1,[r0,#0x10]
000008  f04f0500          MOV      r5,#0
00000c  43c9              MVNS     r1,r1
00000e  0789              LSLS     r1,r1,#30
000010  d415              BMI      |L45.62|
;;;2774     {
;;;2775       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
000012  68c1              LDR      r1,[r0,#0xc]
000014  43c9              MVNS     r1,r1
000016  0789              LSLS     r1,r1,#30
000018  d411              BMI      |L45.62|
;;;2776       {
;;;2777         {
;;;2778           __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
00001a  1ee9              SUBS     r1,r5,#3
00001c  6101              STR      r1,[r0,#0x10]
;;;2779           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
00001e  2001              MOVS     r0,#1
000020  7720              STRB     r0,[r4,#0x1c]
;;;2780   
;;;2781           /* Input capture event */
;;;2782           if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
000022  6820              LDR      r0,[r4,#0]
000024  6980              LDR      r0,[r0,#0x18]
000026  0780              LSLS     r0,r0,#30
;;;2783           {
;;;2784             HAL_TIM_IC_CaptureCallback(htim);
;;;2785           }
;;;2786           /* Output compare event */
;;;2787           else
;;;2788           {
;;;2789             HAL_TIM_OC_DelayElapsedCallback(htim);
000028  4620              MOV      r0,r4
00002a  d002              BEQ      |L45.50|
00002c  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
000030  e004              B        |L45.60|
                  |L45.50|
000032  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2790             HAL_TIM_PWM_PulseFinishedCallback(htim);
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.60|
;;;2791           }
;;;2792           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
00003c  7725              STRB     r5,[r4,#0x1c]
                  |L45.62|
;;;2793         }
;;;2794       }
;;;2795     }
;;;2796     /* Capture compare 2 event */
;;;2797     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
00003e  6820              LDR      r0,[r4,#0]
000040  6901              LDR      r1,[r0,#0x10]
000042  43c9              MVNS     r1,r1
000044  0749              LSLS     r1,r1,#29
000046  d417              BMI      |L45.120|
;;;2798     {
;;;2799       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
000048  68c1              LDR      r1,[r0,#0xc]
00004a  43c9              MVNS     r1,r1
00004c  0749              LSLS     r1,r1,#29
00004e  d413              BMI      |L45.120|
;;;2800       {
;;;2801         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
000050  f06f0104          MVN      r1,#4
000054  6101              STR      r1,[r0,#0x10]
;;;2802         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
000056  2002              MOVS     r0,#2
000058  7720              STRB     r0,[r4,#0x1c]
;;;2803         /* Input capture event */
;;;2804         if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
00005a  6820              LDR      r0,[r4,#0]
00005c  6980              LDR      r0,[r0,#0x18]
00005e  f4107f40          TST      r0,#0x300
;;;2805         {
;;;2806           HAL_TIM_IC_CaptureCallback(htim);
;;;2807         }
;;;2808         /* Output compare event */
;;;2809         else
;;;2810         {
;;;2811           HAL_TIM_OC_DelayElapsedCallback(htim);
000062  4620              MOV      r0,r4
000064  d002              BEQ      |L45.108|
000066  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
00006a  e004              B        |L45.118|
                  |L45.108|
00006c  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2812           HAL_TIM_PWM_PulseFinishedCallback(htim);
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.118|
;;;2813         }
;;;2814         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000076  7725              STRB     r5,[r4,#0x1c]
                  |L45.120|
;;;2815       }
;;;2816     }
;;;2817     /* Capture compare 3 event */
;;;2818     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
000078  6820              LDR      r0,[r4,#0]
00007a  6901              LDR      r1,[r0,#0x10]
00007c  43c9              MVNS     r1,r1
00007e  0709              LSLS     r1,r1,#28
000080  d416              BMI      |L45.176|
;;;2819     {
;;;2820       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
000082  68c1              LDR      r1,[r0,#0xc]
000084  43c9              MVNS     r1,r1
000086  0709              LSLS     r1,r1,#28
000088  d412              BMI      |L45.176|
;;;2821       {
;;;2822         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
00008a  f06f0108          MVN      r1,#8
00008e  6101              STR      r1,[r0,#0x10]
;;;2823         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000090  2004              MOVS     r0,#4
000092  7720              STRB     r0,[r4,#0x1c]
;;;2824         /* Input capture event */
;;;2825         if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
000094  6820              LDR      r0,[r4,#0]
000096  69c0              LDR      r0,[r0,#0x1c]
000098  0780              LSLS     r0,r0,#30
;;;2826         {
;;;2827           HAL_TIM_IC_CaptureCallback(htim);
;;;2828         }
;;;2829         /* Output compare event */
;;;2830         else
;;;2831         {
;;;2832           HAL_TIM_OC_DelayElapsedCallback(htim);
00009a  4620              MOV      r0,r4
00009c  d002              BEQ      |L45.164|
00009e  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
0000a2  e004              B        |L45.174|
                  |L45.164|
0000a4  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2833           HAL_TIM_PWM_PulseFinishedCallback(htim);
0000a8  4620              MOV      r0,r4
0000aa  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.174|
;;;2834         }
;;;2835         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
0000ae  7725              STRB     r5,[r4,#0x1c]
                  |L45.176|
;;;2836       }
;;;2837     }
;;;2838     /* Capture compare 4 event */
;;;2839     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
0000b0  6820              LDR      r0,[r4,#0]
0000b2  6901              LDR      r1,[r0,#0x10]
0000b4  43c9              MVNS     r1,r1
0000b6  06c9              LSLS     r1,r1,#27
0000b8  d417              BMI      |L45.234|
;;;2840     {
;;;2841       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
0000ba  68c1              LDR      r1,[r0,#0xc]
0000bc  43c9              MVNS     r1,r1
0000be  06c9              LSLS     r1,r1,#27
0000c0  d413              BMI      |L45.234|
;;;2842       {
;;;2843         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
0000c2  f06f0110          MVN      r1,#0x10
0000c6  6101              STR      r1,[r0,#0x10]
;;;2844         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
0000c8  2008              MOVS     r0,#8
0000ca  7720              STRB     r0,[r4,#0x1c]
;;;2845         /* Input capture event */
;;;2846         if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
0000cc  6820              LDR      r0,[r4,#0]
0000ce  69c0              LDR      r0,[r0,#0x1c]
0000d0  f4107f40          TST      r0,#0x300
;;;2847         {
;;;2848           HAL_TIM_IC_CaptureCallback(htim);
;;;2849         }
;;;2850         /* Output compare event */
;;;2851         else
;;;2852         {
;;;2853           HAL_TIM_OC_DelayElapsedCallback(htim);
0000d4  4620              MOV      r0,r4
0000d6  d002              BEQ      |L45.222|
0000d8  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
0000dc  e004              B        |L45.232|
                  |L45.222|
0000de  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2854           HAL_TIM_PWM_PulseFinishedCallback(htim);
0000e2  4620              MOV      r0,r4
0000e4  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.232|
;;;2855         }
;;;2856         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
0000e8  7725              STRB     r5,[r4,#0x1c]
                  |L45.234|
;;;2857       }
;;;2858     }
;;;2859     /* TIM Update event */
;;;2860     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
0000ea  6820              LDR      r0,[r4,#0]
0000ec  6901              LDR      r1,[r0,#0x10]
0000ee  43c9              MVNS     r1,r1
0000f0  07c9              LSLS     r1,r1,#31
0000f2  d108              BNE      |L45.262|
;;;2861     {
;;;2862       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
0000f4  68c1              LDR      r1,[r0,#0xc]
0000f6  43c9              MVNS     r1,r1
0000f8  07c9              LSLS     r1,r1,#31
0000fa  d104              BNE      |L45.262|
;;;2863       {
;;;2864         __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
0000fc  1e89              SUBS     r1,r1,#2
0000fe  6101              STR      r1,[r0,#0x10]
;;;2865         HAL_TIM_PeriodElapsedCallback(htim);
000100  4620              MOV      r0,r4
000102  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
                  |L45.262|
;;;2866       }
;;;2867     }
;;;2868     /* TIM Break input event */
;;;2869     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
000106  6820              LDR      r0,[r4,#0]
000108  6901              LDR      r1,[r0,#0x10]
00010a  43c9              MVNS     r1,r1
00010c  0609              LSLS     r1,r1,#24
00010e  d409              BMI      |L45.292|
;;;2870     {
;;;2871       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
000110  68c1              LDR      r1,[r0,#0xc]
000112  43c9              MVNS     r1,r1
000114  0609              LSLS     r1,r1,#24
000116  d405              BMI      |L45.292|
;;;2872       {
;;;2873         __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
000118  f06f0180          MVN      r1,#0x80
00011c  6101              STR      r1,[r0,#0x10]
;;;2874         HAL_TIMEx_BreakCallback(htim);
00011e  4620              MOV      r0,r4
000120  f7fffffe          BL       HAL_TIMEx_BreakCallback
                  |L45.292|
;;;2875       }
;;;2876     }
;;;2877     /* TIM Trigger detection event */
;;;2878     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
000124  6820              LDR      r0,[r4,#0]
000126  6901              LDR      r1,[r0,#0x10]
000128  43c9              MVNS     r1,r1
00012a  0649              LSLS     r1,r1,#25
00012c  d409              BMI      |L45.322|
;;;2879     {
;;;2880       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
00012e  68c1              LDR      r1,[r0,#0xc]
000130  43c9              MVNS     r1,r1
000132  0649              LSLS     r1,r1,#25
000134  d405              BMI      |L45.322|
;;;2881       {
;;;2882         __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
000136  f06f0140          MVN      r1,#0x40
00013a  6101              STR      r1,[r0,#0x10]
;;;2883         HAL_TIM_TriggerCallback(htim);
00013c  4620              MOV      r0,r4
00013e  f7fffffe          BL       HAL_TIM_TriggerCallback
                  |L45.322|
;;;2884       }
;;;2885     }
;;;2886     /* TIM commutation event */
;;;2887     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
000142  6820              LDR      r0,[r4,#0]
000144  6901              LDR      r1,[r0,#0x10]
000146  43c9              MVNS     r1,r1
000148  0689              LSLS     r1,r1,#26
00014a  d40b              BMI      |L45.356|
;;;2888     {
;;;2889       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
00014c  68c1              LDR      r1,[r0,#0xc]
00014e  43c9              MVNS     r1,r1
000150  0689              LSLS     r1,r1,#26
000152  d407              BMI      |L45.356|
;;;2890       {
;;;2891         __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
000154  f06f0120          MVN      r1,#0x20
000158  6101              STR      r1,[r0,#0x10]
;;;2892         HAL_TIMEx_CommutationCallback(htim);
00015a  4620              MOV      r0,r4
00015c  e8bd4070          POP      {r4-r6,lr}
000160  f7ffbffe          B.W      HAL_TIMEx_CommutationCallback
                  |L45.356|
;;;2893       }
;;;2894     }
;;;2895   }
000164  bd70              POP      {r4-r6,pc}
;;;2896   
                          ENDP


                          AREA ||i.HAL_TIM_OC_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_ConfigChannel PROC
;;;2932     */
;;;2933   HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;2934   {
000002  4604              MOV      r4,r0
;;;2935     /* Check the parameters */
;;;2936     assert_param(IS_TIM_CHANNELS(Channel));
;;;2937     assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
;;;2938     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;2939   
;;;2940     /* Check input state */
;;;2941     __HAL_LOCK(htim);
000004  f890003c          LDRB     r0,[r0,#0x3c]
000008  2801              CMP      r0,#1
00000a  d00d              BEQ      |L46.40|
00000c  2501              MOVS     r5,#1
00000e  f884503c          STRB     r5,[r4,#0x3c]
;;;2942   
;;;2943     htim->State = HAL_TIM_STATE_BUSY;
000012  2002              MOVS     r0,#2
000014  f884003d          STRB     r0,[r4,#0x3d]
000018  b142              CBZ      r2,|L46.44|
;;;2944   
;;;2945     switch (Channel)
00001a  2a04              CMP      r2,#4
00001c  d00a              BEQ      |L46.52|
00001e  2a08              CMP      r2,#8
000020  d00c              BEQ      |L46.60|
000022  2a0c              CMP      r2,#0xc
000024  d111              BNE      |L46.74|
000026  e00d              B        |L46.68|
                  |L46.40|
000028  2002              MOVS     r0,#2                 ;2941
;;;2946     {
;;;2947       case TIM_CHANNEL_1:
;;;2948       {
;;;2949         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;2950         /* Configure the TIM Channel 1 in Output Compare */
;;;2951         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;2952       }
;;;2953       break;
;;;2954   
;;;2955       case TIM_CHANNEL_2:
;;;2956       {
;;;2957         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2958         /* Configure the TIM Channel 2 in Output Compare */
;;;2959         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;2960       }
;;;2961       break;
;;;2962   
;;;2963       case TIM_CHANNEL_3:
;;;2964       {
;;;2965          assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;2966         /* Configure the TIM Channel 3 in Output Compare */
;;;2967         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;2968       }
;;;2969       break;
;;;2970   
;;;2971       case TIM_CHANNEL_4:
;;;2972       {
;;;2973         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;2974          /* Configure the TIM Channel 4 in Output Compare */
;;;2975          TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;2976       }
;;;2977       break;
;;;2978   
;;;2979       default:
;;;2980       break;
;;;2981     }
;;;2982     htim->State = HAL_TIM_STATE_READY;
;;;2983   
;;;2984     __HAL_UNLOCK(htim);
;;;2985   
;;;2986     return HAL_OK;
;;;2987   }
00002a  bd70              POP      {r4-r6,pc}
                  |L46.44|
00002c  6820              LDR      r0,[r4,#0]            ;2951
00002e  f7fffffe          BL       TIM_OC1_SetConfig
000032  e00a              B        |L46.74|
                  |L46.52|
000034  6820              LDR      r0,[r4,#0]            ;2959
000036  f7fffffe          BL       TIM_OC2_SetConfig
00003a  e006              B        |L46.74|
                  |L46.60|
00003c  6820              LDR      r0,[r4,#0]            ;2967
00003e  f7fffffe          BL       TIM_OC3_SetConfig
000042  e002              B        |L46.74|
                  |L46.68|
000044  6820              LDR      r0,[r4,#0]            ;2975
000046  f7fffffe          BL       TIM_OC4_SetConfig
                  |L46.74|
00004a  f884503d          STRB     r5,[r4,#0x3d]         ;2982
00004e  2000              MOVS     r0,#0                 ;2984
000050  f884003c          STRB     r0,[r4,#0x3c]         ;2984
000054  bd70              POP      {r4-r6,pc}
;;;2988   
                          ENDP


                          AREA ||i.HAL_TIM_OC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_DeInit PROC
;;;519      */
;;;520    HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;521    {
000002  4604              MOV      r4,r0
;;;522      /* Check the parameters */
;;;523      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;524    
;;;525       htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f884003d          STRB     r0,[r4,#0x3d]
;;;526    
;;;527      /* Disable the TIM Peripheral Clock */
;;;528      __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L47.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L47.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L47.38|
;;;529    
;;;530      /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;531      HAL_TIM_OC_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_OC_MspDeInit
;;;532    
;;;533      /* Change TIM state */
;;;534      htim->State = HAL_TIM_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  f884003d          STRB     r0,[r4,#0x3d]
;;;535    
;;;536      /* Release Lock */
;;;537      __HAL_UNLOCK(htim);
000032  f884003c          STRB     r0,[r4,#0x3c]
;;;538    
;;;539      return HAL_OK;
;;;540    }
000036  bd10              POP      {r4,pc}
;;;541    
                          ENDP


                          AREA ||i.HAL_TIM_OC_DelayElapsedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_DelayElapsedCallback PROC
;;;4298     */
;;;4299   __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4300   {
;;;4301     /* Prevent unused argument(s) compilation warning */
;;;4302     UNUSED(htim);
;;;4303     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4304               the __HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
;;;4305      */
;;;4306   }
;;;4307   /**
                          ENDP


                          AREA ||i.HAL_TIM_OC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_GetState PROC
;;;4396     */
;;;4397   HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
000000  f890003d          LDRB     r0,[r0,#0x3d]
;;;4398   {
;;;4399     return htim->State;
;;;4400   }
000004  4770              BX       lr
;;;4401   
                          ENDP


                          AREA ||i.HAL_TIM_OC_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_Init PROC
;;;479      */
;;;480    HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef* htim)
000000  b510              PUSH     {r4,lr}
;;;481    {
000002  0004              MOVS     r4,r0
000004  d003              BEQ      |L50.14|
;;;482      /* Check the TIM handle allocation */
;;;483      if(htim == NULL)
;;;484      {
;;;485        return HAL_ERROR;
;;;486      }
;;;487    
;;;488      /* Check the parameters */
;;;489      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;490      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;491      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;492      assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;493    
;;;494      if(htim->State == HAL_TIM_STATE_RESET)
000006  f894003d          LDRB     r0,[r4,#0x3d]
00000a  b110              CBZ      r0,|L50.18|
00000c  e007              B        |L50.30|
                  |L50.14|
00000e  2001              MOVS     r0,#1                 ;485
;;;495      {
;;;496        /* Allocate lock resource and initialize it */
;;;497        htim->Lock = HAL_UNLOCKED;
;;;498        
;;;499        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;500        HAL_TIM_OC_MspInit(htim);
;;;501      }
;;;502    
;;;503      /* Set the TIM state */
;;;504      htim->State= HAL_TIM_STATE_BUSY;
;;;505    
;;;506      /* Init the base time for the Output Compare */
;;;507      TIM_Base_SetConfig(htim->Instance,  &htim->Init);
;;;508    
;;;509      /* Initialize the TIM state*/
;;;510      htim->State= HAL_TIM_STATE_READY;
;;;511    
;;;512      return HAL_OK;
;;;513    }
000010  bd10              POP      {r4,pc}
                  |L50.18|
000012  2000              MOVS     r0,#0                 ;497
000014  f884003c          STRB     r0,[r4,#0x3c]         ;497
000018  4620              MOV      r0,r4                 ;500
00001a  f7fffffe          BL       HAL_TIM_OC_MspInit
                  |L50.30|
00001e  2002              MOVS     r0,#2                 ;504
000020  f884003d          STRB     r0,[r4,#0x3d]         ;504
000024  1d21              ADDS     r1,r4,#4              ;507
000026  6820              LDR      r0,[r4,#0]            ;507
000028  f7fffffe          BL       TIM_Base_SetConfig
00002c  2001              MOVS     r0,#1                 ;510
00002e  f884003d          STRB     r0,[r4,#0x3d]         ;510
000032  2000              MOVS     r0,#0                 ;512
000034  bd10              POP      {r4,pc}
;;;514    
                          ENDP


                          AREA ||i.HAL_TIM_OC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_MspDeInit PROC
;;;560      */
;;;561    __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;562    {
;;;563      /* Prevent unused argument(s) compilation warning */
;;;564      UNUSED(htim);
;;;565      /* NOTE : This function Should not be modified, when the callback is needed,
;;;566                the HAL_TIM_OC_MspDeInit could be implemented in the user file
;;;567       */
;;;568    }
;;;569    
                          ENDP


                          AREA ||i.HAL_TIM_OC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_MspInit PROC
;;;546      */
;;;547    __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;548    {
;;;549      /* Prevent unused argument(s) compilation warning */
;;;550      UNUSED(htim);
;;;551      /* NOTE : This function Should not be modified, when the callback is needed,
;;;552                the HAL_TIM_OC_MspInit could be implemented in the user file
;;;553       */
;;;554    }
;;;555    
                          ENDP


                          AREA ||i.HAL_TIM_OC_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start PROC
;;;580    */
;;;581    HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;582    {
000002  4604              MOV      r4,r0
;;;583      /* Check the parameters */
;;;584      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;585    
;;;586      /* Enable the Output compare channel */
;;;587      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2201              MOVS     r2,#1
000008  f7fffffe          BL       TIM_CCxChannelCmd
;;;588    
;;;589      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00000c  4907              LDR      r1,|L53.44|
00000e  6820              LDR      r0,[r4,#0]
000010  4288              CMP      r0,r1
000012  d103              BNE      |L53.28|
;;;590      {
;;;591        /* Enable the main output */
;;;592        __HAL_TIM_MOE_ENABLE(htim);
000014  6c41              LDR      r1,[r0,#0x44]
000016  f4414100          ORR      r1,r1,#0x8000
00001a  6441              STR      r1,[r0,#0x44]
                  |L53.28|
;;;593      }
;;;594    
;;;595      /* Enable the Peripheral */
;;;596      __HAL_TIM_ENABLE(htim);
00001c  6820              LDR      r0,[r4,#0]
00001e  6801              LDR      r1,[r0,#0]
000020  f0410101          ORR      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
;;;597    
;;;598      /* Return function status */
;;;599      return HAL_OK;
000026  2000              MOVS     r0,#0
;;;600    }
000028  bd10              POP      {r4,pc}
;;;601    
                          ENDP

00002a  0000              DCW      0x0000
                  |L53.44|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_OC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start_DMA PROC
;;;778    */
;;;779    HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;780    {
000002  4604              MOV      r4,r0
;;;781      /* Check the parameters */
;;;782      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;783    
;;;784      if((htim->State == HAL_TIM_STATE_BUSY))
000004  f890003d          LDRB     r0,[r0,#0x3d]
000008  4616              MOV      r6,r2                 ;780
00000a  460d              MOV      r5,r1                 ;780
00000c  2802              CMP      r0,#2
00000e  d005              BEQ      |L54.28|
;;;785      {
;;;786         return HAL_BUSY;
;;;787      }
;;;788      else if((htim->State == HAL_TIM_STATE_READY))
000010  f894003d          LDRB     r0,[r4,#0x3d]
000014  2801              CMP      r0,#1
000016  d105              BNE      |L54.36|
;;;789      {
;;;790        if(((uint32_t)pData == 0U) && (Length > 0U))
000018  b90e              CBNZ     r6,|L54.30|
00001a  b103              CBZ      r3,|L54.30|
                  |L54.28|
;;;791        {
;;;792          return HAL_ERROR;
;;;793        }
;;;794        else
;;;795        {
;;;796          htim->State = HAL_TIM_STATE_BUSY;
;;;797        }
;;;798      }
;;;799      switch (Channel)
;;;800      {
;;;801        case TIM_CHANNEL_1:
;;;802        {
;;;803          /* Set the DMA Period elapsed callback */
;;;804          htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;805    
;;;806          /* Set the DMA error callback */
;;;807          htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;808    
;;;809          /* Enable the DMA channel */
;;;810          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;811    
;;;812          /* Enable the TIM Capture/Compare 1 DMA request */
;;;813          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;814        }
;;;815        break;
;;;816    
;;;817        case TIM_CHANNEL_2:
;;;818        {
;;;819          /* Set the DMA Period elapsed callback */
;;;820          htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;821    
;;;822          /* Set the DMA error callback */
;;;823          htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;824    
;;;825          /* Enable the DMA channel */
;;;826          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;827    
;;;828          /* Enable the TIM Capture/Compare 2 DMA request */
;;;829          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;830        }
;;;831        break;
;;;832    
;;;833        case TIM_CHANNEL_3:
;;;834        {
;;;835          /* Set the DMA Period elapsed callback */
;;;836          htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;837    
;;;838          /* Set the DMA error callback */
;;;839          htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;840    
;;;841          /* Enable the DMA channel */
;;;842          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;843    
;;;844          /* Enable the TIM Capture/Compare 3 DMA request */
;;;845          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;846        }
;;;847        break;
;;;848    
;;;849        case TIM_CHANNEL_4:
;;;850        {
;;;851         /* Set the DMA Period elapsed callback */
;;;852          htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;853    
;;;854          /* Set the DMA error callback */
;;;855          htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;856    
;;;857          /* Enable the DMA channel */
;;;858          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;859    
;;;860          /* Enable the TIM Capture/Compare 4 DMA request */
;;;861          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;862        }
;;;863        break;
;;;864    
;;;865        default:
;;;866        break;
;;;867      }
;;;868    
;;;869      /* Enable the Output compare channel */
;;;870      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;871    
;;;872      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;873      {
;;;874        /* Enable the main output */
;;;875        __HAL_TIM_MOE_ENABLE(htim);
;;;876      }
;;;877    
;;;878      /* Enable the Peripheral */
;;;879      __HAL_TIM_ENABLE(htim);
;;;880    
;;;881      /* Return function status */
;;;882      return HAL_OK;
;;;883    }
00001c  bd70              POP      {r4-r6,pc}
                  |L54.30|
00001e  2002              MOVS     r0,#2                 ;796
000020  f884003d          STRB     r0,[r4,#0x3d]         ;796
                  |L54.36|
000024  482c              LDR      r0,|L54.216|
000026  492d              LDR      r1,|L54.220|
000028  b135              CBZ      r5,|L54.56|
00002a  2d04              CMP      r5,#4                 ;799
00002c  d013              BEQ      |L54.86|
00002e  2d08              CMP      r5,#8                 ;799
000030  d034              BEQ      |L54.156|
000032  2d0c              CMP      r5,#0xc               ;799
000034  d11e              BNE      |L54.116|
000036  e040              B        |L54.186|
                  |L54.56|
000038  6a62              LDR      r2,[r4,#0x24]         ;804
00003a  6290              STR      r0,[r2,#0x28]         ;807
00003c  6a60              LDR      r0,[r4,#0x24]         ;807
00003e  6301              STR      r1,[r0,#0x30]         ;810
000040  6822              LDR      r2,[r4,#0]            ;810
000042  4631              MOV      r1,r6                 ;810
000044  3234              ADDS     r2,r2,#0x34           ;810
000046  6a60              LDR      r0,[r4,#0x24]         ;810
000048  f7fffffe          BL       HAL_DMA_Start_IT
00004c  6820              LDR      r0,[r4,#0]            ;813
00004e  68c1              LDR      r1,[r0,#0xc]          ;813
000050  f4417100          ORR      r1,r1,#0x200          ;813
000054  e00d              B        |L54.114|
                  |L54.86|
000056  6aa2              LDR      r2,[r4,#0x28]         ;820
000058  6290              STR      r0,[r2,#0x28]         ;823
00005a  6aa0              LDR      r0,[r4,#0x28]         ;823
00005c  6301              STR      r1,[r0,#0x30]         ;826
00005e  6822              LDR      r2,[r4,#0]            ;826
000060  4631              MOV      r1,r6                 ;826
000062  3238              ADDS     r2,r2,#0x38           ;826
000064  6aa0              LDR      r0,[r4,#0x28]         ;826
000066  f7fffffe          BL       HAL_DMA_Start_IT
00006a  6820              LDR      r0,[r4,#0]            ;829
00006c  68c1              LDR      r1,[r0,#0xc]          ;829
00006e  f4416180          ORR      r1,r1,#0x400          ;829
                  |L54.114|
000072  60c1              STR      r1,[r0,#0xc]          ;813
                  |L54.116|
000074  2201              MOVS     r2,#1                 ;870
000076  4629              MOV      r1,r5                 ;870
000078  6820              LDR      r0,[r4,#0]            ;870
00007a  f7fffffe          BL       TIM_CCxChannelCmd
00007e  4918              LDR      r1,|L54.224|
000080  6820              LDR      r0,[r4,#0]            ;872
000082  4288              CMP      r0,r1                 ;872
000084  d103              BNE      |L54.142|
000086  6c41              LDR      r1,[r0,#0x44]         ;875
000088  f4414100          ORR      r1,r1,#0x8000         ;875
00008c  6441              STR      r1,[r0,#0x44]         ;875
                  |L54.142|
00008e  6820              LDR      r0,[r4,#0]            ;879
000090  6801              LDR      r1,[r0,#0]            ;879
000092  f0410101          ORR      r1,r1,#1              ;879
000096  6001              STR      r1,[r0,#0]            ;879
000098  2000              MOVS     r0,#0                 ;882
00009a  bd70              POP      {r4-r6,pc}
                  |L54.156|
00009c  6ae2              LDR      r2,[r4,#0x2c]         ;836
00009e  6290              STR      r0,[r2,#0x28]         ;839
0000a0  6ae0              LDR      r0,[r4,#0x2c]         ;839
0000a2  6301              STR      r1,[r0,#0x30]         ;842
0000a4  6822              LDR      r2,[r4,#0]            ;842
0000a6  4631              MOV      r1,r6                 ;842
0000a8  323c              ADDS     r2,r2,#0x3c           ;842
0000aa  6ae0              LDR      r0,[r4,#0x2c]         ;842
0000ac  f7fffffe          BL       HAL_DMA_Start_IT
0000b0  6820              LDR      r0,[r4,#0]            ;845
0000b2  68c1              LDR      r1,[r0,#0xc]          ;845
0000b4  f4416100          ORR      r1,r1,#0x800          ;845
0000b8  e7db              B        |L54.114|
                  |L54.186|
0000ba  6b22              LDR      r2,[r4,#0x30]         ;852
0000bc  6290              STR      r0,[r2,#0x28]         ;855
0000be  6b20              LDR      r0,[r4,#0x30]         ;855
0000c0  6301              STR      r1,[r0,#0x30]         ;858
0000c2  6822              LDR      r2,[r4,#0]            ;858
0000c4  4631              MOV      r1,r6                 ;858
0000c6  3240              ADDS     r2,r2,#0x40           ;858
0000c8  6b20              LDR      r0,[r4,#0x30]         ;858
0000ca  f7fffffe          BL       HAL_DMA_Start_IT
0000ce  6820              LDR      r0,[r4,#0]            ;861
0000d0  68c1              LDR      r1,[r0,#0xc]          ;861
0000d2  f4415180          ORR      r1,r1,#0x1000         ;861
0000d6  e7cc              B        |L54.114|
;;;884    
                          ENDP

                  |L54.216|
                          DCD      TIM_DMADelayPulseCplt
                  |L54.220|
                          DCD      TIM_DMAError
                  |L54.224|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_OC_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start_IT PROC
;;;644    */
;;;645    HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;646    {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L55.22|
;;;647      /* Check the parameters */
;;;648      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;649    
;;;650      switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L55.30|
00000c  2908              CMP      r1,#8
00000e  d01d              BEQ      |L55.76|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L55.38|
000014  e01e              B        |L55.84|
                  |L55.22|
;;;651      {
;;;652        case TIM_CHANNEL_1:
;;;653        {
;;;654          /* Enable the TIM Capture/Compare 1 interrupt */
;;;655          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0400002          ORR      r0,r0,#2
;;;656        }
;;;657        break;
00001c  e002              B        |L55.36|
                  |L55.30|
;;;658    
;;;659        case TIM_CHANNEL_2:
;;;660        {
;;;661          /* Enable the TIM Capture/Compare 2 interrupt */
;;;662          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0400004          ORR      r0,r0,#4
                  |L55.36|
000024  60d0              STR      r0,[r2,#0xc]          ;655
                  |L55.38|
;;;663        }
;;;664        break;
;;;665    
;;;666        case TIM_CHANNEL_3:
;;;667        {
;;;668          /* Enable the TIM Capture/Compare 3 interrupt */
;;;669          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
;;;670        }
;;;671        break;
;;;672    
;;;673        case TIM_CHANNEL_4:
;;;674        {
;;;675          /* Enable the TIM Capture/Compare 4 interrupt */
;;;676          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
;;;677        }
;;;678        break;
;;;679    
;;;680        default:
;;;681        break;
;;;682      }
;;;683    
;;;684      /* Enable the Output compare channel */
;;;685      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000026  2201              MOVS     r2,#1
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;686    
;;;687      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00002e  490b              LDR      r1,|L55.92|
000030  6820              LDR      r0,[r4,#0]
000032  4288              CMP      r0,r1
000034  d103              BNE      |L55.62|
;;;688      {
;;;689        /* Enable the main output */
;;;690        __HAL_TIM_MOE_ENABLE(htim);
000036  6c41              LDR      r1,[r0,#0x44]
000038  f4414100          ORR      r1,r1,#0x8000
00003c  6441              STR      r1,[r0,#0x44]
                  |L55.62|
;;;691      }
;;;692    
;;;693      /* Enable the Peripheral */
;;;694      __HAL_TIM_ENABLE(htim);
00003e  6820              LDR      r0,[r4,#0]
000040  6801              LDR      r1,[r0,#0]
000042  f0410101          ORR      r1,r1,#1
000046  6001              STR      r1,[r0,#0]
;;;695    
;;;696      /* Return function status */
;;;697      return HAL_OK;
000048  2000              MOVS     r0,#0
;;;698    }
00004a  bd10              POP      {r4,pc}
                  |L55.76|
00004c  68d0              LDR      r0,[r2,#0xc]          ;669
00004e  f0400008          ORR      r0,r0,#8              ;669
000052  e7e7              B        |L55.36|
                  |L55.84|
000054  68d0              LDR      r0,[r2,#0xc]          ;676
000056  f0400010          ORR      r0,r0,#0x10           ;676
00005a  e7e3              B        |L55.36|
;;;699    
                          ENDP

                  |L55.92|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_OC_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop PROC
;;;612    */
;;;613    HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;614    {
000002  4604              MOV      r4,r0
;;;615      /* Check the parameters */
;;;616      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;617    
;;;618      /* Disable the Output compare channel */
;;;619      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2200              MOVS     r2,#0
000008  f7fffffe          BL       TIM_CCxChannelCmd
;;;620    
;;;621      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00000c  480e              LDR      r0,|L56.72|
;;;622      {
;;;623        /* Disable the Main Ouput */
;;;624        __HAL_TIM_MOE_DISABLE(htim);
00000e  f2411211          MOV      r2,#0x1111
000012  6821              LDR      r1,[r4,#0]            ;621
000014  1093              ASRS     r3,r2,#2
000016  4281              CMP      r1,r0                 ;621
000018  d109              BNE      |L56.46|
00001a  6a08              LDR      r0,[r1,#0x20]
00001c  4210              TST      r0,r2
00001e  d106              BNE      |L56.46|
000020  6a08              LDR      r0,[r1,#0x20]
000022  4218              TST      r0,r3
000024  d103              BNE      |L56.46|
000026  6c48              LDR      r0,[r1,#0x44]
000028  f4204000          BIC      r0,r0,#0x8000
00002c  6448              STR      r0,[r1,#0x44]
                  |L56.46|
;;;625      }
;;;626    
;;;627      /* Disable the Peripheral */
;;;628      __HAL_TIM_DISABLE(htim);
00002e  6820              LDR      r0,[r4,#0]
000030  6a01              LDR      r1,[r0,#0x20]
000032  4211              TST      r1,r2
000034  d106              BNE      |L56.68|
000036  6a01              LDR      r1,[r0,#0x20]
000038  4219              TST      r1,r3
00003a  d103              BNE      |L56.68|
00003c  6801              LDR      r1,[r0,#0]
00003e  f0210101          BIC      r1,r1,#1
000042  6001              STR      r1,[r0,#0]
                  |L56.68|
;;;629    
;;;630      /* Return function status */
;;;631      return HAL_OK;
000044  2000              MOVS     r0,#0
;;;632    }
000046  bd10              POP      {r4,pc}
;;;633    
                          ENDP

                  |L56.72|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_OC_Stop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop_DMA PROC
;;;895    */
;;;896    HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;897    {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L57.22|
;;;898      /* Check the parameters */
;;;899      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;900    
;;;901      switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L57.30|
00000c  2908              CMP      r1,#8
00000e  d02f              BEQ      |L57.112|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L57.38|
000014  e030              B        |L57.120|
                  |L57.22|
;;;902      {
;;;903        case TIM_CHANNEL_1:
;;;904        {
;;;905          /* Disable the TIM Capture/Compare 1 DMA request */
;;;906          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f4207000          BIC      r0,r0,#0x200
;;;907        }
;;;908        break;
00001c  e002              B        |L57.36|
                  |L57.30|
;;;909    
;;;910        case TIM_CHANNEL_2:
;;;911        {
;;;912          /* Disable the TIM Capture/Compare 2 DMA request */
;;;913          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f4206080          BIC      r0,r0,#0x400
                  |L57.36|
000024  60d0              STR      r0,[r2,#0xc]          ;906
                  |L57.38|
;;;914        }
;;;915        break;
;;;916    
;;;917        case TIM_CHANNEL_3:
;;;918        {
;;;919          /* Disable the TIM Capture/Compare 3 DMA request */
;;;920          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
;;;921        }
;;;922        break;
;;;923    
;;;924        case TIM_CHANNEL_4:
;;;925        {
;;;926          /* Disable the TIM Capture/Compare 4 interrupt */
;;;927          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
;;;928        }
;;;929        break;
;;;930    
;;;931        default:
;;;932        break;
;;;933      }
;;;934    
;;;935      /* Disable the Output compare channel */
;;;936      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000026  2200              MOVS     r2,#0
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;937    
;;;938      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00002e  4b14              LDR      r3,|L57.128|
;;;939      {
;;;940        /* Disable the Main Ouput */
;;;941        __HAL_TIM_MOE_DISABLE(htim);
000030  f2411111          MOV      r1,#0x1111
000034  6820              LDR      r0,[r4,#0]            ;938
000036  108a              ASRS     r2,r1,#2
000038  4298              CMP      r0,r3                 ;938
00003a  d109              BNE      |L57.80|
00003c  6a03              LDR      r3,[r0,#0x20]
00003e  420b              TST      r3,r1
000040  d106              BNE      |L57.80|
000042  6a03              LDR      r3,[r0,#0x20]
000044  4213              TST      r3,r2
000046  d103              BNE      |L57.80|
000048  6c43              LDR      r3,[r0,#0x44]
00004a  f4234300          BIC      r3,r3,#0x8000
00004e  6443              STR      r3,[r0,#0x44]
                  |L57.80|
;;;942      }
;;;943    
;;;944      /* Disable the Peripheral */
;;;945      __HAL_TIM_DISABLE(htim);
000050  6820              LDR      r0,[r4,#0]
000052  6a03              LDR      r3,[r0,#0x20]
000054  420b              TST      r3,r1
000056  d106              BNE      |L57.102|
000058  6a01              LDR      r1,[r0,#0x20]
00005a  4211              TST      r1,r2
00005c  d103              BNE      |L57.102|
00005e  6801              LDR      r1,[r0,#0]
000060  f0210101          BIC      r1,r1,#1
000064  6001              STR      r1,[r0,#0]
                  |L57.102|
;;;946    
;;;947      /* Change the htim state */
;;;948      htim->State = HAL_TIM_STATE_READY;
000066  2001              MOVS     r0,#1
000068  f884003d          STRB     r0,[r4,#0x3d]
;;;949    
;;;950      /* Return function status */
;;;951      return HAL_OK;
00006c  2000              MOVS     r0,#0
;;;952    }
00006e  bd10              POP      {r4,pc}
                  |L57.112|
000070  68d0              LDR      r0,[r2,#0xc]          ;920
000072  f4206000          BIC      r0,r0,#0x800          ;920
000076  e7d5              B        |L57.36|
                  |L57.120|
000078  68d0              LDR      r0,[r2,#0xc]          ;927
00007a  f4205080          BIC      r0,r0,#0x1000         ;927
00007e  e7d1              B        |L57.36|
;;;953    
                          ENDP

                  |L57.128|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_OC_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop_IT PROC
;;;710    */
;;;711    HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;712    {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L58.22|
;;;713      /* Check the parameters */
;;;714      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;715    
;;;716      switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L58.30|
00000c  2908              CMP      r1,#8
00000e  d02c              BEQ      |L58.106|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L58.38|
000014  e02d              B        |L58.114|
                  |L58.22|
;;;717      {
;;;718        case TIM_CHANNEL_1:
;;;719        {
;;;720          /* Disable the TIM Capture/Compare 1 interrupt */
;;;721          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0200002          BIC      r0,r0,#2
;;;722        }
;;;723        break;
00001c  e002              B        |L58.36|
                  |L58.30|
;;;724    
;;;725        case TIM_CHANNEL_2:
;;;726        {
;;;727          /* Disable the TIM Capture/Compare 2 interrupt */
;;;728          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0200004          BIC      r0,r0,#4
                  |L58.36|
000024  60d0              STR      r0,[r2,#0xc]          ;721
                  |L58.38|
;;;729        }
;;;730        break;
;;;731    
;;;732        case TIM_CHANNEL_3:
;;;733        {
;;;734          /* Disable the TIM Capture/Compare 3 interrupt */
;;;735          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
;;;736        }
;;;737        break;
;;;738    
;;;739        case TIM_CHANNEL_4:
;;;740        {
;;;741          /* Disable the TIM Capture/Compare 4 interrupt */
;;;742          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
;;;743        }
;;;744        break;
;;;745    
;;;746        default:
;;;747        break;
;;;748      }
;;;749    
;;;750      /* Disable the Output compare channel */
;;;751      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000026  2200              MOVS     r2,#0
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;752    
;;;753      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00002e  4b13              LDR      r3,|L58.124|
;;;754      {
;;;755        /* Disable the Main Ouput */
;;;756        __HAL_TIM_MOE_DISABLE(htim);
000030  f2411211          MOV      r2,#0x1111
000034  6820              LDR      r0,[r4,#0]            ;753
000036  1091              ASRS     r1,r2,#2
000038  4298              CMP      r0,r3                 ;753
00003a  d109              BNE      |L58.80|
00003c  6a03              LDR      r3,[r0,#0x20]
00003e  4213              TST      r3,r2
000040  d106              BNE      |L58.80|
000042  6a03              LDR      r3,[r0,#0x20]
000044  420b              TST      r3,r1
000046  d103              BNE      |L58.80|
000048  6c43              LDR      r3,[r0,#0x44]
00004a  f4234300          BIC      r3,r3,#0x8000
00004e  6443              STR      r3,[r0,#0x44]
                  |L58.80|
;;;757      }
;;;758    
;;;759      /* Disable the Peripheral */
;;;760      __HAL_TIM_DISABLE(htim);
000050  6820              LDR      r0,[r4,#0]
000052  6a03              LDR      r3,[r0,#0x20]
000054  4213              TST      r3,r2
000056  d106              BNE      |L58.102|
000058  6a02              LDR      r2,[r0,#0x20]
00005a  420a              TST      r2,r1
00005c  d103              BNE      |L58.102|
00005e  6801              LDR      r1,[r0,#0]
000060  f0210101          BIC      r1,r1,#1
000064  6001              STR      r1,[r0,#0]
                  |L58.102|
;;;761    
;;;762      /* Return function status */
;;;763      return HAL_OK;
000066  2000              MOVS     r0,#0
;;;764    }
000068  bd10              POP      {r4,pc}
                  |L58.106|
00006a  68d0              LDR      r0,[r2,#0xc]          ;735
00006c  f0200008          BIC      r0,r0,#8              ;735
000070  e7d8              B        |L58.36|
                  |L58.114|
000072  68d0              LDR      r0,[r2,#0xc]          ;742
000074  f0200010          BIC      r0,r0,#0x10           ;742
000078  e7d4              B        |L58.36|
;;;765    
                          ENDP

00007a  0000              DCW      0x0000
                  |L58.124|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_OnePulse_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_ConfigChannel PROC
;;;3197     */
;;;3198   HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef* sConfig, uint32_t OutputChannel,  uint32_t InputChannel)
000000  b5f0              PUSH     {r4-r7,lr}
;;;3199   {
000002  461e              MOV      r6,r3
000004  b087              SUB      sp,sp,#0x1c
000006  460d              MOV      r5,r1
000008  4604              MOV      r4,r0
;;;3200     TIM_OC_InitTypeDef temp1;
;;;3201   
;;;3202     /* Check the parameters */
;;;3203     assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
;;;3204     assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
;;;3205   
;;;3206     if(OutputChannel != InputChannel)
00000a  42b2              CMP      r2,r6
00000c  d063              BEQ      |L59.214|
;;;3207     {
;;;3208     __HAL_LOCK(htim);
00000e  f894003c          LDRB     r0,[r4,#0x3c]
000012  2801              CMP      r0,#1
000014  d015              BEQ      |L59.66|
000016  2701              MOVS     r7,#1
000018  f884703c          STRB     r7,[r4,#0x3c]
;;;3209   
;;;3210     htim->State = HAL_TIM_STATE_BUSY;
00001c  2002              MOVS     r0,#2
00001e  f884003d          STRB     r0,[r4,#0x3d]
;;;3211   
;;;3212     /* Extract the Ouput compare configuration from sConfig structure */
;;;3213     temp1.OCMode = sConfig->OCMode;
000022  6828              LDR      r0,[r5,#0]
;;;3214     temp1.Pulse = sConfig->Pulse;
000024  9000              STR      r0,[sp,#0]
000026  6868              LDR      r0,[r5,#4]
;;;3215     temp1.OCPolarity = sConfig->OCPolarity;
000028  9001              STR      r0,[sp,#4]
00002a  68a8              LDR      r0,[r5,#8]
;;;3216     temp1.OCNPolarity = sConfig->OCNPolarity;
00002c  9002              STR      r0,[sp,#8]
00002e  68e8              LDR      r0,[r5,#0xc]
;;;3217     temp1.OCIdleState = sConfig->OCIdleState;
000030  9003              STR      r0,[sp,#0xc]
000032  6928              LDR      r0,[r5,#0x10]
;;;3218     temp1.OCNIdleState = sConfig->OCNIdleState;
000034  9005              STR      r0,[sp,#0x14]
000036  6968              LDR      r0,[r5,#0x14]
000038  9006              STR      r0,[sp,#0x18]         ;3208
00003a  b12a              CBZ      r2,|L59.72|
;;;3219   
;;;3220       switch (OutputChannel)
00003c  2a04              CMP      r2,#4
00003e  d10c              BNE      |L59.90|
000040  e007              B        |L59.82|
                  |L59.66|
000042  2002              MOVS     r0,#2                 ;3208
                  |L59.68|
;;;3221     {
;;;3222       case TIM_CHANNEL_1:
;;;3223       {
;;;3224           assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3225   
;;;3226         TIM_OC1_SetConfig(htim->Instance, &temp1);
;;;3227       }
;;;3228       break;
;;;3229       case TIM_CHANNEL_2:
;;;3230       {
;;;3231           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3232   
;;;3233         TIM_OC2_SetConfig(htim->Instance, &temp1);
;;;3234       }
;;;3235       break;
;;;3236       default:
;;;3237       break;
;;;3238     }
;;;3239     switch (InputChannel)
;;;3240     {
;;;3241       case TIM_CHANNEL_1:
;;;3242       {
;;;3243         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3244   
;;;3245         TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;3246                           sConfig->ICSelection, sConfig->ICFilter);
;;;3247   
;;;3248         /* Reset the IC1PSC Bits */
;;;3249       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;3250   
;;;3251         /* Select the Trigger source */
;;;3252           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;3253         htim->Instance->SMCR |= TIM_TS_TI1FP1;
;;;3254   
;;;3255         /* Select the Slave Mode */
;;;3256           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3257         htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;3258       }
;;;3259       break;
;;;3260       case TIM_CHANNEL_2:
;;;3261       {
;;;3262         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3263   
;;;3264         TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;3265                    sConfig->ICSelection, sConfig->ICFilter);
;;;3266   
;;;3267         /* Reset the IC2PSC Bits */
;;;3268           htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;3269   
;;;3270         /* Select the Trigger source */
;;;3271           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;3272         htim->Instance->SMCR |= TIM_TS_TI2FP2;
;;;3273   
;;;3274         /* Select the Slave Mode */
;;;3275           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3276         htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;3277       }
;;;3278       break;
;;;3279   
;;;3280       default:
;;;3281       break;
;;;3282     }
;;;3283   
;;;3284     htim->State = HAL_TIM_STATE_READY;
;;;3285   
;;;3286     __HAL_UNLOCK(htim);
;;;3287   
;;;3288     return HAL_OK;
;;;3289   }
;;;3290     else
;;;3291     {
;;;3292       return HAL_ERROR;
;;;3293     }
;;;3294   }
000044  b007              ADD      sp,sp,#0x1c
000046  bdf0              POP      {r4-r7,pc}
                  |L59.72|
000048  4669              MOV      r1,sp                 ;3226
00004a  6820              LDR      r0,[r4,#0]            ;3226
00004c  f7fffffe          BL       TIM_OC1_SetConfig
000050  e003              B        |L59.90|
                  |L59.82|
000052  4669              MOV      r1,sp                 ;3233
000054  6820              LDR      r0,[r4,#0]            ;3233
000056  f7fffffe          BL       TIM_OC2_SetConfig
                  |L59.90|
00005a  b116              CBZ      r6,|L59.98|
00005c  2e04              CMP      r6,#4                 ;3239
00005e  d134              BNE      |L59.202|
000060  e014              B        |L59.140|
                  |L59.98|
000062  3518              ADDS     r5,r5,#0x18           ;3239
000064  6820              LDR      r0,[r4,#0]            ;3245
000066  e895000e          LDM      r5,{r1-r3}            ;3239
00006a  f7fffffe          BL       TIM_TI1_SetConfig
00006e  6820              LDR      r0,[r4,#0]            ;3249
000070  6981              LDR      r1,[r0,#0x18]         ;3249
000072  f021010c          BIC      r1,r1,#0xc            ;3249
000076  6181              STR      r1,[r0,#0x18]         ;3249
000078  6820              LDR      r0,[r4,#0]            ;3252
00007a  6881              LDR      r1,[r0,#8]            ;3252
00007c  f0210170          BIC      r1,r1,#0x70           ;3252
000080  6081              STR      r1,[r0,#8]            ;3252
000082  6820              LDR      r0,[r4,#0]            ;3253
000084  6881              LDR      r1,[r0,#8]            ;3253
000086  f0410150          ORR      r1,r1,#0x50           ;3253
00008a  e013              B        |L59.180|
                  |L59.140|
00008c  3518              ADDS     r5,r5,#0x18           ;3259
00008e  6820              LDR      r0,[r4,#0]            ;3264
000090  e895000e          LDM      r5,{r1-r3}            ;3259
000094  f7fffffe          BL       TIM_TI2_SetConfig
000098  6820              LDR      r0,[r4,#0]            ;3268
00009a  6981              LDR      r1,[r0,#0x18]         ;3268
00009c  f4216140          BIC      r1,r1,#0xc00          ;3268
0000a0  6181              STR      r1,[r0,#0x18]         ;3268
0000a2  6820              LDR      r0,[r4,#0]            ;3271
0000a4  6881              LDR      r1,[r0,#8]            ;3271
0000a6  f0210170          BIC      r1,r1,#0x70           ;3271
0000aa  6081              STR      r1,[r0,#8]            ;3271
0000ac  6820              LDR      r0,[r4,#0]            ;3272
0000ae  6881              LDR      r1,[r0,#8]            ;3272
0000b0  f0410160          ORR      r1,r1,#0x60           ;3272
                  |L59.180|
0000b4  6081              STR      r1,[r0,#8]            ;3253
0000b6  6820              LDR      r0,[r4,#0]            ;3256
0000b8  6881              LDR      r1,[r0,#8]            ;3256
0000ba  f0210107          BIC      r1,r1,#7              ;3256
0000be  6081              STR      r1,[r0,#8]            ;3256
0000c0  6820              LDR      r0,[r4,#0]            ;3257
0000c2  6881              LDR      r1,[r0,#8]            ;3257
0000c4  f0410106          ORR      r1,r1,#6              ;3257
0000c8  6081              STR      r1,[r0,#8]            ;3257
                  |L59.202|
0000ca  f884703d          STRB     r7,[r4,#0x3d]         ;3284
0000ce  2000              MOVS     r0,#0                 ;3286
0000d0  f884003c          STRB     r0,[r4,#0x3c]         ;3286
0000d4  e7b6              B        |L59.68|
                  |L59.214|
0000d6  2001              MOVS     r0,#1                 ;3292
0000d8  e7b4              B        |L59.68|
;;;3295   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_DeInit PROC
;;;2013     */
;;;2014   HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;2015   {
000002  4604              MOV      r4,r0
;;;2016     /* Check the parameters */
;;;2017     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2018   
;;;2019     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f884003d          STRB     r0,[r4,#0x3d]
;;;2020   
;;;2021     /* Disable the TIM Peripheral Clock */
;;;2022     __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L60.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L60.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L60.38|
;;;2023   
;;;2024     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;2025     HAL_TIM_OnePulse_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_OnePulse_MspDeInit
;;;2026   
;;;2027     /* Change TIM state */
;;;2028     htim->State = HAL_TIM_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  f884003d          STRB     r0,[r4,#0x3d]
;;;2029   
;;;2030     /* Release Lock */
;;;2031     __HAL_UNLOCK(htim);
000032  f884003c          STRB     r0,[r4,#0x3c]
;;;2032   
;;;2033     return HAL_OK;
;;;2034   }
000036  bd10              POP      {r4,pc}
;;;2035   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_GetState PROC
;;;4426     */
;;;4427   HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
000000  f890003d          LDRB     r0,[r0,#0x3d]
;;;4428   {
;;;4429     return htim->State;
;;;4430   }
000004  4770              BX       lr
;;;4431   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_Init PROC
;;;1966     */
;;;1967   HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
000000  b570              PUSH     {r4-r6,lr}
;;;1968   {
000002  460d              MOV      r5,r1
000004  0004              MOVS     r4,r0
000006  d003              BEQ      |L62.16|
;;;1969     /* Check the TIM handle allocation */
;;;1970     if(htim == NULL)
;;;1971     {
;;;1972       return HAL_ERROR;
;;;1973     }
;;;1974   
;;;1975     /* Check the parameters */
;;;1976     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1977     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1978     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;1979     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;1980     assert_param(IS_TIM_OPM_MODE(OnePulseMode));
;;;1981   
;;;1982     if(htim->State == HAL_TIM_STATE_RESET)
000008  f894003d          LDRB     r0,[r4,#0x3d]
00000c  b110              CBZ      r0,|L62.20|
00000e  e007              B        |L62.32|
                  |L62.16|
000010  2001              MOVS     r0,#1                 ;1972
;;;1983     {
;;;1984       /* Allocate lock resource and initialize it */
;;;1985       htim->Lock = HAL_UNLOCKED;
;;;1986       
;;;1987       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1988       HAL_TIM_OnePulse_MspInit(htim);
;;;1989     }
;;;1990   
;;;1991     /* Set the TIM state */
;;;1992     htim->State= HAL_TIM_STATE_BUSY;
;;;1993   
;;;1994     /* Configure the Time base in the One Pulse Mode */
;;;1995     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;1996   
;;;1997     /* Reset the OPM Bit */
;;;1998     htim->Instance->CR1 &= ~TIM_CR1_OPM;
;;;1999   
;;;2000     /* Configure the OPM Mode */
;;;2001     htim->Instance->CR1 |= OnePulseMode;
;;;2002   
;;;2003     /* Initialize the TIM state*/
;;;2004     htim->State= HAL_TIM_STATE_READY;
;;;2005   
;;;2006     return HAL_OK;
;;;2007   }
000012  bd70              POP      {r4-r6,pc}
                  |L62.20|
000014  2000              MOVS     r0,#0                 ;1985
000016  f884003c          STRB     r0,[r4,#0x3c]         ;1985
00001a  4620              MOV      r0,r4                 ;1988
00001c  f7fffffe          BL       HAL_TIM_OnePulse_MspInit
                  |L62.32|
000020  2002              MOVS     r0,#2                 ;1992
000022  f884003d          STRB     r0,[r4,#0x3d]         ;1992
000026  1d21              ADDS     r1,r4,#4              ;1995
000028  6820              LDR      r0,[r4,#0]            ;1995
00002a  f7fffffe          BL       TIM_Base_SetConfig
00002e  6820              LDR      r0,[r4,#0]            ;1998
000030  6801              LDR      r1,[r0,#0]            ;1998
000032  f0210108          BIC      r1,r1,#8              ;1998
000036  6001              STR      r1,[r0,#0]            ;1998
000038  6820              LDR      r0,[r4,#0]            ;2001
00003a  6801              LDR      r1,[r0,#0]            ;2001
00003c  4329              ORRS     r1,r1,r5              ;2001
00003e  6001              STR      r1,[r0,#0]            ;2001
000040  2001              MOVS     r0,#1                 ;2004
000042  f884003d          STRB     r0,[r4,#0x3d]         ;2004
000046  2000              MOVS     r0,#0                 ;2006
000048  bd70              POP      {r4-r6,pc}
;;;2008   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_MspDeInit PROC
;;;2054     */
;;;2055   __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2056   {
;;;2057     /* Prevent unused argument(s) compilation warning */
;;;2058     UNUSED(htim);
;;;2059     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2060               the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
;;;2061      */
;;;2062   }
;;;2063   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_MspInit PROC
;;;2040     */
;;;2041   __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2042   {
;;;2043     /* Prevent unused argument(s) compilation warning */
;;;2044     UNUSED(htim);
;;;2045     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2046               the HAL_TIM_OnePulse_MspInit could be implemented in the user file
;;;2047      */
;;;2048   }
;;;2049   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Start PROC
;;;2072   */
;;;2073   HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;2074   {
000002  4604              MOV      r4,r0
;;;2075     /* Prevent unused argument(s) compilation warning */
;;;2076     UNUSED(OutputChannel);
;;;2077   
;;;2078     /* Enable the Capture compare and the Input Capture channels 
;;;2079       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2080       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2081       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2082       in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
;;;2083   
;;;2084       No need to enable the counter, it's enabled automatically by hardware 
;;;2085       (the counter starts in response to a stimulus and generate a pulse */
;;;2086   
;;;2087     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2201              MOVS     r2,#1
000008  2100              MOVS     r1,#0
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;2088     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
00000e  2201              MOVS     r2,#1
000010  2104              MOVS     r1,#4
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       TIM_CCxChannelCmd
;;;2089   
;;;2090     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000018  4904              LDR      r1,|L65.44|
00001a  6820              LDR      r0,[r4,#0]
00001c  4288              CMP      r0,r1
00001e  d103              BNE      |L65.40|
;;;2091     {
;;;2092       /* Enable the main output */
;;;2093       __HAL_TIM_MOE_ENABLE(htim);
000020  6c41              LDR      r1,[r0,#0x44]
000022  f4414100          ORR      r1,r1,#0x8000
000026  6441              STR      r1,[r0,#0x44]
                  |L65.40|
;;;2094     }
;;;2095   
;;;2096     /* Return function status */
;;;2097     return HAL_OK;
000028  2000              MOVS     r0,#0
;;;2098   }
00002a  bd10              POP      {r4,pc}
;;;2099   
                          ENDP

                  |L65.44|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_OnePulse_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Start_IT PROC
;;;2144   */
;;;2145   HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;2146   {
000002  4604              MOV      r4,r0
;;;2147     /* Prevent unused argument(s) compilation warning */
;;;2148     UNUSED(OutputChannel);
;;;2149   
;;;2150     /* Enable the Capture compare and the Input Capture channels 
;;;2151       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2152       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2153       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2154       in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
;;;2155   
;;;2156       No need to enable the counter, it's enabled automatically by hardware 
;;;2157       (the counter starts in response to a stimulus and generate a pulse */
;;;2158   
;;;2159     /* Enable the TIM Capture/Compare 1 interrupt */
;;;2160     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000004  6800              LDR      r0,[r0,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f0410102          ORR      r1,r1,#2
00000c  60c1              STR      r1,[r0,#0xc]
;;;2161   
;;;2162     /* Enable the TIM Capture/Compare 2 interrupt */
;;;2163     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00000e  6820              LDR      r0,[r4,#0]
000010  68c1              LDR      r1,[r0,#0xc]
000012  f0410104          ORR      r1,r1,#4
000016  60c1              STR      r1,[r0,#0xc]
;;;2164   
;;;2165     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000018  2201              MOVS     r2,#1
00001a  2100              MOVS     r1,#0
00001c  6820              LDR      r0,[r4,#0]
00001e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2166     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000022  2201              MOVS     r2,#1
000024  2104              MOVS     r1,#4
000026  6820              LDR      r0,[r4,#0]
000028  f7fffffe          BL       TIM_CCxChannelCmd
;;;2167   
;;;2168     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00002c  4904              LDR      r1,|L66.64|
00002e  6820              LDR      r0,[r4,#0]
000030  4288              CMP      r0,r1
000032  d103              BNE      |L66.60|
;;;2169     {
;;;2170       /* Enable the main output */
;;;2171       __HAL_TIM_MOE_ENABLE(htim);
000034  6c41              LDR      r1,[r0,#0x44]
000036  f4414100          ORR      r1,r1,#0x8000
00003a  6441              STR      r1,[r0,#0x44]
                  |L66.60|
;;;2172     }
;;;2173   
;;;2174     /* Return function status */
;;;2175     return HAL_OK;
00003c  2000              MOVS     r0,#0
;;;2176   }
00003e  bd10              POP      {r4,pc}
;;;2177   
                          ENDP

                  |L66.64|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_OnePulse_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Stop PROC
;;;2108   */
;;;2109   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;2110   {
000002  4604              MOV      r4,r0
;;;2111     /* Prevent unused argument(s) compilation warning */
;;;2112     UNUSED(OutputChannel);
;;;2113   
;;;2114     /* Disable the Capture compare and the Input Capture channels
;;;2115     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2116     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2117     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2118     in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
;;;2119   
;;;2120     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000004  2200              MOVS     r2,#0
000006  6800              LDR      r0,[r0,#0]
000008  4611              MOV      r1,r2
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;2121     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
00000e  2200              MOVS     r2,#0
000010  2104              MOVS     r1,#4
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       TIM_CCxChannelCmd
;;;2122   
;;;2123     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000018  4b0e              LDR      r3,|L67.84|
;;;2124     {
;;;2125       /* Disable the Main Ouput */
;;;2126       __HAL_TIM_MOE_DISABLE(htim);
00001a  f2411111          MOV      r1,#0x1111
00001e  6820              LDR      r0,[r4,#0]            ;2123
000020  108a              ASRS     r2,r1,#2
000022  4298              CMP      r0,r3                 ;2123
000024  d109              BNE      |L67.58|
000026  6a03              LDR      r3,[r0,#0x20]
000028  420b              TST      r3,r1
00002a  d106              BNE      |L67.58|
00002c  6a03              LDR      r3,[r0,#0x20]
00002e  4213              TST      r3,r2
000030  d103              BNE      |L67.58|
000032  6c43              LDR      r3,[r0,#0x44]
000034  f4234300          BIC      r3,r3,#0x8000
000038  6443              STR      r3,[r0,#0x44]
                  |L67.58|
;;;2127     }
;;;2128   
;;;2129     /* Disable the Peripheral */
;;;2130     __HAL_TIM_DISABLE(htim);
00003a  6820              LDR      r0,[r4,#0]
00003c  6a03              LDR      r3,[r0,#0x20]
00003e  420b              TST      r3,r1
000040  d106              BNE      |L67.80|
000042  6a01              LDR      r1,[r0,#0x20]
000044  4211              TST      r1,r2
000046  d103              BNE      |L67.80|
000048  6801              LDR      r1,[r0,#0]
00004a  f0210101          BIC      r1,r1,#1
00004e  6001              STR      r1,[r0,#0]
                  |L67.80|
;;;2131   
;;;2132     /* Return function status */
;;;2133     return HAL_OK;
000050  2000              MOVS     r0,#0
;;;2134   }
000052  bd10              POP      {r4,pc}
;;;2135   
                          ENDP

                  |L67.84|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_OnePulse_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Stop_IT PROC
;;;2186   */
;;;2187   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;2188   {
000002  4604              MOV      r4,r0
;;;2189     /* Prevent unused argument(s) compilation warning */
;;;2190     UNUSED(OutputChannel);
;;;2191   
;;;2192     /* Disable the TIM Capture/Compare 1 interrupt */
;;;2193     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000004  6800              LDR      r0,[r0,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f0210102          BIC      r1,r1,#2
00000c  60c1              STR      r1,[r0,#0xc]
;;;2194   
;;;2195     /* Disable the TIM Capture/Compare 2 interrupt */
;;;2196     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00000e  6820              LDR      r0,[r4,#0]
000010  68c1              LDR      r1,[r0,#0xc]
000012  f0210104          BIC      r1,r1,#4
000016  60c1              STR      r1,[r0,#0xc]
;;;2197   
;;;2198     /* Disable the Capture compare and the Input Capture channels 
;;;2199     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2200     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2201     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2202     in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
;;;2203     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000018  2200              MOVS     r2,#0
00001a  4611              MOV      r1,r2
00001c  6820              LDR      r0,[r4,#0]
00001e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2204     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000022  2200              MOVS     r2,#0
000024  2104              MOVS     r1,#4
000026  6820              LDR      r0,[r4,#0]
000028  f7fffffe          BL       TIM_CCxChannelCmd
;;;2205   
;;;2206     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00002c  4b0e              LDR      r3,|L68.104|
;;;2207     {
;;;2208       /* Disable the Main Ouput */
;;;2209       __HAL_TIM_MOE_DISABLE(htim);
00002e  f2411111          MOV      r1,#0x1111
000032  6820              LDR      r0,[r4,#0]            ;2206
000034  108a              ASRS     r2,r1,#2
000036  4298              CMP      r0,r3                 ;2206
000038  d109              BNE      |L68.78|
00003a  6a03              LDR      r3,[r0,#0x20]
00003c  420b              TST      r3,r1
00003e  d106              BNE      |L68.78|
000040  6a03              LDR      r3,[r0,#0x20]
000042  4213              TST      r3,r2
000044  d103              BNE      |L68.78|
000046  6c43              LDR      r3,[r0,#0x44]
000048  f4234300          BIC      r3,r3,#0x8000
00004c  6443              STR      r3,[r0,#0x44]
                  |L68.78|
;;;2210     }
;;;2211   
;;;2212     /* Disable the Peripheral */
;;;2213      __HAL_TIM_DISABLE(htim);
00004e  6820              LDR      r0,[r4,#0]
000050  6a03              LDR      r3,[r0,#0x20]
000052  420b              TST      r3,r1
000054  d106              BNE      |L68.100|
000056  6a01              LDR      r1,[r0,#0x20]
000058  4211              TST      r1,r2
00005a  d103              BNE      |L68.100|
00005c  6801              LDR      r1,[r0,#0]
00005e  f0210101          BIC      r1,r1,#1
000062  6001              STR      r1,[r0,#0]
                  |L68.100|
;;;2214   
;;;2215     /* Return function status */
;;;2216     return HAL_OK;
000064  2000              MOVS     r0,#0
;;;2217   }
000066  bd10              POP      {r4,pc}
;;;2218   
                          ENDP

                  |L68.104|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_PWM_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_ConfigChannel PROC
;;;3097     */
;;;3098   HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;3099   {
000002  4604              MOV      r4,r0
;;;3100     __HAL_LOCK(htim);
000004  f890003c          LDRB     r0,[r0,#0x3c]
000008  460d              MOV      r5,r1                 ;3099
00000a  2801              CMP      r0,#1
00000c  d00d              BEQ      |L69.42|
00000e  2601              MOVS     r6,#1
000010  f884603c          STRB     r6,[r4,#0x3c]
;;;3101   
;;;3102     /* Check the parameters */
;;;3103     assert_param(IS_TIM_CHANNELS(Channel));
;;;3104     assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
;;;3105     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;3106     assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
;;;3107   
;;;3108     htim->State = HAL_TIM_STATE_BUSY;
000014  2002              MOVS     r0,#2
000016  f884003d          STRB     r0,[r4,#0x3d]
00001a  b142              CBZ      r2,|L69.46|
;;;3109   
;;;3110     switch (Channel)
00001c  2a04              CMP      r2,#4
00001e  d018              BEQ      |L69.82|
000020  2a08              CMP      r2,#8
000022  d02a              BEQ      |L69.122|
000024  2a0c              CMP      r2,#0xc
000026  d14d              BNE      |L69.196|
000028  e039              B        |L69.158|
                  |L69.42|
00002a  2002              MOVS     r0,#2                 ;3100
;;;3111     {
;;;3112       case TIM_CHANNEL_1:
;;;3113       {
;;;3114         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3115         /* Configure the Channel 1 in PWM mode */
;;;3116         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;3117   
;;;3118         /* Set the Preload enable bit for channel1 */
;;;3119         htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
;;;3120   
;;;3121         /* Configure the Output Fast mode */
;;;3122         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
;;;3123         htim->Instance->CCMR1 |= sConfig->OCFastMode;
;;;3124       }
;;;3125       break;
;;;3126   
;;;3127       case TIM_CHANNEL_2:
;;;3128       {
;;;3129         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3130         /* Configure the Channel 2 in PWM mode */
;;;3131         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;3132   
;;;3133         /* Set the Preload enable bit for channel2 */
;;;3134         htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
;;;3135   
;;;3136         /* Configure the Output Fast mode */
;;;3137         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
;;;3138         htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
;;;3139       }
;;;3140       break;
;;;3141   
;;;3142       case TIM_CHANNEL_3:
;;;3143       {
;;;3144         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3145         /* Configure the Channel 3 in PWM mode */
;;;3146         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;3147   
;;;3148         /* Set the Preload enable bit for channel3 */
;;;3149         htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
;;;3150   
;;;3151        /* Configure the Output Fast mode */
;;;3152         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
;;;3153         htim->Instance->CCMR2 |= sConfig->OCFastMode;
;;;3154       }
;;;3155       break;
;;;3156   
;;;3157       case TIM_CHANNEL_4:
;;;3158       {
;;;3159         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3160         /* Configure the Channel 4 in PWM mode */
;;;3161         TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;3162   
;;;3163         /* Set the Preload enable bit for channel4 */
;;;3164         htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
;;;3165   
;;;3166        /* Configure the Output Fast mode */
;;;3167         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
;;;3168         htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;
;;;3169       }
;;;3170       break;
;;;3171   
;;;3172       default:
;;;3173       break;
;;;3174     }
;;;3175   
;;;3176     htim->State = HAL_TIM_STATE_READY;
;;;3177   
;;;3178     __HAL_UNLOCK(htim);
;;;3179   
;;;3180     return HAL_OK;
;;;3181   }
00002c  bd70              POP      {r4-r6,pc}
                  |L69.46|
00002e  6820              LDR      r0,[r4,#0]            ;3116
000030  f7fffffe          BL       TIM_OC1_SetConfig
000034  6820              LDR      r0,[r4,#0]            ;3119
000036  6981              LDR      r1,[r0,#0x18]         ;3119
000038  f0410108          ORR      r1,r1,#8              ;3119
00003c  6181              STR      r1,[r0,#0x18]         ;3119
00003e  6820              LDR      r0,[r4,#0]            ;3122
000040  6981              LDR      r1,[r0,#0x18]         ;3122
000042  f0210104          BIC      r1,r1,#4              ;3122
000046  6181              STR      r1,[r0,#0x18]         ;3122
000048  6820              LDR      r0,[r4,#0]            ;3123
00004a  6981              LDR      r1,[r0,#0x18]         ;3123
00004c  692a              LDR      r2,[r5,#0x10]         ;3123
00004e  4311              ORRS     r1,r1,r2              ;3123
000050  e011              B        |L69.118|
                  |L69.82|
000052  6820              LDR      r0,[r4,#0]            ;3131
000054  f7fffffe          BL       TIM_OC2_SetConfig
000058  6820              LDR      r0,[r4,#0]            ;3134
00005a  6981              LDR      r1,[r0,#0x18]         ;3134
00005c  f4416100          ORR      r1,r1,#0x800          ;3134
000060  6181              STR      r1,[r0,#0x18]         ;3134
000062  6820              LDR      r0,[r4,#0]            ;3137
000064  6981              LDR      r1,[r0,#0x18]         ;3137
000066  f4216180          BIC      r1,r1,#0x400          ;3137
00006a  6181              STR      r1,[r0,#0x18]         ;3137
00006c  6820              LDR      r0,[r4,#0]            ;3138
00006e  6981              LDR      r1,[r0,#0x18]         ;3138
000070  692a              LDR      r2,[r5,#0x10]         ;3138
000072  ea412102          ORR      r1,r1,r2,LSL #8       ;3138
                  |L69.118|
000076  6181              STR      r1,[r0,#0x18]         ;3123
000078  e024              B        |L69.196|
                  |L69.122|
00007a  6820              LDR      r0,[r4,#0]            ;3146
00007c  f7fffffe          BL       TIM_OC3_SetConfig
000080  6820              LDR      r0,[r4,#0]            ;3149
000082  69c1              LDR      r1,[r0,#0x1c]         ;3149
000084  f0410108          ORR      r1,r1,#8              ;3149
000088  61c1              STR      r1,[r0,#0x1c]         ;3149
00008a  6820              LDR      r0,[r4,#0]            ;3152
00008c  69c1              LDR      r1,[r0,#0x1c]         ;3152
00008e  f0210104          BIC      r1,r1,#4              ;3152
000092  61c1              STR      r1,[r0,#0x1c]         ;3152
000094  6820              LDR      r0,[r4,#0]            ;3153
000096  69c1              LDR      r1,[r0,#0x1c]         ;3153
000098  692a              LDR      r2,[r5,#0x10]         ;3153
00009a  4311              ORRS     r1,r1,r2              ;3153
00009c  e011              B        |L69.194|
                  |L69.158|
00009e  6820              LDR      r0,[r4,#0]            ;3161
0000a0  f7fffffe          BL       TIM_OC4_SetConfig
0000a4  6820              LDR      r0,[r4,#0]            ;3164
0000a6  69c1              LDR      r1,[r0,#0x1c]         ;3164
0000a8  f4416100          ORR      r1,r1,#0x800          ;3164
0000ac  61c1              STR      r1,[r0,#0x1c]         ;3164
0000ae  6820              LDR      r0,[r4,#0]            ;3167
0000b0  69c1              LDR      r1,[r0,#0x1c]         ;3167
0000b2  f4216180          BIC      r1,r1,#0x400          ;3167
0000b6  61c1              STR      r1,[r0,#0x1c]         ;3167
0000b8  6820              LDR      r0,[r4,#0]            ;3168
0000ba  69c1              LDR      r1,[r0,#0x1c]         ;3168
0000bc  692a              LDR      r2,[r5,#0x10]         ;3168
0000be  ea412102          ORR      r1,r1,r2,LSL #8       ;3168
                  |L69.194|
0000c2  61c1              STR      r1,[r0,#0x1c]         ;3153
                  |L69.196|
0000c4  f884603d          STRB     r6,[r4,#0x3d]         ;3176
0000c8  2000              MOVS     r0,#0                 ;3178
0000ca  f884003c          STRB     r0,[r4,#0x3c]         ;3178
0000ce  bd70              POP      {r4-r6,pc}
;;;3182   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_DeInit PROC
;;;1024     */
;;;1025   HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1026   {
000002  4604              MOV      r4,r0
;;;1027     /* Check the parameters */
;;;1028     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1029   
;;;1030     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f884003d          STRB     r0,[r4,#0x3d]
;;;1031   
;;;1032     /* Disable the TIM Peripheral Clock */
;;;1033     __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L70.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L70.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L70.38|
;;;1034   
;;;1035     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1036     HAL_TIM_PWM_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_PWM_MspDeInit
;;;1037   
;;;1038     /* Change TIM state */
;;;1039     htim->State = HAL_TIM_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  f884003d          STRB     r0,[r4,#0x3d]
;;;1040   
;;;1041     /* Release Lock */
;;;1042     __HAL_UNLOCK(htim);
000032  f884003c          STRB     r0,[r4,#0x3c]
;;;1043   
;;;1044     return HAL_OK;
;;;1045   }
000036  bd10              POP      {r4,pc}
;;;1046   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_GetState PROC
;;;4406     */
;;;4407   HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
000000  f890003d          LDRB     r0,[r0,#0x3d]
;;;4408   {
;;;4409     return htim->State;
;;;4410   }
000004  4770              BX       lr
;;;4411   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_Init PROC
;;;984      */
;;;985    HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;986    {
000002  0004              MOVS     r4,r0
000004  d003              BEQ      |L72.14|
;;;987      /* Check the TIM handle allocation */
;;;988      if(htim == NULL)
;;;989      {
;;;990        return HAL_ERROR;
;;;991      }
;;;992    
;;;993      /* Check the parameters */
;;;994      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;995      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;996      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;997      assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;998    
;;;999      if(htim->State == HAL_TIM_STATE_RESET)
000006  f894003d          LDRB     r0,[r4,#0x3d]
00000a  b110              CBZ      r0,|L72.18|
00000c  e007              B        |L72.30|
                  |L72.14|
00000e  2001              MOVS     r0,#1                 ;990
;;;1000     {
;;;1001       /* Allocate lock resource and initialize it */
;;;1002       htim->Lock = HAL_UNLOCKED;
;;;1003       
;;;1004       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1005       HAL_TIM_PWM_MspInit(htim);
;;;1006     }
;;;1007   
;;;1008     /* Set the TIM state */
;;;1009     htim->State= HAL_TIM_STATE_BUSY;
;;;1010   
;;;1011     /* Init the base time for the PWM */
;;;1012     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;1013   
;;;1014     /* Initialize the TIM state*/
;;;1015     htim->State= HAL_TIM_STATE_READY;
;;;1016   
;;;1017     return HAL_OK;
;;;1018   }
000010  bd10              POP      {r4,pc}
                  |L72.18|
000012  2000              MOVS     r0,#0                 ;1002
000014  f884003c          STRB     r0,[r4,#0x3c]         ;1002
000018  4620              MOV      r0,r4                 ;1005
00001a  f7fffffe          BL       HAL_TIM_PWM_MspInit
                  |L72.30|
00001e  2002              MOVS     r0,#2                 ;1009
000020  f884003d          STRB     r0,[r4,#0x3d]         ;1009
000024  1d21              ADDS     r1,r4,#4              ;1012
000026  6820              LDR      r0,[r4,#0]            ;1012
000028  f7fffffe          BL       TIM_Base_SetConfig
00002c  2001              MOVS     r0,#1                 ;1015
00002e  f884003d          STRB     r0,[r4,#0x3d]         ;1015
000032  2000              MOVS     r0,#0                 ;1017
000034  bd10              POP      {r4,pc}
;;;1019   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_MspDeInit PROC
;;;1065     */
;;;1066   __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1067   {
;;;1068     /* Prevent unused argument(s) compilation warning */
;;;1069     UNUSED(htim);
;;;1070     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1071               the HAL_TIM_PWM_MspDeInit could be implemented in the user file
;;;1072      */
;;;1073   }
;;;1074   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_MspInit PROC
;;;1051     */
;;;1052   __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1053   {
;;;1054     /* Prevent unused argument(s) compilation warning */
;;;1055     UNUSED(htim);
;;;1056     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1057               the HAL_TIM_PWM_MspInit could be implemented in the user file
;;;1058      */
;;;1059   }
;;;1060   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_PulseFinishedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_PulseFinishedCallback PROC
;;;4325     */
;;;4326   __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4327   {
;;;4328     /* Prevent unused argument(s) compilation warning */
;;;4329     UNUSED(htim);
;;;4330     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4331               the __HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
;;;4332      */
;;;4333   }
;;;4334   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start PROC
;;;1085   */
;;;1086   HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1087   {
000002  4604              MOV      r4,r0
;;;1088     /* Check the parameters */
;;;1089     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1090   
;;;1091     /* Enable the Capture compare channel */
;;;1092     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2201              MOVS     r2,#1
000008  f7fffffe          BL       TIM_CCxChannelCmd
;;;1093   
;;;1094     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00000c  4907              LDR      r1,|L76.44|
00000e  6820              LDR      r0,[r4,#0]
000010  4288              CMP      r0,r1
000012  d103              BNE      |L76.28|
;;;1095     {
;;;1096       /* Enable the main output */
;;;1097       __HAL_TIM_MOE_ENABLE(htim);
000014  6c41              LDR      r1,[r0,#0x44]
000016  f4414100          ORR      r1,r1,#0x8000
00001a  6441              STR      r1,[r0,#0x44]
                  |L76.28|
;;;1098     }
;;;1099   
;;;1100     /* Enable the Peripheral */
;;;1101     __HAL_TIM_ENABLE(htim);
00001c  6820              LDR      r0,[r4,#0]
00001e  6801              LDR      r1,[r0,#0]
000020  f0410101          ORR      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
;;;1102   
;;;1103     /* Return function status */
;;;1104     return HAL_OK;
000026  2000              MOVS     r0,#0
;;;1105   }
000028  bd10              POP      {r4,pc}
;;;1106   
                          ENDP

00002a  0000              DCW      0x0000
                  |L76.44|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_PWM_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start_DMA PROC
;;;1286   */
;;;1287   HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;1288   {
000002  4604              MOV      r4,r0
;;;1289     /* Check the parameters */
;;;1290     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1291   
;;;1292     if((htim->State == HAL_TIM_STATE_BUSY))
000004  f890003d          LDRB     r0,[r0,#0x3d]
000008  4616              MOV      r6,r2                 ;1288
00000a  460d              MOV      r5,r1                 ;1288
00000c  2802              CMP      r0,#2
00000e  d005              BEQ      |L77.28|
;;;1293     {
;;;1294        return HAL_BUSY;
;;;1295     }
;;;1296     else if((htim->State == HAL_TIM_STATE_READY))
000010  f894003d          LDRB     r0,[r4,#0x3d]
000014  2801              CMP      r0,#1
000016  d105              BNE      |L77.36|
;;;1297     {
;;;1298       if(((uint32_t)pData == 0U) && (Length > 0U))
000018  b90e              CBNZ     r6,|L77.30|
00001a  b103              CBZ      r3,|L77.30|
                  |L77.28|
;;;1299       {
;;;1300         return HAL_ERROR;
;;;1301       }
;;;1302       else
;;;1303       {
;;;1304         htim->State = HAL_TIM_STATE_BUSY;
;;;1305       }
;;;1306     }
;;;1307     switch (Channel)
;;;1308     {
;;;1309       case TIM_CHANNEL_1:
;;;1310       {
;;;1311         /* Set the DMA Period elapsed callback */
;;;1312         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1313   
;;;1314         /* Set the DMA error callback */
;;;1315         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;1316   
;;;1317         /* Enable the DMA channel */
;;;1318         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;1319   
;;;1320         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1321         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1322       }
;;;1323       break;
;;;1324   
;;;1325       case TIM_CHANNEL_2:
;;;1326       {
;;;1327         /* Set the DMA Period elapsed callback */
;;;1328         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1329   
;;;1330         /* Set the DMA error callback */
;;;1331         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;1332   
;;;1333         /* Enable the DMA channel */
;;;1334         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;1335   
;;;1336         /* Enable the TIM Capture/Compare 2 DMA request */
;;;1337         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1338       }
;;;1339       break;
;;;1340   
;;;1341       case TIM_CHANNEL_3:
;;;1342       {
;;;1343         /* Set the DMA Period elapsed callback */
;;;1344         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1345   
;;;1346         /* Set the DMA error callback */
;;;1347         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;1348   
;;;1349         /* Enable the DMA channel */
;;;1350         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;1351   
;;;1352         /* Enable the TIM Output Capture/Compare 3 request */
;;;1353         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1354       }
;;;1355       break;
;;;1356   
;;;1357       case TIM_CHANNEL_4:
;;;1358       {
;;;1359        /* Set the DMA Period elapsed callback */
;;;1360         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1361   
;;;1362         /* Set the DMA error callback */
;;;1363         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;1364   
;;;1365         /* Enable the DMA channel */
;;;1366         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;1367   
;;;1368         /* Enable the TIM Capture/Compare 4 DMA request */
;;;1369         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1370       }
;;;1371       break;
;;;1372   
;;;1373       default:
;;;1374       break;
;;;1375     }
;;;1376   
;;;1377     /* Enable the Capture compare channel */
;;;1378     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1379   
;;;1380     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;1381     {
;;;1382       /* Enable the main output */
;;;1383       __HAL_TIM_MOE_ENABLE(htim);
;;;1384     }
;;;1385   
;;;1386     /* Enable the Peripheral */
;;;1387     __HAL_TIM_ENABLE(htim);
;;;1388   
;;;1389     /* Return function status */
;;;1390     return HAL_OK;
;;;1391   }
00001c  bd70              POP      {r4-r6,pc}
                  |L77.30|
00001e  2002              MOVS     r0,#2                 ;1304
000020  f884003d          STRB     r0,[r4,#0x3d]         ;1304
                  |L77.36|
000024  482c              LDR      r0,|L77.216|
000026  492d              LDR      r1,|L77.220|
000028  b135              CBZ      r5,|L77.56|
00002a  2d04              CMP      r5,#4                 ;1307
00002c  d013              BEQ      |L77.86|
00002e  2d08              CMP      r5,#8                 ;1307
000030  d034              BEQ      |L77.156|
000032  2d0c              CMP      r5,#0xc               ;1307
000034  d11e              BNE      |L77.116|
000036  e040              B        |L77.186|
                  |L77.56|
000038  6a62              LDR      r2,[r4,#0x24]         ;1312
00003a  6290              STR      r0,[r2,#0x28]         ;1315
00003c  6a60              LDR      r0,[r4,#0x24]         ;1315
00003e  6301              STR      r1,[r0,#0x30]         ;1318
000040  6822              LDR      r2,[r4,#0]            ;1318
000042  4631              MOV      r1,r6                 ;1318
000044  3234              ADDS     r2,r2,#0x34           ;1318
000046  6a60              LDR      r0,[r4,#0x24]         ;1318
000048  f7fffffe          BL       HAL_DMA_Start_IT
00004c  6820              LDR      r0,[r4,#0]            ;1321
00004e  68c1              LDR      r1,[r0,#0xc]          ;1321
000050  f4417100          ORR      r1,r1,#0x200          ;1321
000054  e00d              B        |L77.114|
                  |L77.86|
000056  6aa2              LDR      r2,[r4,#0x28]         ;1328
000058  6290              STR      r0,[r2,#0x28]         ;1331
00005a  6aa0              LDR      r0,[r4,#0x28]         ;1331
00005c  6301              STR      r1,[r0,#0x30]         ;1334
00005e  6822              LDR      r2,[r4,#0]            ;1334
000060  4631              MOV      r1,r6                 ;1334
000062  3238              ADDS     r2,r2,#0x38           ;1334
000064  6aa0              LDR      r0,[r4,#0x28]         ;1334
000066  f7fffffe          BL       HAL_DMA_Start_IT
00006a  6820              LDR      r0,[r4,#0]            ;1337
00006c  68c1              LDR      r1,[r0,#0xc]          ;1337
00006e  f4416180          ORR      r1,r1,#0x400          ;1337
                  |L77.114|
000072  60c1              STR      r1,[r0,#0xc]          ;1321
                  |L77.116|
000074  2201              MOVS     r2,#1                 ;1378
000076  4629              MOV      r1,r5                 ;1378
000078  6820              LDR      r0,[r4,#0]            ;1378
00007a  f7fffffe          BL       TIM_CCxChannelCmd
00007e  4918              LDR      r1,|L77.224|
000080  6820              LDR      r0,[r4,#0]            ;1380
000082  4288              CMP      r0,r1                 ;1380
000084  d103              BNE      |L77.142|
000086  6c41              LDR      r1,[r0,#0x44]         ;1383
000088  f4414100          ORR      r1,r1,#0x8000         ;1383
00008c  6441              STR      r1,[r0,#0x44]         ;1383
                  |L77.142|
00008e  6820              LDR      r0,[r4,#0]            ;1387
000090  6801              LDR      r1,[r0,#0]            ;1387
000092  f0410101          ORR      r1,r1,#1              ;1387
000096  6001              STR      r1,[r0,#0]            ;1387
000098  2000              MOVS     r0,#0                 ;1390
00009a  bd70              POP      {r4-r6,pc}
                  |L77.156|
00009c  6ae2              LDR      r2,[r4,#0x2c]         ;1344
00009e  6290              STR      r0,[r2,#0x28]         ;1347
0000a0  6ae0              LDR      r0,[r4,#0x2c]         ;1347
0000a2  6301              STR      r1,[r0,#0x30]         ;1350
0000a4  6822              LDR      r2,[r4,#0]            ;1350
0000a6  4631              MOV      r1,r6                 ;1350
0000a8  323c              ADDS     r2,r2,#0x3c           ;1350
0000aa  6ae0              LDR      r0,[r4,#0x2c]         ;1350
0000ac  f7fffffe          BL       HAL_DMA_Start_IT
0000b0  6820              LDR      r0,[r4,#0]            ;1353
0000b2  68c1              LDR      r1,[r0,#0xc]          ;1353
0000b4  f4416100          ORR      r1,r1,#0x800          ;1353
0000b8  e7db              B        |L77.114|
                  |L77.186|
0000ba  6b22              LDR      r2,[r4,#0x30]         ;1360
0000bc  6290              STR      r0,[r2,#0x28]         ;1363
0000be  6b20              LDR      r0,[r4,#0x30]         ;1363
0000c0  6301              STR      r1,[r0,#0x30]         ;1366
0000c2  6822              LDR      r2,[r4,#0]            ;1366
0000c4  4631              MOV      r1,r6                 ;1366
0000c6  3240              ADDS     r2,r2,#0x40           ;1366
0000c8  6b20              LDR      r0,[r4,#0x30]         ;1366
0000ca  f7fffffe          BL       HAL_DMA_Start_IT
0000ce  6820              LDR      r0,[r4,#0]            ;1369
0000d0  68c1              LDR      r1,[r0,#0xc]          ;1369
0000d2  f4415180          ORR      r1,r1,#0x1000         ;1369
0000d6  e7cc              B        |L77.114|
;;;1392   
                          ENDP

                  |L77.216|
                          DCD      TIM_DMADelayPulseCplt
                  |L77.220|
                          DCD      TIM_DMAError
                  |L77.224|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_PWM_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start_IT PROC
;;;1152   */
;;;1153   HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1154   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L78.22|
;;;1155     /* Check the parameters */
;;;1156     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1157   
;;;1158     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L78.30|
00000c  2908              CMP      r1,#8
00000e  d01d              BEQ      |L78.76|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L78.38|
000014  e01e              B        |L78.84|
                  |L78.22|
;;;1159     {
;;;1160       case TIM_CHANNEL_1:
;;;1161       {
;;;1162         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1163         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0400002          ORR      r0,r0,#2
;;;1164       }
;;;1165       break;
00001c  e002              B        |L78.36|
                  |L78.30|
;;;1166   
;;;1167       case TIM_CHANNEL_2:
;;;1168       {
;;;1169         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1170         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0400004          ORR      r0,r0,#4
                  |L78.36|
000024  60d0              STR      r0,[r2,#0xc]          ;1163
                  |L78.38|
;;;1171       }
;;;1172       break;
;;;1173   
;;;1174       case TIM_CHANNEL_3:
;;;1175       {
;;;1176         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1177         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
;;;1178       }
;;;1179       break;
;;;1180   
;;;1181       case TIM_CHANNEL_4:
;;;1182       {
;;;1183         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1184         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
;;;1185       }
;;;1186       break;
;;;1187   
;;;1188       default:
;;;1189       break;
;;;1190     }
;;;1191   
;;;1192     /* Enable the Capture compare channel */
;;;1193     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000026  2201              MOVS     r2,#1
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;1194   
;;;1195     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00002e  490b              LDR      r1,|L78.92|
000030  6820              LDR      r0,[r4,#0]
000032  4288              CMP      r0,r1
000034  d103              BNE      |L78.62|
;;;1196     {
;;;1197       /* Enable the main output */
;;;1198       __HAL_TIM_MOE_ENABLE(htim);
000036  6c41              LDR      r1,[r0,#0x44]
000038  f4414100          ORR      r1,r1,#0x8000
00003c  6441              STR      r1,[r0,#0x44]
                  |L78.62|
;;;1199     }
;;;1200   
;;;1201     /* Enable the Peripheral */
;;;1202     __HAL_TIM_ENABLE(htim);
00003e  6820              LDR      r0,[r4,#0]
000040  6801              LDR      r1,[r0,#0]
000042  f0410101          ORR      r1,r1,#1
000046  6001              STR      r1,[r0,#0]
;;;1203   
;;;1204     /* Return function status */
;;;1205     return HAL_OK;
000048  2000              MOVS     r0,#0
;;;1206   }
00004a  bd10              POP      {r4,pc}
                  |L78.76|
00004c  68d0              LDR      r0,[r2,#0xc]          ;1177
00004e  f0400008          ORR      r0,r0,#8              ;1177
000052  e7e7              B        |L78.36|
                  |L78.84|
000054  68d0              LDR      r0,[r2,#0xc]          ;1184
000056  f0400010          ORR      r0,r0,#0x10           ;1184
00005a  e7e3              B        |L78.36|
;;;1207   
                          ENDP

                  |L78.92|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_PWM_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop PROC
;;;1117   */
;;;1118   HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1119   {
000002  4604              MOV      r4,r0
;;;1120     /* Check the parameters */
;;;1121     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1122   
;;;1123     /* Disable the Capture compare channel */
;;;1124     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2200              MOVS     r2,#0
000008  f7fffffe          BL       TIM_CCxChannelCmd
;;;1125   
;;;1126     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00000c  4b10              LDR      r3,|L79.80|
;;;1127     {
;;;1128       /* Disable the Main Ouput */
;;;1129       __HAL_TIM_MOE_DISABLE(htim);
00000e  f2411111          MOV      r1,#0x1111
000012  6820              LDR      r0,[r4,#0]            ;1126
000014  108a              ASRS     r2,r1,#2
000016  4298              CMP      r0,r3                 ;1126
000018  d109              BNE      |L79.46|
00001a  6a03              LDR      r3,[r0,#0x20]
00001c  420b              TST      r3,r1
00001e  d106              BNE      |L79.46|
000020  6a03              LDR      r3,[r0,#0x20]
000022  4213              TST      r3,r2
000024  d103              BNE      |L79.46|
000026  6c43              LDR      r3,[r0,#0x44]
000028  f4234300          BIC      r3,r3,#0x8000
00002c  6443              STR      r3,[r0,#0x44]
                  |L79.46|
;;;1130     }
;;;1131   
;;;1132     /* Disable the Peripheral */
;;;1133     __HAL_TIM_DISABLE(htim);
00002e  6820              LDR      r0,[r4,#0]
000030  6a03              LDR      r3,[r0,#0x20]
000032  420b              TST      r3,r1
000034  d106              BNE      |L79.68|
000036  6a01              LDR      r1,[r0,#0x20]
000038  4211              TST      r1,r2
00003a  d103              BNE      |L79.68|
00003c  6801              LDR      r1,[r0,#0]
00003e  f0210101          BIC      r1,r1,#1
000042  6001              STR      r1,[r0,#0]
                  |L79.68|
;;;1134   
;;;1135     /* Change the htim state */
;;;1136     htim->State = HAL_TIM_STATE_READY;
000044  2001              MOVS     r0,#1
000046  f884003d          STRB     r0,[r4,#0x3d]
;;;1137   
;;;1138     /* Return function status */
;;;1139     return HAL_OK;
00004a  2000              MOVS     r0,#0
;;;1140   }
00004c  bd10              POP      {r4,pc}
;;;1141   
                          ENDP

00004e  0000              DCW      0x0000
                  |L79.80|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_PWM_Stop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop_DMA PROC
;;;1403   */
;;;1404   HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1405   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L80.22|
;;;1406     /* Check the parameters */
;;;1407     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1408   
;;;1409     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L80.30|
00000c  2908              CMP      r1,#8
00000e  d02f              BEQ      |L80.112|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L80.38|
000014  e030              B        |L80.120|
                  |L80.22|
;;;1410     {
;;;1411       case TIM_CHANNEL_1:
;;;1412       {
;;;1413         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1414         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f4207000          BIC      r0,r0,#0x200
;;;1415       }
;;;1416       break;
00001c  e002              B        |L80.36|
                  |L80.30|
;;;1417   
;;;1418       case TIM_CHANNEL_2:
;;;1419       {
;;;1420         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1421         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f4206080          BIC      r0,r0,#0x400
                  |L80.36|
000024  60d0              STR      r0,[r2,#0xc]          ;1414
                  |L80.38|
;;;1422       }
;;;1423       break;
;;;1424   
;;;1425       case TIM_CHANNEL_3:
;;;1426       {
;;;1427         /* Disable the TIM Capture/Compare 3 DMA request */
;;;1428         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
;;;1429       }
;;;1430       break;
;;;1431   
;;;1432       case TIM_CHANNEL_4:
;;;1433       {
;;;1434         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1435         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
;;;1436       }
;;;1437       break;
;;;1438   
;;;1439       default:
;;;1440       break;
;;;1441     }
;;;1442   
;;;1443     /* Disable the Capture compare channel */
;;;1444     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000026  2200              MOVS     r2,#0
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;1445   
;;;1446     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00002e  4b14              LDR      r3,|L80.128|
;;;1447     {
;;;1448       /* Disable the Main Ouput */
;;;1449       __HAL_TIM_MOE_DISABLE(htim);
000030  f2411111          MOV      r1,#0x1111
000034  6820              LDR      r0,[r4,#0]            ;1446
000036  108a              ASRS     r2,r1,#2
000038  4298              CMP      r0,r3                 ;1446
00003a  d109              BNE      |L80.80|
00003c  6a03              LDR      r3,[r0,#0x20]
00003e  420b              TST      r3,r1
000040  d106              BNE      |L80.80|
000042  6a03              LDR      r3,[r0,#0x20]
000044  4213              TST      r3,r2
000046  d103              BNE      |L80.80|
000048  6c43              LDR      r3,[r0,#0x44]
00004a  f4234300          BIC      r3,r3,#0x8000
00004e  6443              STR      r3,[r0,#0x44]
                  |L80.80|
;;;1450     }
;;;1451   
;;;1452     /* Disable the Peripheral */
;;;1453     __HAL_TIM_DISABLE(htim);
000050  6820              LDR      r0,[r4,#0]
000052  6a03              LDR      r3,[r0,#0x20]
000054  420b              TST      r3,r1
000056  d106              BNE      |L80.102|
000058  6a01              LDR      r1,[r0,#0x20]
00005a  4211              TST      r1,r2
00005c  d103              BNE      |L80.102|
00005e  6801              LDR      r1,[r0,#0]
000060  f0210101          BIC      r1,r1,#1
000064  6001              STR      r1,[r0,#0]
                  |L80.102|
;;;1454   
;;;1455     /* Change the htim state */
;;;1456     htim->State = HAL_TIM_STATE_READY;
000066  2001              MOVS     r0,#1
000068  f884003d          STRB     r0,[r4,#0x3d]
;;;1457   
;;;1458     /* Return function status */
;;;1459     return HAL_OK;
00006c  2000              MOVS     r0,#0
;;;1460   }
00006e  bd10              POP      {r4,pc}
                  |L80.112|
000070  68d0              LDR      r0,[r2,#0xc]          ;1428
000072  f4206000          BIC      r0,r0,#0x800          ;1428
000076  e7d5              B        |L80.36|
                  |L80.120|
000078  68d0              LDR      r0,[r2,#0xc]          ;1435
00007a  f4205080          BIC      r0,r0,#0x1000         ;1435
00007e  e7d1              B        |L80.36|
;;;1461   
                          ENDP

                  |L80.128|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_PWM_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop_IT PROC
;;;1218   */
;;;1219   HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1220   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L81.22|
;;;1221     /* Check the parameters */
;;;1222     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1223   
;;;1224     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L81.30|
00000c  2908              CMP      r1,#8
00000e  d02c              BEQ      |L81.106|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L81.38|
000014  e02d              B        |L81.114|
                  |L81.22|
;;;1225     {
;;;1226       case TIM_CHANNEL_1:
;;;1227       {
;;;1228         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1229         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0200002          BIC      r0,r0,#2
;;;1230       }
;;;1231       break;
00001c  e002              B        |L81.36|
                  |L81.30|
;;;1232   
;;;1233       case TIM_CHANNEL_2:
;;;1234       {
;;;1235         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1236         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0200004          BIC      r0,r0,#4
                  |L81.36|
000024  60d0              STR      r0,[r2,#0xc]          ;1229
                  |L81.38|
;;;1237       }
;;;1238       break;
;;;1239   
;;;1240       case TIM_CHANNEL_3:
;;;1241       {
;;;1242         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1243         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
;;;1244       }
;;;1245       break;
;;;1246   
;;;1247       case TIM_CHANNEL_4:
;;;1248       {
;;;1249         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1250         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
;;;1251       }
;;;1252       break;
;;;1253   
;;;1254       default:
;;;1255       break;
;;;1256     }
;;;1257   
;;;1258     /* Disable the Capture compare channel */
;;;1259     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000026  2200              MOVS     r2,#0
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;1260   
;;;1261     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00002e  4b13              LDR      r3,|L81.124|
;;;1262     {
;;;1263       /* Disable the Main Ouput */
;;;1264       __HAL_TIM_MOE_DISABLE(htim);
000030  f2411211          MOV      r2,#0x1111
000034  6820              LDR      r0,[r4,#0]            ;1261
000036  1091              ASRS     r1,r2,#2
000038  4298              CMP      r0,r3                 ;1261
00003a  d109              BNE      |L81.80|
00003c  6a03              LDR      r3,[r0,#0x20]
00003e  4213              TST      r3,r2
000040  d106              BNE      |L81.80|
000042  6a03              LDR      r3,[r0,#0x20]
000044  420b              TST      r3,r1
000046  d103              BNE      |L81.80|
000048  6c43              LDR      r3,[r0,#0x44]
00004a  f4234300          BIC      r3,r3,#0x8000
00004e  6443              STR      r3,[r0,#0x44]
                  |L81.80|
;;;1265     }
;;;1266   
;;;1267     /* Disable the Peripheral */
;;;1268     __HAL_TIM_DISABLE(htim);
000050  6820              LDR      r0,[r4,#0]
000052  6a03              LDR      r3,[r0,#0x20]
000054  4213              TST      r3,r2
000056  d106              BNE      |L81.102|
000058  6a02              LDR      r2,[r0,#0x20]
00005a  420a              TST      r2,r1
00005c  d103              BNE      |L81.102|
00005e  6801              LDR      r1,[r0,#0]
000060  f0210101          BIC      r1,r1,#1
000064  6001              STR      r1,[r0,#0]
                  |L81.102|
;;;1269   
;;;1270     /* Return function status */
;;;1271     return HAL_OK;
000066  2000              MOVS     r0,#0
;;;1272   }
000068  bd10              POP      {r4,pc}
                  |L81.106|
00006a  68d0              LDR      r0,[r2,#0xc]          ;1243
00006c  f0200008          BIC      r0,r0,#8              ;1243
000070  e7d8              B        |L81.36|
                  |L81.114|
000072  68d0              LDR      r0,[r2,#0xc]          ;1250
000074  f0200010          BIC      r0,r0,#0x10           ;1250
000078  e7d4              B        |L81.36|
;;;1273   
                          ENDP

00007a  0000              DCW      0x0000
                  |L81.124|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_PeriodElapsedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PeriodElapsedCallback PROC
;;;4284     */
;;;4285   __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4286   {
;;;4287     /* Prevent unused argument(s) compilation warning */
;;;4288     UNUSED(htim);
;;;4289     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4290               the __HAL_TIM_PeriodElapsedCallback could be implemented in the user file
;;;4291      */
;;;4292   
;;;4293   }
;;;4294   /**
                          ENDP


                          AREA ||i.HAL_TIM_ReadCapturedValue||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ReadCapturedValue PROC
;;;4197     */
;;;4198   uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  f890303c          LDRB     r3,[r0,#0x3c]
;;;4199   {
;;;4200     uint32_t tmpreg = 0U;
000004  2200              MOVS     r2,#0
;;;4201   
;;;4202     __HAL_LOCK(htim);
000006  2b01              CMP      r3,#1
000008  d00a              BEQ      |L83.32|
00000a  2301              MOVS     r3,#1
00000c  f880303c          STRB     r3,[r0,#0x3c]
000010  b141              CBZ      r1,|L83.36|
;;;4203   
;;;4204     switch (Channel)
000012  2904              CMP      r1,#4
000014  d009              BEQ      |L83.42|
000016  2908              CMP      r1,#8
000018  d00a              BEQ      |L83.48|
00001a  290c              CMP      r1,#0xc
00001c  d10d              BNE      |L83.58|
00001e  e00a              B        |L83.54|
                  |L83.32|
000020  2002              MOVS     r0,#2                 ;4202
;;;4205     {
;;;4206     case TIM_CHANNEL_1:
;;;4207       {
;;;4208         /* Check the parameters */
;;;4209         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4210   
;;;4211         /* Return the capture 1 value */
;;;4212         tmpreg =  htim->Instance->CCR1;
;;;4213   
;;;4214         break;
;;;4215       }
;;;4216     case TIM_CHANNEL_2:
;;;4217       {
;;;4218         /* Check the parameters */
;;;4219         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4220   
;;;4221         /* Return the capture 2 value */
;;;4222         tmpreg =   htim->Instance->CCR2;
;;;4223   
;;;4224         break;
;;;4225       }
;;;4226   
;;;4227     case TIM_CHANNEL_3:
;;;4228       {
;;;4229         /* Check the parameters */
;;;4230         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;4231   
;;;4232         /* Return the capture 3 value */
;;;4233         tmpreg =   htim->Instance->CCR3;
;;;4234   
;;;4235         break;
;;;4236       }
;;;4237   
;;;4238     case TIM_CHANNEL_4:
;;;4239       {
;;;4240         /* Check the parameters */
;;;4241         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;4242   
;;;4243         /* Return the capture 4 value */
;;;4244         tmpreg =   htim->Instance->CCR4;
;;;4245   
;;;4246         break;
;;;4247       }
;;;4248   
;;;4249     default:
;;;4250       break;
;;;4251     }
;;;4252   
;;;4253     __HAL_UNLOCK(htim);
;;;4254     return tmpreg;
;;;4255   }
000022  4770              BX       lr
                  |L83.36|
000024  6801              LDR      r1,[r0,#0]            ;4212
000026  6b4a              LDR      r2,[r1,#0x34]         ;4212
000028  e007              B        |L83.58|
                  |L83.42|
00002a  6801              LDR      r1,[r0,#0]            ;4222
00002c  6b8a              LDR      r2,[r1,#0x38]         ;4222
00002e  e004              B        |L83.58|
                  |L83.48|
000030  6801              LDR      r1,[r0,#0]            ;4233
000032  6bca              LDR      r2,[r1,#0x3c]         ;4233
000034  e001              B        |L83.58|
                  |L83.54|
000036  6801              LDR      r1,[r0,#0]            ;4244
000038  6c0a              LDR      r2,[r1,#0x40]         ;4244
                  |L83.58|
00003a  2100              MOVS     r1,#0                 ;4253
00003c  f880103c          STRB     r1,[r0,#0x3c]         ;4253
000040  4610              MOV      r0,r2                 ;4254
000042  4770              BX       lr
;;;4256   
                          ENDP


                          AREA ||i.HAL_TIM_SlaveConfigSynchronization||, CODE, READONLY, ALIGN=1

                  HAL_TIM_SlaveConfigSynchronization PROC
;;;4124     */
;;;4125   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef * sSlaveConfig)
000000  b570              PUSH     {r4-r6,lr}
;;;4126   {
000002  4604              MOV      r4,r0
;;;4127     /* Check the parameters */
;;;4128     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;4129     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;4130     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;4131   
;;;4132     __HAL_LOCK(htim);
000004  f890003c          LDRB     r0,[r0,#0x3c]
000008  2801              CMP      r0,#1
00000a  d018              BEQ      |L84.62|
00000c  2501              MOVS     r5,#1
00000e  f884503c          STRB     r5,[r4,#0x3c]
;;;4133   
;;;4134     htim->State = HAL_TIM_STATE_BUSY;
000012  2002              MOVS     r0,#2
000014  f884003d          STRB     r0,[r4,#0x3d]
;;;4135   
;;;4136     TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       TIM_SlaveTimer_SetConfig
;;;4137   
;;;4138     /* Disable Trigger Interrupt */
;;;4139     __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);
00001e  6820              LDR      r0,[r4,#0]
000020  68c1              LDR      r1,[r0,#0xc]
000022  f0210140          BIC      r1,r1,#0x40
000026  60c1              STR      r1,[r0,#0xc]
;;;4140   
;;;4141     /* Disable Trigger DMA request */
;;;4142     __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
000028  6820              LDR      r0,[r4,#0]
00002a  68c1              LDR      r1,[r0,#0xc]
00002c  f4214180          BIC      r1,r1,#0x4000
000030  60c1              STR      r1,[r0,#0xc]
;;;4143   
;;;4144     htim->State = HAL_TIM_STATE_READY;
000032  f884503d          STRB     r5,[r4,#0x3d]
;;;4145   
;;;4146     __HAL_UNLOCK(htim);
000036  2000              MOVS     r0,#0
000038  f884003c          STRB     r0,[r4,#0x3c]
;;;4147   
;;;4148     return HAL_OK;
;;;4149       }
00003c  bd70              POP      {r4-r6,pc}
                  |L84.62|
00003e  2002              MOVS     r0,#2                 ;4132
000040  bd70              POP      {r4-r6,pc}
;;;4150   
                          ENDP


                          AREA ||i.HAL_TIM_SlaveConfigSynchronization_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_SlaveConfigSynchronization_IT PROC
;;;4159     */
;;;4160   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization_IT(TIM_HandleTypeDef *htim,
000000  b570              PUSH     {r4-r6,lr}
;;;4161                                                           TIM_SlaveConfigTypeDef * sSlaveConfig)
;;;4162       {
000002  4604              MOV      r4,r0
;;;4163         /* Check the parameters */
;;;4164     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;4165     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;4166     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;4167   
;;;4168     __HAL_LOCK(htim);
000004  f890003c          LDRB     r0,[r0,#0x3c]
000008  2801              CMP      r0,#1
00000a  d018              BEQ      |L85.62|
00000c  2501              MOVS     r5,#1
00000e  f884503c          STRB     r5,[r4,#0x3c]
;;;4169   
;;;4170     htim->State = HAL_TIM_STATE_BUSY;
000012  2002              MOVS     r0,#2
000014  f884003d          STRB     r0,[r4,#0x3d]
;;;4171   
;;;4172     TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       TIM_SlaveTimer_SetConfig
;;;4173   
;;;4174     /* Enable Trigger Interrupt */
;;;4175     __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
00001e  6820              LDR      r0,[r4,#0]
000020  68c1              LDR      r1,[r0,#0xc]
000022  f0410140          ORR      r1,r1,#0x40
000026  60c1              STR      r1,[r0,#0xc]
;;;4176   
;;;4177     /* Disable Trigger DMA request */
;;;4178     __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
000028  6820              LDR      r0,[r4,#0]
00002a  68c1              LDR      r1,[r0,#0xc]
00002c  f4214180          BIC      r1,r1,#0x4000
000030  60c1              STR      r1,[r0,#0xc]
;;;4179   
;;;4180     htim->State = HAL_TIM_STATE_READY;
000032  f884503d          STRB     r5,[r4,#0x3d]
;;;4181   
;;;4182     __HAL_UNLOCK(htim);
000036  2000              MOVS     r0,#0
000038  f884003c          STRB     r0,[r4,#0x3c]
;;;4183   
;;;4184     return HAL_OK;
;;;4185   }
00003c  bd70              POP      {r4-r6,pc}
                  |L85.62|
00003e  2002              MOVS     r0,#2                 ;4168
000040  bd70              POP      {r4-r6,pc}
;;;4186   
                          ENDP


                          AREA ||i.HAL_TIM_TriggerCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_TriggerCallback PROC
;;;4339     */
;;;4340   __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4341   {
;;;4342     /* Prevent unused argument(s) compilation warning */
;;;4343     UNUSED(htim);
;;;4344     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4345               the HAL_TIM_TriggerCallback could be implemented in the user file
;;;4346      */
;;;4347   }
;;;4348   
                          ENDP


                          AREA ||i.TIM_Base_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_Base_SetConfig PROC
;;;4566     */
;;;4567   void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
000000  b5f0              PUSH     {r4-r7,lr}
;;;4568   {
;;;4569     uint32_t tmpcr1 = 0U;
;;;4570     tmpcr1 = TIMx->CR1;
000002  6802              LDR      r2,[r0,#0]
;;;4571   
;;;4572     /* Set TIM Time Base Unit parameters ---------------------------------------*/
;;;4573     if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
000004  4b16              LDR      r3,|L87.96|
000006  4c17              LDR      r4,|L87.100|
000008  4d17              LDR      r5,|L87.104|
00000a  f04f4780          MOV      r7,#0x40000000
00000e  4298              CMP      r0,r3
000010  d005              BEQ      |L87.30|
000012  42b8              CMP      r0,r7
000014  d003              BEQ      |L87.30|
000016  42a0              CMP      r0,r4
000018  d001              BEQ      |L87.30|
00001a  42a8              CMP      r0,r5
00001c  d103              BNE      |L87.38|
                  |L87.30|
;;;4574     {
;;;4575       /* Select the Counter Mode */
;;;4576       tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
00001e  f0220670          BIC      r6,r2,#0x70
;;;4577       tmpcr1 |= Structure->CounterMode;
000022  684a              LDR      r2,[r1,#4]
000024  4332              ORRS     r2,r2,r6
                  |L87.38|
;;;4578     }
;;;4579   
;;;4580     if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
000026  4298              CMP      r0,r3
000028  d005              BEQ      |L87.54|
00002a  42b8              CMP      r0,r7
00002c  d003              BEQ      |L87.54|
00002e  42a0              CMP      r0,r4
000030  d001              BEQ      |L87.54|
000032  42a8              CMP      r0,r5
000034  d103              BNE      |L87.62|
                  |L87.54|
;;;4581     {
;;;4582       /* Set the clock division */
;;;4583       tmpcr1 &= ~TIM_CR1_CKD;
000036  f4227440          BIC      r4,r2,#0x300
;;;4584       tmpcr1 |= (uint32_t)Structure->ClockDivision;
00003a  68ca              LDR      r2,[r1,#0xc]
00003c  4322              ORRS     r2,r2,r4
                  |L87.62|
;;;4585     }
;;;4586   
;;;4587     /* Set the auto-reload preload */
;;;4588     tmpcr1 &= ~TIM_CR1_ARPE;
00003e  f0220480          BIC      r4,r2,#0x80
;;;4589     tmpcr1 |= (uint32_t)Structure->AutoReloadPreload;
000042  694a              LDR      r2,[r1,#0x14]
000044  4322              ORRS     r2,r2,r4
;;;4590   
;;;4591     TIMx->CR1 = tmpcr1;
000046  6002              STR      r2,[r0,#0]
;;;4592   
;;;4593     /* Set the Autoreload value */
;;;4594     TIMx->ARR = (uint32_t)Structure->Period ;
000048  688a              LDR      r2,[r1,#8]
00004a  62c2              STR      r2,[r0,#0x2c]
;;;4595   
;;;4596     /* Set the Prescaler value */
;;;4597     TIMx->PSC = (uint32_t)Structure->Prescaler;
00004c  680a              LDR      r2,[r1,#0]
00004e  6282              STR      r2,[r0,#0x28]
;;;4598   
;;;4599     if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
000050  4298              CMP      r0,r3
000052  d101              BNE      |L87.88|
;;;4600     {
;;;4601       /* Set the Repetition Counter value */
;;;4602       TIMx->RCR = Structure->RepetitionCounter;
000054  6909              LDR      r1,[r1,#0x10]
000056  6301              STR      r1,[r0,#0x30]
                  |L87.88|
;;;4603     }
;;;4604   
;;;4605     /* Generate an update event to reload the Prescaler 
;;;4606        and the repetition counter(only for TIM1 and TIM8) value immediatly */
;;;4607     TIMx->EGR = TIM_EGR_UG;
000058  2101              MOVS     r1,#1
00005a  6141              STR      r1,[r0,#0x14]
;;;4608   }
00005c  bdf0              POP      {r4-r7,pc}
;;;4609   
                          ENDP

00005e  0000              DCW      0x0000
                  |L87.96|
                          DCD      0x40012c00
                  |L87.100|
                          DCD      0x40000400
                  |L87.104|
                          DCD      0x40000800

                          AREA ||i.TIM_CCxChannelCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxChannelCmd PROC
;;;5361     */
;;;5362   void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
000000  b510              PUSH     {r4,lr}
;;;5363   {
;;;5364     uint32_t tmp = 0U;
;;;5365   
;;;5366     /* Check the parameters */
;;;5367     assert_param(IS_TIM_CC1_INSTANCE(TIMx));
;;;5368     assert_param(IS_TIM_CHANNELS(Channel));
;;;5369   
;;;5370     tmp = TIM_CCER_CC1E << Channel;
000002  2301              MOVS     r3,#1
;;;5371   
;;;5372     /* Reset the CCxE Bit */
;;;5373     TIMx->CCER &= ~tmp;
000004  6a04              LDR      r4,[r0,#0x20]
000006  408b              LSLS     r3,r3,r1              ;5370
000008  439c              BICS     r4,r4,r3
00000a  6204              STR      r4,[r0,#0x20]
;;;5374   
;;;5375     /* Set or reset the CCxE Bit */
;;;5376     TIMx->CCER |=  (uint32_t)(ChannelState << Channel);
00000c  6a03              LDR      r3,[r0,#0x20]
00000e  408a              LSLS     r2,r2,r1
000010  4313              ORRS     r3,r3,r2
000012  6203              STR      r3,[r0,#0x20]
;;;5377   }
000014  bd10              POP      {r4,pc}
;;;5378   
                          ENDP


                          AREA ||i.TIM_DMACaptureCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMACaptureCplt PROC
;;;4504     */
;;;4505   void TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4506   {
;;;4507     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
;;;4508   
;;;4509     htim->State= HAL_TIM_STATE_READY;
000002  6a44              LDR      r4,[r0,#0x24]
000004  2101              MOVS     r1,#1
000006  f884103d          STRB     r1,[r4,#0x3d]
;;;4510   
;;;4511     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
00000a  6a62              LDR      r2,[r4,#0x24]
00000c  4282              CMP      r2,r0
00000e  d101              BNE      |L89.20|
;;;4512     {
;;;4513       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000010  7721              STRB     r1,[r4,#0x1c]
000012  e00e              B        |L89.50|
                  |L89.20|
;;;4514     }
;;;4515     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
000014  6aa1              LDR      r1,[r4,#0x28]
000016  4281              CMP      r1,r0
000018  d101              BNE      |L89.30|
;;;4516     {
;;;4517       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
00001a  2002              MOVS     r0,#2
00001c  e008              B        |L89.48|
                  |L89.30|
;;;4518     }
;;;4519     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
00001e  6ae1              LDR      r1,[r4,#0x2c]
000020  4281              CMP      r1,r0
000022  d101              BNE      |L89.40|
;;;4520     {
;;;4521       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000024  2004              MOVS     r0,#4
000026  e003              B        |L89.48|
                  |L89.40|
;;;4522     }
;;;4523     else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
000028  6b21              LDR      r1,[r4,#0x30]
00002a  4281              CMP      r1,r0
00002c  d101              BNE      |L89.50|
;;;4524     {
;;;4525       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
00002e  2008              MOVS     r0,#8
                  |L89.48|
000030  7720              STRB     r0,[r4,#0x1c]
                  |L89.50|
;;;4526     }
;;;4527   
;;;4528     HAL_TIM_IC_CaptureCallback(htim);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
;;;4529   
;;;4530     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000038  2000              MOVS     r0,#0
00003a  7720              STRB     r0,[r4,#0x1c]
;;;4531   }
00003c  bd10              POP      {r4,pc}
;;;4532   
                          ENDP


                          AREA ||i.TIM_DMADelayPulseCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMADelayPulseCplt PROC
;;;4472     */
;;;4473   void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4474   {
;;;4475     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
;;;4476   
;;;4477     htim->State= HAL_TIM_STATE_READY;
000002  6a44              LDR      r4,[r0,#0x24]
000004  2101              MOVS     r1,#1
000006  f884103d          STRB     r1,[r4,#0x3d]
;;;4478   
;;;4479     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
00000a  6a62              LDR      r2,[r4,#0x24]
00000c  4282              CMP      r2,r0
00000e  d101              BNE      |L90.20|
;;;4480     {
;;;4481       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000010  7721              STRB     r1,[r4,#0x1c]
000012  e00e              B        |L90.50|
                  |L90.20|
;;;4482     }
;;;4483     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
000014  6aa1              LDR      r1,[r4,#0x28]
000016  4281              CMP      r1,r0
000018  d101              BNE      |L90.30|
;;;4484     {
;;;4485       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
00001a  2002              MOVS     r0,#2
00001c  e008              B        |L90.48|
                  |L90.30|
;;;4486     }
;;;4487     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
00001e  6ae1              LDR      r1,[r4,#0x2c]
000020  4281              CMP      r1,r0
000022  d101              BNE      |L90.40|
;;;4488     {
;;;4489       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000024  2004              MOVS     r0,#4
000026  e003              B        |L90.48|
                  |L90.40|
;;;4490     }
;;;4491     else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
000028  6b21              LDR      r1,[r4,#0x30]
00002a  4281              CMP      r1,r0
00002c  d101              BNE      |L90.50|
;;;4492     {
;;;4493       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
00002e  2008              MOVS     r0,#8
                  |L90.48|
000030  7720              STRB     r0,[r4,#0x1c]
                  |L90.50|
;;;4494     }
;;;4495   
;;;4496     HAL_TIM_PWM_PulseFinishedCallback(htim);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
;;;4497   
;;;4498     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000038  2000              MOVS     r0,#0
00003a  7720              STRB     r0,[r4,#0x1c]
;;;4499   }
00003c  bd10              POP      {r4,pc}
;;;4500   /**
                          ENDP


                          AREA ||i.TIM_DMAError||, CODE, READONLY, ALIGN=1

                  TIM_DMAError PROC
;;;4458     */
;;;4459   void TIM_DMAError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4460   {
;;;4461     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;4462   
;;;4463     htim->State= HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  f880103d          STRB     r1,[r0,#0x3d]
;;;4464   
;;;4465     HAL_TIM_ErrorCallback(htim);
00000a  f7fffffe          BL       HAL_TIM_ErrorCallback
;;;4466   }
00000e  bd10              POP      {r4,pc}
;;;4467   
                          ENDP


                          AREA ||i.TIM_DMAPeriodElapsedCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMAPeriodElapsedCplt PROC
;;;4537     */
;;;4538   static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4539   {
;;;4540     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;4541   
;;;4542     htim->State= HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  f880103d          STRB     r1,[r0,#0x3d]
;;;4543   
;;;4544     HAL_TIM_PeriodElapsedCallback(htim);
00000a  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
;;;4545   }
00000e  bd10              POP      {r4,pc}
;;;4546   
                          ENDP


                          AREA ||i.TIM_DMATriggerCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMATriggerCplt PROC
;;;4551     */
;;;4552   static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4553   {
;;;4554     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;4555   
;;;4556     htim->State= HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  f880103d          STRB     r1,[r0,#0x3d]
;;;4557   
;;;4558     HAL_TIM_TriggerCallback(htim);
00000a  f7fffffe          BL       HAL_TIM_TriggerCallback
;;;4559   }
00000e  bd10              POP      {r4,pc}
;;;4560   
                          ENDP


                          AREA ||i.TIM_ETR_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_ETR_SetConfig PROC
;;;5331     */
;;;5332   static void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
000000  b510              PUSH     {r4,lr}
;;;5333                          uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
;;;5334   {
;;;5335     uint32_t tmpsmcr = 0U;
;;;5336   
;;;5337     tmpsmcr = TIMx->SMCR;
000002  6884              LDR      r4,[r0,#8]
;;;5338   
;;;5339     /* Reset the ETR Bits */
;;;5340     tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
;;;5341   
;;;5342     /* Set the Prescaler, the Filter value and the Polarity */
;;;5343     tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
000004  ea422203          ORR      r2,r2,r3,LSL #8
000008  f424447f          BIC      r4,r4,#0xff00         ;5340
00000c  430a              ORRS     r2,r2,r1
00000e  4322              ORRS     r2,r2,r4
;;;5344   
;;;5345     /* Write to TIMx SMCR */
;;;5346     TIMx->SMCR = tmpsmcr;
000010  6082              STR      r2,[r0,#8]
;;;5347   }
000012  bd10              POP      {r4,pc}
;;;5348   
                          ENDP


                          AREA ||i.TIM_ITRx_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITRx_SetConfig PROC
;;;5301     */
;;;5302   static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t InputTriggerSource)
000000  6882              LDR      r2,[r0,#8]
;;;5303   {
;;;5304     uint32_t tmpsmcr = 0U;
;;;5305   
;;;5306      /* Get the TIMx SMCR register value */
;;;5307      tmpsmcr = TIMx->SMCR;
;;;5308      /* Reset the TS Bits */
;;;5309      tmpsmcr &= ~TIM_SMCR_TS;
000002  f0220270          BIC      r2,r2,#0x70
;;;5310      /* Set the Input Trigger source and the slave mode*/
;;;5311      tmpsmcr |= InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1;
000006  430a              ORRS     r2,r2,r1
000008  f0420107          ORR      r1,r2,#7
;;;5312      /* Write to TIMx SMCR */
;;;5313      TIMx->SMCR = tmpsmcr;
00000c  6081              STR      r1,[r0,#8]
;;;5314   }
00000e  4770              BX       lr
;;;5315   /**
                          ENDP


                          AREA ||i.TIM_OC1_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC1_SetConfig PROC
;;;4615     */
;;;4616   static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;4617   {
;;;4618     uint32_t tmpccmrx = 0U;
;;;4619     uint32_t tmpccer = 0U;
;;;4620     uint32_t tmpcr2 = 0U;
;;;4621   
;;;4622      /* Disable the Channel 1: Reset the CC1E Bit */
;;;4623     TIMx->CCER &= ~TIM_CCER_CC1E;
000002  6a02              LDR      r2,[r0,#0x20]
000004  f0220201          BIC      r2,r2,#1
000008  6202              STR      r2,[r0,#0x20]
;;;4624   
;;;4625     /* Get the TIMx CCER register value */
;;;4626     tmpccer = TIMx->CCER;
00000a  6a02              LDR      r2,[r0,#0x20]
;;;4627     /* Get the TIMx CR2 register value */
;;;4628     tmpcr2 =  TIMx->CR2;
00000c  6843              LDR      r3,[r0,#4]
;;;4629   
;;;4630     /* Get the TIMx CCMR1 register value */
;;;4631     tmpccmrx = TIMx->CCMR1;
00000e  6984              LDR      r4,[r0,#0x18]
;;;4632   
;;;4633     /* Reset the Output Compare Mode Bits */
;;;4634     tmpccmrx &= ~TIM_CCMR1_OC1M;
;;;4635     tmpccmrx &= ~TIM_CCMR1_CC1S;
000010  f0240573          BIC      r5,r4,#0x73
;;;4636     /* Select the Output Compare Mode */
;;;4637     tmpccmrx |= OC_Config->OCMode;
000014  680c              LDR      r4,[r1,#0]
000016  432c              ORRS     r4,r4,r5
;;;4638   
;;;4639     /* Reset the Output Polarity level */
;;;4640     tmpccer &= ~TIM_CCER_CC1P;
000018  f0220502          BIC      r5,r2,#2
;;;4641     /* Set the Output Compare Polarity */
;;;4642     tmpccer |= OC_Config->OCPolarity;
00001c  688a              LDR      r2,[r1,#8]
00001e  432a              ORRS     r2,r2,r5
;;;4643   
;;;4644     if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
000020  4d0a              LDR      r5,|L96.76|
000022  42a8              CMP      r0,r5
000024  d10b              BNE      |L96.62|
;;;4645     {
;;;4646       /* Check parameters */
;;;4647       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;4648   
;;;4649       /* Reset the Output N Polarity level */
;;;4650       tmpccer &= ~TIM_CCER_CC1NP;
000026  f0220508          BIC      r5,r2,#8
;;;4651       /* Set the Output N Polarity */
;;;4652       tmpccer |= OC_Config->OCNPolarity;
00002a  68ca              LDR      r2,[r1,#0xc]
;;;4653       /* Reset the Output N State */
;;;4654       tmpccer &= ~TIM_CCER_CC1NE;
;;;4655     }
;;;4656   
;;;4657     if(IS_TIM_BREAK_INSTANCE(TIMx))
;;;4658     {
;;;4659       /* Check parameters */
;;;4660       assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
;;;4661       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;4662   
;;;4663       /* Reset the Output Compare and Output Compare N IDLE State */
;;;4664       tmpcr2 &= ~TIM_CR2_OIS1;
;;;4665       tmpcr2 &= ~TIM_CR2_OIS1N;
00002c  f4237340          BIC      r3,r3,#0x300
000030  432a              ORRS     r2,r2,r5              ;4652
;;;4666       /* Set the Output Idle state */
;;;4667       tmpcr2 |= OC_Config->OCIdleState;
000032  694d              LDR      r5,[r1,#0x14]
000034  f0220204          BIC      r2,r2,#4              ;4654
000038  431d              ORRS     r5,r5,r3
;;;4668       /* Set the Output N Idle state */
;;;4669       tmpcr2 |= OC_Config->OCNIdleState;
00003a  698b              LDR      r3,[r1,#0x18]
00003c  432b              ORRS     r3,r3,r5
                  |L96.62|
;;;4670     }
;;;4671     /* Write to TIMx CR2 */
;;;4672     TIMx->CR2 = tmpcr2;
00003e  6043              STR      r3,[r0,#4]
;;;4673   
;;;4674     /* Write to TIMx CCMR1 */
;;;4675     TIMx->CCMR1 = tmpccmrx;
000040  6184              STR      r4,[r0,#0x18]
;;;4676   
;;;4677     /* Set the Capture Compare Register value */
;;;4678     TIMx->CCR1 = OC_Config->Pulse;
000042  6849              LDR      r1,[r1,#4]
000044  6341              STR      r1,[r0,#0x34]
;;;4679   
;;;4680     /* Write to TIMx CCER */
;;;4681     TIMx->CCER = tmpccer;
000046  6202              STR      r2,[r0,#0x20]
;;;4682   }
000048  bd30              POP      {r4,r5,pc}
;;;4683   
                          ENDP

00004a  0000              DCW      0x0000
                  |L96.76|
                          DCD      0x40012c00

                          AREA ||i.TIM_OC2_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC2_SetConfig PROC
;;;4689     */
;;;4690   void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;4691   {
;;;4692     uint32_t tmpccmrx = 0U;
;;;4693     uint32_t tmpccer = 0U;
;;;4694     uint32_t tmpcr2 = 0U;
;;;4695   
;;;4696     /* Disable the Channel 2: Reset the CC2E Bit */
;;;4697     TIMx->CCER &= ~TIM_CCER_CC2E;
000002  6a02              LDR      r2,[r0,#0x20]
000004  f0220210          BIC      r2,r2,#0x10
000008  6202              STR      r2,[r0,#0x20]
;;;4698   
;;;4699     /* Get the TIMx CCER register value */
;;;4700     tmpccer = TIMx->CCER;
00000a  6a02              LDR      r2,[r0,#0x20]
;;;4701     /* Get the TIMx CR2 register value */
;;;4702     tmpcr2 =  TIMx->CR2;
00000c  6843              LDR      r3,[r0,#4]
;;;4703   
;;;4704     /* Get the TIMx CCMR1 register value */
;;;4705     tmpccmrx = TIMx->CCMR1;
00000e  6984              LDR      r4,[r0,#0x18]
;;;4706   
;;;4707     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;4708     tmpccmrx &= ~TIM_CCMR1_OC2M;
;;;4709     tmpccmrx &= ~TIM_CCMR1_CC2S;
;;;4710   
;;;4711     /* Select the Output Compare Mode */
;;;4712     tmpccmrx |= (OC_Config->OCMode << 8U);
000010  680d              LDR      r5,[r1,#0]
000012  f42444e6          BIC      r4,r4,#0x7300         ;4709
000016  ea442405          ORR      r4,r4,r5,LSL #8
;;;4713   
;;;4714     /* Reset the Output Polarity level */
;;;4715     tmpccer &= ~TIM_CCER_CC2P;
;;;4716     /* Set the Output Compare Polarity */
;;;4717     tmpccer |= (OC_Config->OCPolarity << 4U);
00001a  688d              LDR      r5,[r1,#8]
00001c  f0220220          BIC      r2,r2,#0x20           ;4715
000020  ea421205          ORR      r2,r2,r5,LSL #4
;;;4718   
;;;4719     if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
000024  4d0b              LDR      r5,|L97.84|
000026  42a8              CMP      r0,r5
000028  d10e              BNE      |L97.72|
;;;4720     {
;;;4721       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;4722   
;;;4723       /* Reset the Output N Polarity level */
;;;4724       tmpccer &= ~TIM_CCER_CC2NP;
;;;4725       /* Set the Output N Polarity */
;;;4726       tmpccer |= (OC_Config->OCNPolarity << 4U);
00002a  68cd              LDR      r5,[r1,#0xc]
00002c  f0220280          BIC      r2,r2,#0x80           ;4724
000030  ea421205          ORR      r2,r2,r5,LSL #4
;;;4727       /* Reset the Output N State */
;;;4728       tmpccer &= ~TIM_CCER_CC2NE;
;;;4729   
;;;4730     }
;;;4731   
;;;4732     if(IS_TIM_BREAK_INSTANCE(TIMx))
;;;4733     {
;;;4734       /* Check parameters */
;;;4735       assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
;;;4736       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;4737   
;;;4738       /* Reset the Output Compare and Output Compare N IDLE State */
;;;4739       tmpcr2 &= ~TIM_CR2_OIS2;
;;;4740       tmpcr2 &= ~TIM_CR2_OIS2N;
;;;4741       /* Set the Output Idle state */
;;;4742       tmpcr2 |= (OC_Config->OCIdleState << 2);
000034  694d              LDR      r5,[r1,#0x14]
000036  f4236340          BIC      r3,r3,#0xc00          ;4740
00003a  ea430385          ORR      r3,r3,r5,LSL #2
;;;4743       /* Set the Output N Idle state */
;;;4744       tmpcr2 |= (OC_Config->OCNIdleState << 2);
00003e  698d              LDR      r5,[r1,#0x18]
000040  f0220240          BIC      r2,r2,#0x40           ;4728
000044  ea430385          ORR      r3,r3,r5,LSL #2
                  |L97.72|
;;;4745     }
;;;4746   
;;;4747     /* Write to TIMx CR2 */
;;;4748     TIMx->CR2 = tmpcr2;
000048  6043              STR      r3,[r0,#4]
;;;4749   
;;;4750     /* Write to TIMx CCMR1 */
;;;4751     TIMx->CCMR1 = tmpccmrx;
00004a  6184              STR      r4,[r0,#0x18]
;;;4752   
;;;4753     /* Set the Capture Compare Register value */
;;;4754     TIMx->CCR2 = OC_Config->Pulse;
00004c  6849              LDR      r1,[r1,#4]
00004e  6381              STR      r1,[r0,#0x38]
;;;4755   
;;;4756     /* Write to TIMx CCER */
;;;4757     TIMx->CCER = tmpccer;
000050  6202              STR      r2,[r0,#0x20]
;;;4758   }
000052  bd30              POP      {r4,r5,pc}
;;;4759   
                          ENDP

                  |L97.84|
                          DCD      0x40012c00

                          AREA ||i.TIM_OC3_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC3_SetConfig PROC
;;;4765     */
;;;4766   static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;4767   {
;;;4768     uint32_t tmpccmrx = 0U;
;;;4769     uint32_t tmpccer = 0U;
;;;4770     uint32_t tmpcr2 = 0U;
;;;4771   
;;;4772     /* Disable the Channel 3: Reset the CC2E Bit */
;;;4773     TIMx->CCER &= ~TIM_CCER_CC3E;
000002  6a02              LDR      r2,[r0,#0x20]
000004  f4227280          BIC      r2,r2,#0x100
000008  6202              STR      r2,[r0,#0x20]
;;;4774   
;;;4775     /* Get the TIMx CCER register value */
;;;4776     tmpccer = TIMx->CCER;
00000a  6a03              LDR      r3,[r0,#0x20]
;;;4777     /* Get the TIMx CR2 register value */
;;;4778     tmpcr2 =  TIMx->CR2;
00000c  6842              LDR      r2,[r0,#4]
;;;4779   
;;;4780     /* Get the TIMx CCMR2 register value */
;;;4781     tmpccmrx = TIMx->CCMR2;
00000e  69c4              LDR      r4,[r0,#0x1c]
;;;4782   
;;;4783     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;4784     tmpccmrx &= ~TIM_CCMR2_OC3M;
;;;4785     tmpccmrx &= ~TIM_CCMR2_CC3S;
;;;4786     /* Select the Output Compare Mode */
;;;4787     tmpccmrx |= OC_Config->OCMode;
;;;4788   
;;;4789     /* Reset the Output Polarity level */
;;;4790     tmpccer &= ~TIM_CCER_CC3P;
000010  f4237300          BIC      r3,r3,#0x200
000014  f0240573          BIC      r5,r4,#0x73           ;4785
000018  680c              LDR      r4,[r1,#0]            ;4787
00001a  432c              ORRS     r4,r4,r5              ;4787
;;;4791     /* Set the Output Compare Polarity */
;;;4792     tmpccer |= (OC_Config->OCPolarity << 8U);
00001c  688d              LDR      r5,[r1,#8]
00001e  ea432305          ORR      r3,r3,r5,LSL #8
;;;4793   
;;;4794     if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
000022  4d0c              LDR      r5,|L98.84|
000024  42a8              CMP      r0,r5
000026  d10e              BNE      |L98.70|
;;;4795     {
;;;4796       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;4797   
;;;4798       /* Reset the Output N Polarity level */
;;;4799       tmpccer &= ~TIM_CCER_CC3NP;
;;;4800       /* Set the Output N Polarity */
;;;4801       tmpccer |= (OC_Config->OCNPolarity << 8U);
000028  68cd              LDR      r5,[r1,#0xc]
00002a  f4236300          BIC      r3,r3,#0x800          ;4799
00002e  ea432305          ORR      r3,r3,r5,LSL #8
;;;4802       /* Reset the Output N State */
;;;4803       tmpccer &= ~TIM_CCER_CC3NE;
;;;4804     }
;;;4805   
;;;4806     if(IS_TIM_BREAK_INSTANCE(TIMx))
;;;4807     {
;;;4808       /* Check parameters */
;;;4809       assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
;;;4810       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;4811   
;;;4812       /* Reset the Output Compare and Output Compare N IDLE State */
;;;4813       tmpcr2 &= ~TIM_CR2_OIS3;
;;;4814       tmpcr2 &= ~TIM_CR2_OIS3N;
;;;4815       /* Set the Output Idle state */
;;;4816       tmpcr2 |= (OC_Config->OCIdleState << 4U);
000032  694d              LDR      r5,[r1,#0x14]
000034  f4225240          BIC      r2,r2,#0x3000         ;4814
000038  ea421205          ORR      r2,r2,r5,LSL #4
;;;4817       /* Set the Output N Idle state */
;;;4818       tmpcr2 |= (OC_Config->OCNIdleState << 4U);
00003c  698d              LDR      r5,[r1,#0x18]
00003e  f4236380          BIC      r3,r3,#0x400          ;4803
000042  ea421205          ORR      r2,r2,r5,LSL #4
                  |L98.70|
;;;4819     }
;;;4820   
;;;4821     /* Write to TIMx CR2 */
;;;4822     TIMx->CR2 = tmpcr2;
000046  6042              STR      r2,[r0,#4]
;;;4823   
;;;4824     /* Write to TIMx CCMR2 */
;;;4825     TIMx->CCMR2 = tmpccmrx;
000048  61c4              STR      r4,[r0,#0x1c]
;;;4826   
;;;4827     /* Set the Capture Compare Register value */
;;;4828     TIMx->CCR3 = OC_Config->Pulse;
00004a  6849              LDR      r1,[r1,#4]
00004c  63c1              STR      r1,[r0,#0x3c]
;;;4829   
;;;4830     /* Write to TIMx CCER */
;;;4831     TIMx->CCER = tmpccer;
00004e  6203              STR      r3,[r0,#0x20]
;;;4832   }
000050  bd30              POP      {r4,r5,pc}
;;;4833   
                          ENDP

000052  0000              DCW      0x0000
                  |L98.84|
                          DCD      0x40012c00

                          AREA ||i.TIM_OC4_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC4_SetConfig PROC
;;;4839     */
;;;4840   static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;4841   {
;;;4842     uint32_t tmpccmrx = 0U;
;;;4843     uint32_t tmpccer = 0U;
;;;4844     uint32_t tmpcr2 = 0U;
;;;4845   
;;;4846     /* Disable the Channel 4: Reset the CC4E Bit */
;;;4847     TIMx->CCER &= ~TIM_CCER_CC4E;
000002  6a02              LDR      r2,[r0,#0x20]
000004  f4225280          BIC      r2,r2,#0x1000
000008  6202              STR      r2,[r0,#0x20]
;;;4848   
;;;4849     /* Get the TIMx CCER register value */
;;;4850     tmpccer = TIMx->CCER;
00000a  6a04              LDR      r4,[r0,#0x20]
;;;4851     /* Get the TIMx CR2 register value */
;;;4852     tmpcr2 =  TIMx->CR2;
00000c  6842              LDR      r2,[r0,#4]
;;;4853   
;;;4854     /* Get the TIMx CCMR2 register value */
;;;4855     tmpccmrx = TIMx->CCMR2;
00000e  69c3              LDR      r3,[r0,#0x1c]
;;;4856   
;;;4857     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;4858     tmpccmrx &= ~TIM_CCMR2_OC4M;
;;;4859     tmpccmrx &= ~TIM_CCMR2_CC4S;
;;;4860   
;;;4861     /* Select the Output Compare Mode */
;;;4862     tmpccmrx |= (OC_Config->OCMode << 8U);
000010  680d              LDR      r5,[r1,#0]
000012  f42343e6          BIC      r3,r3,#0x7300         ;4859
000016  ea432305          ORR      r3,r3,r5,LSL #8
;;;4863   
;;;4864     /* Reset the Output Polarity level */
;;;4865     tmpccer &= ~TIM_CCER_CC4P;
;;;4866     /* Set the Output Compare Polarity */
;;;4867     tmpccer |= (OC_Config->OCPolarity << 12U);
00001a  688d              LDR      r5,[r1,#8]
00001c  f4245400          BIC      r4,r4,#0x2000         ;4865
000020  ea443405          ORR      r4,r4,r5,LSL #12
;;;4868   
;;;4869     if(IS_TIM_BREAK_INSTANCE(TIMx))
000024  4d06              LDR      r5,|L99.64|
000026  42a8              CMP      r0,r5
000028  d104              BNE      |L99.52|
;;;4870     {
;;;4871       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;4872   
;;;4873      /* Reset the Output Compare IDLE State */
;;;4874       tmpcr2 &= ~TIM_CR2_OIS4;
;;;4875       /* Set the Output Idle state */
;;;4876       tmpcr2 |= (OC_Config->OCIdleState << 6);
00002a  694d              LDR      r5,[r1,#0x14]
00002c  f4224280          BIC      r2,r2,#0x4000         ;4874
000030  ea421285          ORR      r2,r2,r5,LSL #6
                  |L99.52|
;;;4877     }
;;;4878   
;;;4879     /* Write to TIMx CR2 */
;;;4880     TIMx->CR2 = tmpcr2;
000034  6042              STR      r2,[r0,#4]
;;;4881   
;;;4882     /* Write to TIMx CCMR2 */
;;;4883     TIMx->CCMR2 = tmpccmrx;
000036  61c3              STR      r3,[r0,#0x1c]
;;;4884   
;;;4885     /* Set the Capture Compare Register value */
;;;4886     TIMx->CCR4 = OC_Config->Pulse;
000038  6849              LDR      r1,[r1,#4]
00003a  6401              STR      r1,[r0,#0x40]
;;;4887   
;;;4888     /* Write to TIMx CCER */
;;;4889     TIMx->CCER = tmpccer;
00003c  6204              STR      r4,[r0,#0x20]
;;;4890   }
00003e  bd30              POP      {r4,r5,pc}
;;;4891   
                          ENDP

                  |L99.64|
                          DCD      0x40012c00

                          AREA ||i.TIM_SlaveTimer_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_SlaveTimer_SetConfig PROC
;;;4899     */
;;;4900   static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
000000  b430              PUSH     {r4,r5}
;;;4901                                 TIM_SlaveConfigTypeDef * sSlaveConfig)
;;;4902   {
;;;4903     uint32_t tmpsmcr = 0U;
;;;4904     uint32_t tmpccmr1 = 0U;
;;;4905     uint32_t tmpccer = 0U;
;;;4906   
;;;4907     /* Get the TIMx SMCR register value */
;;;4908     tmpsmcr = htim->Instance->SMCR;
000002  6803              LDR      r3,[r0,#0]
000004  689a              LDR      r2,[r3,#8]
;;;4909   
;;;4910     /* Reset the Trigger Selection Bits */
;;;4911     tmpsmcr &= ~TIM_SMCR_TS;
000006  f0220470          BIC      r4,r2,#0x70
;;;4912     /* Set the Input Trigger source */
;;;4913     tmpsmcr |= sSlaveConfig->InputTrigger;
00000a  684a              LDR      r2,[r1,#4]
00000c  4322              ORRS     r2,r2,r4
;;;4914   
;;;4915     /* Reset the slave mode Bits */
;;;4916     tmpsmcr &= ~TIM_SMCR_SMS;
00000e  f0220407          BIC      r4,r2,#7
;;;4917     /* Set the slave mode */
;;;4918     tmpsmcr |= sSlaveConfig->SlaveMode;
000012  680a              LDR      r2,[r1,#0]
000014  4322              ORRS     r2,r2,r4
;;;4919   
;;;4920     /* Write to TIMx SMCR */
;;;4921     htim->Instance->SMCR = tmpsmcr;
000016  609a              STR      r2,[r3,#8]
;;;4922   
;;;4923     /* Configure the trigger prescaler, filter, and polarity */
;;;4924     switch (sSlaveConfig->InputTrigger)
000018  684a              LDR      r2,[r1,#4]
00001a  f0120f0f          TST      r2,#0xf
00001e  d11f              BNE      |L100.96|
000020  1112              ASRS     r2,r2,#4
000022  2a08              CMP      r2,#8
000024  d21c              BCS      |L100.96|
000026  e8dff002          TBB      [pc,r2]
00002a  1b1b              DCB      0x1b,0x1b
00002c  1b1b0b1d          DCB      0x1b,0x1b,0x0b,0x1d
000030  2304              DCB      0x23,0x04
;;;4925     {
;;;4926     case TIM_TS_ETRF:
;;;4927       {
;;;4928         /* Check the parameters */
;;;4929         assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
;;;4930         assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
;;;4931         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;4932         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4933         /* Configure the ETR Trigger source */
;;;4934         TIM_ETR_SetConfig(htim->Instance,
000032  690b              LDR      r3,[r1,#0x10]
000034  e9d12102          LDRD     r2,r1,[r1,#8]
000038  6800              LDR      r0,[r0,#0]
00003a  bc30              POP      {r4,r5}
00003c  f7ffbffe          B.W      TIM_ETR_SetConfig
;;;4935                           sSlaveConfig->TriggerPrescaler,
;;;4936                           sSlaveConfig->TriggerPolarity,
;;;4937                           sSlaveConfig->TriggerFilter);
;;;4938       }
;;;4939       break;
;;;4940   
;;;4941     case TIM_TS_TI1F_ED:
;;;4942       {
;;;4943         /* Check the parameters */
;;;4944         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4945         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4946   
;;;4947         /* Disable the Channel 1: Reset the CC1E Bit */
;;;4948         tmpccer = htim->Instance->CCER;
000040  6802              LDR      r2,[r0,#0]
000042  6a13              LDR      r3,[r2,#0x20]
;;;4949         htim->Instance->CCER &= ~TIM_CCER_CC1E;
000044  6a14              LDR      r4,[r2,#0x20]
000046  f0240401          BIC      r4,r4,#1
00004a  6214              STR      r4,[r2,#0x20]
;;;4950         tmpccmr1 = htim->Instance->CCMR1;
00004c  6802              LDR      r2,[r0,#0]
00004e  6994              LDR      r4,[r2,#0x18]
;;;4951   
;;;4952         /* Set the filter */
;;;4953         tmpccmr1 &= ~TIM_CCMR1_IC1F;
;;;4954         tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4U);
000050  6909              LDR      r1,[r1,#0x10]
000052  f02404f0          BIC      r4,r4,#0xf0           ;4953
000056  ea441101          ORR      r1,r4,r1,LSL #4
;;;4955   
;;;4956         /* Write to TIMx CCMR1 and CCER registers */
;;;4957         htim->Instance->CCMR1 = tmpccmr1;
00005a  6191              STR      r1,[r2,#0x18]
;;;4958         htim->Instance->CCER = tmpccer;
00005c  6800              LDR      r0,[r0,#0]
00005e  6203              STR      r3,[r0,#0x20]
                  |L100.96|
;;;4959   
;;;4960       }
;;;4961       break;
;;;4962   
;;;4963     case TIM_TS_TI1FP1:
;;;4964       {
;;;4965         /* Check the parameters */
;;;4966         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4967         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;4968         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4969   
;;;4970         /* Configure TI1 Filter and Polarity */
;;;4971         TIM_TI1_ConfigInputStage(htim->Instance,
;;;4972                                  sSlaveConfig->TriggerPolarity,
;;;4973                                  sSlaveConfig->TriggerFilter);
;;;4974       }
;;;4975       break;
;;;4976   
;;;4977     case TIM_TS_TI2FP2:
;;;4978       {
;;;4979         /* Check the parameters */
;;;4980         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4981         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;4982         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4983   
;;;4984         /* Configure TI2 Filter and Polarity */
;;;4985         TIM_TI2_ConfigInputStage(htim->Instance,
;;;4986                                   sSlaveConfig->TriggerPolarity,
;;;4987                                   sSlaveConfig->TriggerFilter);
;;;4988       }
;;;4989       break;
;;;4990   
;;;4991     case TIM_TS_ITR0:
;;;4992       {
;;;4993         /* Check the parameter */
;;;4994         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4995       }
;;;4996       break;
;;;4997   
;;;4998     case TIM_TS_ITR1:
;;;4999       {
;;;5000         /* Check the parameter */
;;;5001         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5002       }
;;;5003       break;
;;;5004   
;;;5005     case TIM_TS_ITR2:
;;;5006       {
;;;5007         /* Check the parameter */
;;;5008         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5009       }
;;;5010       break;
;;;5011   
;;;5012     case TIM_TS_ITR3:
;;;5013       {
;;;5014         /* Check the parameter */
;;;5015         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5016       }
;;;5017       break;
;;;5018   
;;;5019     default:
;;;5020       break;
;;;5021     }
;;;5022   }
000060  bc30              POP      {r4,r5}
000062  4770              BX       lr
000064  690a              LDR      r2,[r1,#0x10]         ;4971
000066  6889              LDR      r1,[r1,#8]            ;4971
000068  6800              LDR      r0,[r0,#0]            ;4971
00006a  bc30              POP      {r4,r5}               ;4971
00006c  f7ffbffe          B.W      TIM_TI1_ConfigInputStage
000070  690a              LDR      r2,[r1,#0x10]         ;4985
000072  6889              LDR      r1,[r1,#8]            ;4985
000074  6800              LDR      r0,[r0,#0]            ;4985
000076  bc30              POP      {r4,r5}               ;4985
000078  f7ffbffe          B.W      TIM_TI2_ConfigInputStage
;;;5023   
                          ENDP


                          AREA ||i.TIM_TI1_ConfigInputStage||, CODE, READONLY, ALIGN=1

                  TIM_TI1_ConfigInputStage PROC
;;;5088     */
;;;5089   static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
000000  b510              PUSH     {r4,lr}
;;;5090   {
;;;5091     uint32_t tmpccmr1 = 0U;
;;;5092     uint32_t tmpccer = 0U;
;;;5093   
;;;5094     /* Disable the Channel 1: Reset the CC1E Bit */
;;;5095     tmpccer = TIMx->CCER;
000002  6a03              LDR      r3,[r0,#0x20]
;;;5096     TIMx->CCER &= ~TIM_CCER_CC1E;
000004  6a04              LDR      r4,[r0,#0x20]
000006  f0240401          BIC      r4,r4,#1
00000a  6204              STR      r4,[r0,#0x20]
;;;5097     tmpccmr1 = TIMx->CCMR1;
00000c  6984              LDR      r4,[r0,#0x18]
;;;5098   
;;;5099     /* Set the filter */
;;;5100     tmpccmr1 &= ~TIM_CCMR1_IC1F;
00000e  f02404f0          BIC      r4,r4,#0xf0
;;;5101     tmpccmr1 |= (TIM_ICFilter << 4U);
000012  ea441402          ORR      r4,r4,r2,LSL #4
;;;5102   
;;;5103     /* Select the Polarity and set the CC1E Bit */
;;;5104     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
000016  f023020a          BIC      r2,r3,#0xa
;;;5105     tmpccer |= TIM_ICPolarity;
00001a  430a              ORRS     r2,r2,r1
;;;5106   
;;;5107     /* Write to TIMx CCMR1 and CCER registers */
;;;5108     TIMx->CCMR1 = tmpccmr1;
00001c  6184              STR      r4,[r0,#0x18]
;;;5109     TIMx->CCER = tmpccer;
00001e  6202              STR      r2,[r0,#0x20]
;;;5110   }
000020  bd10              POP      {r4,pc}
;;;5111   
                          ENDP


                          AREA ||i.TIM_TI1_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_TI1_SetConfig PROC
;;;5042     */
;;;5043   void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b570              PUSH     {r4-r6,lr}
;;;5044                          uint32_t TIM_ICFilter)
;;;5045   {
;;;5046     uint32_t tmpccmr1 = 0U;
;;;5047     uint32_t tmpccer = 0U;
;;;5048   
;;;5049     /* Disable the Channel 1: Reset the CC1E Bit */
;;;5050     TIMx->CCER &= ~TIM_CCER_CC1E;
000002  6a04              LDR      r4,[r0,#0x20]
000004  f0240401          BIC      r4,r4,#1
000008  6204              STR      r4,[r0,#0x20]
;;;5051     tmpccmr1 = TIMx->CCMR1;
00000a  6984              LDR      r4,[r0,#0x18]
;;;5052     tmpccer = TIMx->CCER;
00000c  6a05              LDR      r5,[r0,#0x20]
;;;5053   
;;;5054     /* Select the Input */
;;;5055     if(IS_TIM_CC2_INSTANCE(TIMx) != RESET)
00000e  4e0f              LDR      r6,|L102.76|
000010  42b0              CMP      r0,r6
000012  d008              BEQ      |L102.38|
000014  f1b04f80          CMP      r0,#0x40000000
000018  d005              BEQ      |L102.38|
00001a  4e0d              LDR      r6,|L102.80|
00001c  42b0              CMP      r0,r6
00001e  d002              BEQ      |L102.38|
000020  4e0c              LDR      r6,|L102.84|
000022  42b0              CMP      r0,r6
000024  d103              BNE      |L102.46|
                  |L102.38|
;;;5056     {
;;;5057       tmpccmr1 &= ~TIM_CCMR1_CC1S;
000026  f0240403          BIC      r4,r4,#3
;;;5058       tmpccmr1 |= TIM_ICSelection;
00002a  4314              ORRS     r4,r4,r2
00002c  e001              B        |L102.50|
                  |L102.46|
;;;5059     }
;;;5060     else
;;;5061     {
;;;5062       tmpccmr1 |= TIM_CCMR1_CC1S_0;
00002e  f0440401          ORR      r4,r4,#1
                  |L102.50|
;;;5063     }
;;;5064   
;;;5065     /* Set the filter */
;;;5066     tmpccmr1 &= ~TIM_CCMR1_IC1F;
000032  071a              LSLS     r2,r3,#28
000034  f02404f0          BIC      r4,r4,#0xf0
;;;5067     tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
000038  ea446212          ORR      r2,r4,r2,LSR #24
;;;5068   
;;;5069     /* Select the Polarity and set the CC1E Bit */
;;;5070     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
00003c  f025030a          BIC      r3,r5,#0xa
;;;5071     tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
000040  f001010a          AND      r1,r1,#0xa
000044  4319              ORRS     r1,r1,r3
;;;5072   
;;;5073     /* Write to TIMx CCMR1 and CCER registers */
;;;5074     TIMx->CCMR1 = tmpccmr1;
000046  6182              STR      r2,[r0,#0x18]
;;;5075     TIMx->CCER = tmpccer;
000048  6201              STR      r1,[r0,#0x20]
;;;5076   }
00004a  bd70              POP      {r4-r6,pc}
;;;5077   
                          ENDP

                  |L102.76|
                          DCD      0x40012c00
                  |L102.80|
                          DCD      0x40000400
                  |L102.84|
                          DCD      0x40000800

                          AREA ||i.TIM_TI2_ConfigInputStage||, CODE, READONLY, ALIGN=1

                  TIM_TI2_ConfigInputStage PROC
;;;5169     */
;;;5170   static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
000000  b510              PUSH     {r4,lr}
;;;5171   {
;;;5172     uint32_t tmpccmr1 = 0U;
;;;5173     uint32_t tmpccer = 0U;
;;;5174   
;;;5175     /* Disable the Channel 2: Reset the CC2E Bit */
;;;5176     TIMx->CCER &= ~TIM_CCER_CC2E;
000002  6a03              LDR      r3,[r0,#0x20]
000004  f0230310          BIC      r3,r3,#0x10
000008  6203              STR      r3,[r0,#0x20]
;;;5177     tmpccmr1 = TIMx->CCMR1;
00000a  6983              LDR      r3,[r0,#0x18]
;;;5178     tmpccer = TIMx->CCER;
00000c  6a04              LDR      r4,[r0,#0x20]
;;;5179   
;;;5180     /* Set the filter */
;;;5181     tmpccmr1 &= ~TIM_CCMR1_IC2F;
00000e  f4234370          BIC      r3,r3,#0xf000
;;;5182     tmpccmr1 |= (TIM_ICFilter << 12U);
000012  ea433202          ORR      r2,r3,r2,LSL #12
;;;5183   
;;;5184     /* Select the Polarity and set the CC2E Bit */
;;;5185     tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
000016  f02403a0          BIC      r3,r4,#0xa0
;;;5186     tmpccer |= (TIM_ICPolarity << 4U);
00001a  ea431101          ORR      r1,r3,r1,LSL #4
;;;5187   
;;;5188     /* Write to TIMx CCMR1 and CCER registers */
;;;5189     TIMx->CCMR1 = tmpccmr1 ;
00001e  6182              STR      r2,[r0,#0x18]
;;;5190     TIMx->CCER = tmpccer;
000020  6201              STR      r1,[r0,#0x20]
;;;5191   }
000022  bd10              POP      {r4,pc}
;;;5192   
                          ENDP


                          AREA ||i.TIM_TI2_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_TI2_SetConfig PROC
;;;5130     */
;;;5131   static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b530              PUSH     {r4,r5,lr}
;;;5132                          uint32_t TIM_ICFilter)
;;;5133   {
;;;5134     uint32_t tmpccmr1 = 0U;
;;;5135     uint32_t tmpccer = 0U;
;;;5136   
;;;5137     /* Disable the Channel 2: Reset the CC2E Bit */
;;;5138     TIMx->CCER &= ~TIM_CCER_CC2E;
000002  6a04              LDR      r4,[r0,#0x20]
000004  f0240410          BIC      r4,r4,#0x10
000008  6204              STR      r4,[r0,#0x20]
;;;5139     tmpccmr1 = TIMx->CCMR1;
00000a  6984              LDR      r4,[r0,#0x18]
;;;5140     tmpccer = TIMx->CCER;
00000c  6a05              LDR      r5,[r0,#0x20]
;;;5141   
;;;5142     /* Select the Input */
;;;5143     tmpccmr1 &= ~TIM_CCMR1_CC2S;
00000e  f4247440          BIC      r4,r4,#0x300
;;;5144     tmpccmr1 |= (TIM_ICSelection << 8U);
000012  ea442202          ORR      r2,r4,r2,LSL #8
;;;5145   
;;;5146     /* Set the filter */
;;;5147     tmpccmr1 &= ~TIM_CCMR1_IC2F;
000016  f4224470          BIC      r4,r2,#0xf000
;;;5148     tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
00001a  f64f72ff          MOV      r2,#0xffff
00001e  ea023203          AND      r2,r2,r3,LSL #12
000022  4322              ORRS     r2,r2,r4
;;;5149   
;;;5150     /* Select the Polarity and set the CC2E Bit */
;;;5151     tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
;;;5152     tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
000024  24a0              MOVS     r4,#0xa0
000026  f02503a0          BIC      r3,r5,#0xa0           ;5151
00002a  ea041101          AND      r1,r4,r1,LSL #4
00002e  4319              ORRS     r1,r1,r3
;;;5153   
;;;5154     /* Write to TIMx CCMR1 and CCER registers */
;;;5155     TIMx->CCMR1 = tmpccmr1 ;
000030  6182              STR      r2,[r0,#0x18]
;;;5156     TIMx->CCER = tmpccer;
000032  6201              STR      r1,[r0,#0x20]
;;;5157   }
000034  bd30              POP      {r4,r5,pc}
;;;5158   
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_tim.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_tim_c_a9d95b52____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___19_stm32f1xx_hal_tim_c_a9d95b52____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_tim_c_a9d95b52____REVSH|
#line 402
|__asm___19_stm32f1xx_hal_tim_c_a9d95b52____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_tim_c_a9d95b52____RRX|
#line 587
|__asm___19_stm32f1xx_hal_tim_c_a9d95b52____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
