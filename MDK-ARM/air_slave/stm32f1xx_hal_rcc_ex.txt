; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\stm32f1xx_hal_rcc_ex.o --asm_dir=.\air_slave\ --list_dir=.\air_slave\ --depend=.\stm32f1xx_hal_rcc_ex.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I.\RTE\_air_slave -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=525 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=.\stm32f1xx_hal_rcc_ex.crf ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_rcc_ex.c]
                          THUMB

                          AREA ||i.HAL_RCCEx_GetPeriphCLKConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_GetPeriphCLKConfig PROC
;;;309      */
;;;310    void HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
000000  2101              MOVS     r1,#1
;;;311    {
;;;312      uint32_t srcclk = 0U;
;;;313      
;;;314      /* Set all possible values for the extended clock type parameter------------*/
;;;315      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_RTC;
;;;316    
;;;317      /* Get the RTC configuration -----------------------------------------------*/
;;;318      srcclk = __HAL_RCC_GET_RTC_SOURCE();
000002  6001              STR      r1,[r0,#0]
000004  4908              LDR      r1,|L1.40|
000006  6a0a              LDR      r2,[r1,#0x20]
000008  f4027240          AND      r2,r2,#0x300
;;;319      /* Source clock is LSE or LSI*/
;;;320      PeriphClkInit->RTCClockSelection = srcclk;
;;;321    
;;;322      /* Get the ADC clock configuration -----------------------------------------*/
;;;323      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_ADC;
00000c  6042              STR      r2,[r0,#4]
00000e  2203              MOVS     r2,#3
;;;324      PeriphClkInit->AdcClockSelection = __HAL_RCC_GET_ADC_SOURCE();
000010  6002              STR      r2,[r0,#0]
000012  684a              LDR      r2,[r1,#4]
000014  f4024240          AND      r2,r2,#0xc000
;;;325    
;;;326    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;327      /* Get the I2S2 clock configuration -----------------------------------------*/
;;;328      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2S2;
;;;329      PeriphClkInit->I2s2ClockSelection = __HAL_RCC_GET_I2S2_SOURCE();
;;;330    
;;;331      /* Get the I2S3 clock configuration -----------------------------------------*/
;;;332      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2S3;
;;;333      PeriphClkInit->I2s3ClockSelection = __HAL_RCC_GET_I2S3_SOURCE();
;;;334    
;;;335    #endif /* STM32F105xC || STM32F107xC */
;;;336    
;;;337    #if defined(STM32F103xE) || defined(STM32F103xG)
;;;338      /* Get the I2S2 clock configuration -----------------------------------------*/
;;;339      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2S2;
;;;340      PeriphClkInit->I2s2ClockSelection = RCC_I2S2CLKSOURCE_SYSCLK;
;;;341    
;;;342      /* Get the I2S3 clock configuration -----------------------------------------*/
;;;343      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2S3;
;;;344      PeriphClkInit->I2s3ClockSelection = RCC_I2S3CLKSOURCE_SYSCLK;
;;;345    
;;;346    #endif /* STM32F103xE || STM32F103xG */
;;;347    
;;;348    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
;;;349     || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
;;;350     || defined(STM32F105xC) || defined(STM32F107xC)
;;;351      /* Get the USB clock configuration -----------------------------------------*/
;;;352      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_USB;
000018  6082              STR      r2,[r0,#8]
00001a  2213              MOVS     r2,#0x13
;;;353      PeriphClkInit->UsbClockSelection = __HAL_RCC_GET_USB_SOURCE();
00001c  6002              STR      r2,[r0,#0]
00001e  6849              LDR      r1,[r1,#4]
000020  f4010180          AND      r1,r1,#0x400000
000024  60c1              STR      r1,[r0,#0xc]
;;;354    #endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;355    }
000026  4770              BX       lr
;;;356    
                          ENDP

                  |L1.40|
                          DCD      0x40021000

                          AREA ||i.HAL_RCCEx_GetPeriphCLKFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_GetPeriphCLKFreq PROC
;;;402      */
;;;403    uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
000000  b510              PUSH     {r4,lr}
;;;404    {
;;;405    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;406      const uint8_t aPLLMULFactorTable[14] = {0, 0, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 13};
;;;407      const uint8_t aPredivFactorTable[16] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
;;;408    
;;;409      uint32_t prediv1 = 0U, pllclk = 0U, pllmul = 0U;
;;;410      uint32_t pll2mul = 0U, pll3mul = 0U, prediv2 = 0U;
;;;411    #endif /* STM32F105xC || STM32F107xC */
;;;412    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6) || \
;;;413        defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)
;;;414      const uint8_t aPLLMULFactorTable[16] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16};
000002  a429              ADR      r4,|L2.168|
000004  4601              MOV      r1,r0                 ;404
000006  cc1d              LDM      r4,{r0,r2-r4}
000008  b086              SUB      sp,sp,#0x18           ;404
00000a  e88d001d          STM      sp,{r0,r2-r4}
;;;415      const uint8_t aPredivFactorTable[2] = {1, 2};
00000e  a02a              ADR      r0,|L2.184|
;;;416    
;;;417      uint32_t prediv1 = 0U, pllclk = 0U, pllmul = 0U;
;;;418    #endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG */
;;;419      uint32_t temp_reg = 0U, frequency = 0U;
;;;420    
;;;421      /* Check the parameters */
;;;422      assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));
;;;423      
;;;424      switch (PeriphClk)
;;;425      {
;;;426    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
;;;427     || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
;;;428     || defined(STM32F105xC) || defined(STM32F107xC)
;;;429      case RCC_PERIPHCLK_USB:  
;;;430        {
;;;431          /* Get RCC configuration ------------------------------------------------------*/
;;;432          temp_reg = RCC->CFGR;
000010  4c2a              LDR      r4,|L2.188|
000012  6800              LDR      r0,[r0,#0]            ;415
000014  9004              STR      r0,[sp,#0x10]         ;419
000016  2000              MOVS     r0,#0                 ;419
000018  2901              CMP      r1,#1                 ;424
00001a  d023              BEQ      |L2.100|
00001c  2902              CMP      r1,#2                 ;424
00001e  d03a              BEQ      |L2.150|
000020  2910              CMP      r1,#0x10              ;424
000022  d11d              BNE      |L2.96|
000024  6861              LDR      r1,[r4,#4]
;;;433      
;;;434          /* Check if PLL is enabled */
;;;435          if (HAL_IS_BIT_SET(RCC->CR,RCC_CR_PLLON))
000026  6822              LDR      r2,[r4,#0]
000028  01d2              LSLS     r2,r2,#7
00002a  d519              BPL      |L2.96|
;;;436          {
;;;437            pllmul = aPLLMULFactorTable[(uint32_t)(temp_reg & RCC_CFGR_PLLMULL) >> RCC_CFGR_PLLMULL_Pos];
00002c  f3c14283          UBFX     r2,r1,#18,#4
;;;438            if ((temp_reg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
000030  03c9              LSLS     r1,r1,#15
000032  f81d0002          LDRB     r0,[sp,r2]            ;437
000036  d509              BPL      |L2.76|
;;;439            {
;;;440    #if defined(STM32F105xC) || defined(STM32F107xC) || defined(STM32F100xB)\
;;;441     || defined(STM32F100xE)
;;;442              prediv1 = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV1) >> RCC_CFGR2_PREDIV1_Pos];
;;;443    #else
;;;444              prediv1 = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos];
000038  6861              LDR      r1,[r4,#4]
00003a  aa04              ADD      r2,sp,#0x10
00003c  f3c14140          UBFX     r1,r1,#17,#1
000040  5c51              LDRB     r1,[r2,r1]
;;;445    #endif /* STM32F105xC || STM32F107xC || STM32F100xB || STM32F100xE */
;;;446    
;;;447    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;448              if(HAL_IS_BIT_SET(RCC->CFGR2, RCC_CFGR2_PREDIV1SRC))
;;;449              {
;;;450                /* PLL2 selected as Prediv1 source */
;;;451                /* PLLCLK = PLL2CLK / PREDIV1 * PLLMUL with PLL2CLK = HSE/PREDIV2 * PLL2MUL */
;;;452                prediv2 = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> RCC_CFGR2_PREDIV2_Pos) + 1;
;;;453                pll2mul = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> RCC_CFGR2_PLL2MUL_Pos) + 2;
;;;454                pllclk = (uint32_t)((((HSE_VALUE / prediv2) * pll2mul) / prediv1) * pllmul);
;;;455              }
;;;456              else
;;;457              {
;;;458                /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
;;;459                pllclk = (uint32_t)((HSE_VALUE / prediv1) * pllmul);
;;;460              }
;;;461              
;;;462              /* If PLLMUL was set to 13 means that it was to cover the case PLLMUL 6.5 (avoid using float) */
;;;463              /* In this case need to divide pllclk by 2 */
;;;464              if (pllmul == aPLLMULFactorTable[(uint32_t)(RCC_CFGR_PLLMULL6_5) >> RCC_CFGR_PLLMULL_Pos])
;;;465              {
;;;466                  pllclk = pllclk / 2;
;;;467              }
;;;468    #else
;;;469              if ((temp_reg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
;;;470              {
;;;471                /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
;;;472                pllclk = (uint32_t)((HSE_VALUE / prediv1) * pllmul);
000042  4a1f              LDR      r2,|L2.192|
000044  fbb2f1f1          UDIV     r1,r2,r1
000048  4348              MULS     r0,r1,r0
00004a  e001              B        |L2.80|
                  |L2.76|
;;;473              }
;;;474    #endif /* STM32F105xC || STM32F107xC */
;;;475            }
;;;476            else
;;;477            {
;;;478              /* HSI used as PLL clock source : PLLCLK = HSI/2 * PLLMUL */
;;;479              pllclk = (uint32_t)((HSI_VALUE >> 1) * pllmul);
00004c  491d              LDR      r1,|L2.196|
00004e  4348              MULS     r0,r1,r0
                  |L2.80|
;;;480            }
;;;481    
;;;482            /* Calcul of the USB frequency*/
;;;483    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;484            /* USBCLK = PLLVCO = (2 x PLLCLK) / USB prescaler */
;;;485            if (__HAL_RCC_GET_USB_SOURCE() == RCC_USBCLKSOURCE_PLL_DIV2)
;;;486            {
;;;487              /* Prescaler of 2 selected for USB */ 
;;;488              frequency = pllclk;
;;;489            }
;;;490            else
;;;491            {
;;;492              /* Prescaler of 3 selected for USB */ 
;;;493              frequency = (2 * pllclk) / 3;
;;;494            }
;;;495    #else
;;;496            /* USBCLK = PLLCLK / USB prescaler */
;;;497            if (__HAL_RCC_GET_USB_SOURCE() == RCC_USBCLKSOURCE_PLL)
000050  6861              LDR      r1,[r4,#4]
000052  0249              LSLS     r1,r1,#9
000054  d404              BMI      |L2.96|
;;;498            {
;;;499              /* No prescaler selected for USB */
;;;500              frequency = pllclk;
;;;501            }
;;;502            else
;;;503            {
;;;504              /* Prescaler of 1.5 selected for USB */ 
;;;505              frequency = (pllclk * 2) / 3;
000056  0040              LSLS     r0,r0,#1
000058  f05f0103          MOVS.W   r1,#3
                  |L2.92|
;;;506            }
;;;507    #endif
;;;508          }
;;;509          break;
;;;510        }
;;;511    #endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;512    #if defined(STM32F103xE) || defined(STM32F103xG) || defined(STM32F105xC) || defined(STM32F107xC)
;;;513      case RCC_PERIPHCLK_I2S2:  
;;;514        {
;;;515    #if defined(STM32F103xE) || defined(STM32F103xG)
;;;516          /* SYSCLK used as source clock for I2S2 */
;;;517          frequency = HAL_RCC_GetSysClockFreq();
;;;518    #else
;;;519          if (__HAL_RCC_GET_I2S2_SOURCE() == RCC_I2S2CLKSOURCE_SYSCLK)
;;;520          {
;;;521            /* SYSCLK used as source clock for I2S2 */
;;;522            frequency = HAL_RCC_GetSysClockFreq();
;;;523          }
;;;524          else
;;;525          {
;;;526             /* Check if PLLI2S is enabled */
;;;527            if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3ON))
;;;528            {
;;;529              /* PLLI2SVCO = 2 * PLLI2SCLK = 2 * (HSE/PREDIV2 * PLL3MUL) */
;;;530              prediv2 = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> RCC_CFGR2_PREDIV2_Pos) + 1;
;;;531              pll3mul = ((RCC->CFGR2 & RCC_CFGR2_PLL3MUL) >> RCC_CFGR2_PLL3MUL_Pos) + 2;
;;;532              frequency = (uint32_t)(2 * ((HSE_VALUE / prediv2) * pll3mul));
;;;533            }
;;;534          }
;;;535    #endif /* STM32F103xE || STM32F103xG */
;;;536          break;
;;;537        }
;;;538      case RCC_PERIPHCLK_I2S3:
;;;539        {
;;;540    #if defined(STM32F103xE) || defined(STM32F103xG)
;;;541          /* SYSCLK used as source clock for I2S3 */
;;;542          frequency = HAL_RCC_GetSysClockFreq();
;;;543    #else
;;;544          if (__HAL_RCC_GET_I2S3_SOURCE() == RCC_I2S3CLKSOURCE_SYSCLK)
;;;545          {
;;;546            /* SYSCLK used as source clock for I2S3 */
;;;547            frequency = HAL_RCC_GetSysClockFreq();
;;;548          }
;;;549          else
;;;550          {
;;;551             /* Check if PLLI2S is enabled */
;;;552            if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3ON))
;;;553            {
;;;554              /* PLLI2SVCO = 2 * PLLI2SCLK = 2 * (HSE/PREDIV2 * PLL3MUL) */
;;;555              prediv2 = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> RCC_CFGR2_PREDIV2_Pos) + 1;
;;;556              pll3mul = ((RCC->CFGR2 & RCC_CFGR2_PLL3MUL) >> RCC_CFGR2_PLL3MUL_Pos) + 2;
;;;557              frequency = (uint32_t)(2 * ((HSE_VALUE / prediv2) * pll3mul));
;;;558            }
;;;559          }
;;;560    #endif /* STM32F103xE || STM32F103xG */
;;;561          break;
;;;562        }
;;;563    #endif /* STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;564      case RCC_PERIPHCLK_RTC:  
;;;565        {
;;;566          /* Get RCC BDCR configuration ------------------------------------------------------*/
;;;567          temp_reg = RCC->BDCR;
;;;568    
;;;569          /* Check if LSE is ready if RTC clock selection is LSE */
;;;570          if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_LSE) && (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSERDY)))
;;;571          {
;;;572            frequency = LSE_VALUE;
;;;573          }
;;;574          /* Check if LSI is ready if RTC clock selection is LSI */
;;;575          else if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_LSI) && (HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY)))
;;;576          {
;;;577            frequency = LSI_VALUE;
;;;578          }
;;;579          else if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_HSE_DIV128) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)))
;;;580          {
;;;581            frequency = HSE_VALUE / 128U;
;;;582          }
;;;583          /* Clock not enabled for RTC*/
;;;584          else
;;;585          {
;;;586            frequency = 0U;
;;;587          }
;;;588          break;
;;;589        }
;;;590      case RCC_PERIPHCLK_ADC:  
;;;591        {
;;;592          frequency = HAL_RCC_GetPCLK2Freq() / (((__HAL_RCC_GET_ADC_SOURCE() >> RCC_CFGR_ADCPRE_Pos) + 1) * 2);
00005c  fbb0f0f1          UDIV     r0,r0,r1
                  |L2.96|
;;;593          break;
;;;594        }
;;;595      default: 
;;;596        {
;;;597          break;
;;;598        }
;;;599      }
;;;600      return(frequency);
;;;601    }
000060  b006              ADD      sp,sp,#0x18
000062  bd10              POP      {r4,pc}
                  |L2.100|
000064  6a22              LDR      r2,[r4,#0x20]         ;567
000066  f3c22101          UBFX     r1,r2,#8,#2           ;570
00006a  2901              CMP      r1,#1                 ;570
00006c  d103              BNE      |L2.118|
00006e  0792              LSLS     r2,r2,#30             ;570
000070  d501              BPL      |L2.118|
000072  03c8              LSLS     r0,r1,#15             ;572
000074  e7f4              B        |L2.96|
                  |L2.118|
000076  2902              CMP      r1,#2                 ;575
000078  d105              BNE      |L2.134|
00007a  6a62              LDR      r2,[r4,#0x24]         ;575
00007c  0792              LSLS     r2,r2,#30             ;575
00007e  d502              BPL      |L2.134|
000080  f6494040          MOV      r0,#0x9c40            ;577
000084  e7ec              B        |L2.96|
                  |L2.134|
000086  2903              CMP      r1,#3                 ;579
000088  d1ea              BNE      |L2.96|
00008a  6821              LDR      r1,[r4,#0]            ;579
00008c  0389              LSLS     r1,r1,#14             ;579
00008e  d5e7              BPL      |L2.96|
000090  f24f4024          MOV      r0,#0xf424            ;581
000094  e7e4              B        |L2.96|
                  |L2.150|
000096  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00009a  6861              LDR      r1,[r4,#4]            ;592
00009c  f3c13181          UBFX     r1,r1,#14,#2          ;592
0000a0  1c49              ADDS     r1,r1,#1              ;592
0000a2  0049              LSLS     r1,r1,#1              ;592
0000a4  e7da              B        |L2.92|
;;;602    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L2.168|
0000a8  02030405          DCB      2,3,4,5,6,"\a\b\t\n\v\f\r",14,15,16,16
0000ac  06070809
0000b0  0a0b0c0d
0000b4  0e0f1010
                  |L2.184|
0000b8  010200            DCB      1,2,0
0000bb  00                DCB      0
                  |L2.188|
                          DCD      0x40021000
                  |L2.192|
                          DCD      0x007a1200
                  |L2.196|
                          DCD      0x003d0900

                          AREA ||i.HAL_RCCEx_PeriphCLKConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_PeriphCLKConfig PROC
;;;115      */
;;;116    HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;117    {
000004  4605              MOV      r5,r0
;;;118      uint32_t tickstart = 0U, temp_reg = 0U;
;;;119    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;120      uint32_t  pllactive = 0U;
;;;121    #endif /* STM32F105xC || STM32F107xC */
;;;122    
;;;123      /* Check the parameters */
;;;124      assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
;;;125      
;;;126      /*------------------------------- RTC/LCD Configuration ------------------------*/ 
;;;127      if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))
000006  7800              LDRB     r0,[r0,#0]
;;;128      {
;;;129        /* check for RTC Parameters used to output RTCCLK */
;;;130        assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
;;;131    
;;;132        FlagStatus       pwrclkchanged = RESET;
;;;133    
;;;134        /* As soon as function is called to change RTC clock source, activation of the 
;;;135           power domain is done. */
;;;136        /* Requires to enable write access to Backup Domain of necessary */
;;;137        if(__HAL_RCC_PWR_IS_CLK_DISABLED())
000008  4c35              LDR      r4,|L3.224|
00000a  07c0              LSLS     r0,r0,#31             ;127
00000c  d054              BEQ      |L3.184|
00000e  69e0              LDR      r0,[r4,#0x1c]
000010  2600              MOVS     r6,#0                 ;132
000012  00c0              LSLS     r0,r0,#3
000014  d408              BMI      |L3.40|
;;;138        {
;;;139        __HAL_RCC_PWR_CLK_ENABLE();
000016  69e0              LDR      r0,[r4,#0x1c]
000018  f0405080          ORR      r0,r0,#0x10000000
00001c  61e0              STR      r0,[r4,#0x1c]
00001e  69e0              LDR      r0,[r4,#0x1c]
;;;140          pwrclkchanged = SET;
000020  2601              MOVS     r6,#1
000022  f0005080          AND      r0,r0,#0x10000000     ;139
000026  9000              STR      r0,[sp,#0]
                  |L3.40|
;;;141        }
;;;142        
;;;143        if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
000028  482e              LDR      r0,|L3.228|
00002a  6801              LDR      r1,[r0,#0]
00002c  05c9              LSLS     r1,r1,#23
00002e  d412              BMI      |L3.86|
;;;144        {
;;;145          /* Enable write access to Backup domain */
;;;146          SET_BIT(PWR->CR, PWR_CR_DBP);
000030  6801              LDR      r1,[r0,#0]
000032  4680              MOV      r8,r0
000034  f4417180          ORR      r1,r1,#0x100
000038  6001              STR      r1,[r0,#0]
;;;147          
;;;148          /* Wait for Backup domain Write protection disable */
;;;149          tickstart = HAL_GetTick();
00003a  f7fffffe          BL       HAL_GetTick
00003e  4607              MOV      r7,r0
;;;150          
;;;151          while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
000040  e005              B        |L3.78|
;;;152          {
;;;153            if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
000042  bf00              NOP      
                  |L3.68|
000044  f7fffffe          BL       HAL_GetTick
000048  1bc0              SUBS     r0,r0,r7
00004a  2864              CMP      r0,#0x64
00004c  d823              BHI      |L3.150|
                  |L3.78|
00004e  f8d80000          LDR      r0,[r8,#0]            ;151
000052  05c0              LSLS     r0,r0,#23             ;151
000054  d5f6              BPL      |L3.68|
                  |L3.86|
;;;154            {
;;;155              return HAL_TIMEOUT;
;;;156            }
;;;157          }
;;;158        }
;;;159          
;;;160        /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */ 
;;;161        temp_reg = (RCC->BDCR & RCC_BDCR_RTCSEL);
000056  6a20              LDR      r0,[r4,#0x20]
000058  f4107040          ANDS     r0,r0,#0x300
;;;162        if((temp_reg != 0x00000000U) && (temp_reg != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
00005c  d021              BEQ      |L3.162|
00005e  88a9              LDRH     r1,[r5,#4]
000060  f4017140          AND      r1,r1,#0x300
000064  4281              CMP      r1,r0
000066  d01c              BEQ      |L3.162|
;;;163        {
;;;164          /* Store the content of BDCR register before the reset of Backup Domain */
;;;165          temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
000068  6a20              LDR      r0,[r4,#0x20]
;;;166          /* RTC Clock selection can be changed only if the Backup Domain is reset */
;;;167          __HAL_RCC_BACKUPRESET_FORCE();
00006a  491f              LDR      r1,|L3.232|
00006c  2201              MOVS     r2,#1
00006e  f4207040          BIC      r0,r0,#0x300          ;165
000072  600a              STR      r2,[r1,#0]
;;;168          __HAL_RCC_BACKUPRESET_RELEASE();
000074  2200              MOVS     r2,#0
000076  600a              STR      r2,[r1,#0]
;;;169          /* Restore the Content of BDCR register */
;;;170          RCC->BDCR = temp_reg;
000078  6220              STR      r0,[r4,#0x20]
;;;171    
;;;172          /* Wait for LSERDY if LSE was enabled */
;;;173          if (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSEON))
00007a  07c0              LSLS     r0,r0,#31
00007c  d011              BEQ      |L3.162|
;;;174          {
;;;175            /* Get Start Tick */
;;;176            tickstart = HAL_GetTick();
00007e  f7fffffe          BL       HAL_GetTick
000082  4607              MOV      r7,r0
;;;177          
;;;178            /* Wait till LSE is ready */  
;;;179            while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
;;;180            {
;;;181              if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
000084  f2413888          MOV      r8,#0x1388
000088  e008              B        |L3.156|
00008a  bf00              NOP      
                  |L3.140|
00008c  f7fffffe          BL       HAL_GetTick
000090  1bc1              SUBS     r1,r0,r7
000092  4541              CMP      r1,r8
000094  d902              BLS      |L3.156|
                  |L3.150|
;;;182              {
;;;183                return HAL_TIMEOUT;
000096  2003              MOVS     r0,#3
                  |L3.152|
;;;184              }      
;;;185            }  
;;;186          }
;;;187        }
;;;188        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection); 
;;;189    
;;;190        /* Require to disable power clock if necessary */
;;;191        if(pwrclkchanged == SET)
;;;192        {
;;;193          __HAL_RCC_PWR_CLK_DISABLE();
;;;194        }
;;;195      }
;;;196    
;;;197      /*------------------------------ ADC clock Configuration ------------------*/ 
;;;198      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
;;;199      {
;;;200        /* Check the parameters */
;;;201        assert_param(IS_RCC_ADCPLLCLK_DIV(PeriphClkInit->AdcClockSelection));
;;;202        
;;;203        /* Configure the ADC clock source */
;;;204        __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
;;;205      }
;;;206    
;;;207    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;208      /*------------------------------ I2S2 Configuration ------------------------*/ 
;;;209      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S2) == RCC_PERIPHCLK_I2S2)
;;;210      {
;;;211        /* Check the parameters */
;;;212        assert_param(IS_RCC_I2S2CLKSOURCE(PeriphClkInit->I2s2ClockSelection));
;;;213    
;;;214        /* Configure the I2S2 clock source */
;;;215        __HAL_RCC_I2S2_CONFIG(PeriphClkInit->I2s2ClockSelection);
;;;216      }
;;;217    
;;;218      /*------------------------------ I2S3 Configuration ------------------------*/ 
;;;219      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S3) == RCC_PERIPHCLK_I2S3)
;;;220      {
;;;221        /* Check the parameters */
;;;222        assert_param(IS_RCC_I2S3CLKSOURCE(PeriphClkInit->I2s3ClockSelection));
;;;223        
;;;224        /* Configure the I2S3 clock source */
;;;225        __HAL_RCC_I2S3_CONFIG(PeriphClkInit->I2s3ClockSelection);
;;;226      }
;;;227    
;;;228      /*------------------------------ PLL I2S Configuration ----------------------*/ 
;;;229      /* Check that PLLI2S need to be enabled */
;;;230      if (HAL_IS_BIT_SET(RCC->CFGR2, RCC_CFGR2_I2S2SRC) || HAL_IS_BIT_SET(RCC->CFGR2, RCC_CFGR2_I2S3SRC))
;;;231      {
;;;232        /* Update flag to indicate that PLL I2S should be active */
;;;233        pllactive = 1;
;;;234      }
;;;235    
;;;236      /* Check if PLL I2S need to be enabled */
;;;237      if (pllactive == 1)
;;;238      {
;;;239        /* Enable PLL I2S only if not active */
;;;240        if (HAL_IS_BIT_CLR(RCC->CR, RCC_CR_PLL3ON))
;;;241        {
;;;242          /* Check the parameters */
;;;243          assert_param(IS_RCC_PLLI2S_MUL(PeriphClkInit->PLLI2S.PLLI2SMUL));
;;;244          assert_param(IS_RCC_HSE_PREDIV2(PeriphClkInit->PLLI2S.HSEPrediv2Value));
;;;245    
;;;246          /* Prediv2 can be written only when the PLL2 is disabled. */
;;;247          /* Return an error only if new value is different from the programmed value */
;;;248          if (HAL_IS_BIT_SET(RCC->CR,RCC_CR_PLL2ON) && \
;;;249            (__HAL_RCC_HSE_GET_PREDIV2() != PeriphClkInit->PLLI2S.HSEPrediv2Value))
;;;250          {
;;;251            return HAL_ERROR;
;;;252          }
;;;253    
;;;254          /* Configure the HSE prediv2 factor --------------------------------*/
;;;255          __HAL_RCC_HSE_PREDIV2_CONFIG(PeriphClkInit->PLLI2S.HSEPrediv2Value);
;;;256    
;;;257          /* Configure the main PLLI2S multiplication factors. */
;;;258          __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SMUL);
;;;259          
;;;260          /* Enable the main PLLI2S. */
;;;261          __HAL_RCC_PLLI2S_ENABLE();
;;;262          
;;;263          /* Get Start Tick*/
;;;264          tickstart = HAL_GetTick();
;;;265          
;;;266          /* Wait till PLLI2S is ready */
;;;267          while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
;;;268          {
;;;269            if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
;;;270            {
;;;271              return HAL_TIMEOUT;
;;;272            }
;;;273          }
;;;274        }
;;;275        else
;;;276        {
;;;277          /* Return an error only if user wants to change the PLLI2SMUL whereas PLLI2S is active */
;;;278          if (READ_BIT(RCC->CFGR2, RCC_CFGR2_PLL3MUL) != PeriphClkInit->PLLI2S.PLLI2SMUL)
;;;279          {
;;;280              return HAL_ERROR;
;;;281          }
;;;282        }
;;;283      }
;;;284    #endif /* STM32F105xC || STM32F107xC */
;;;285    
;;;286    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
;;;287     || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
;;;288     || defined(STM32F105xC) || defined(STM32F107xC)
;;;289      /*------------------------------ USB clock Configuration ------------------*/ 
;;;290      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
;;;291      {
;;;292        /* Check the parameters */
;;;293        assert_param(IS_RCC_USBPLLCLK_DIV(PeriphClkInit->UsbClockSelection));
;;;294        
;;;295        /* Configure the USB clock source */
;;;296        __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
;;;297      }
;;;298    #endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;299    
;;;300      return HAL_OK;
;;;301    }
000098  e8bd83f8          POP      {r3-r9,pc}
                  |L3.156|
00009c  6a20              LDR      r0,[r4,#0x20]         ;179
00009e  0780              LSLS     r0,r0,#30             ;179
0000a0  d5f4              BPL      |L3.140|
                  |L3.162|
0000a2  6a20              LDR      r0,[r4,#0x20]         ;188
0000a4  6869              LDR      r1,[r5,#4]            ;188
0000a6  f4207040          BIC      r0,r0,#0x300          ;188
0000aa  4308              ORRS     r0,r0,r1              ;188
0000ac  6220              STR      r0,[r4,#0x20]         ;188
0000ae  b11e              CBZ      r6,|L3.184|
0000b0  69e0              LDR      r0,[r4,#0x1c]         ;193
0000b2  f0205080          BIC      r0,r0,#0x10000000     ;193
0000b6  61e0              STR      r0,[r4,#0x1c]         ;193
                  |L3.184|
0000b8  7828              LDRB     r0,[r5,#0]            ;198
0000ba  0780              LSLS     r0,r0,#30             ;198
0000bc  d505              BPL      |L3.202|
0000be  6860              LDR      r0,[r4,#4]            ;204
0000c0  68a9              LDR      r1,[r5,#8]            ;204
0000c2  f4204040          BIC      r0,r0,#0xc000         ;204
0000c6  4308              ORRS     r0,r0,r1              ;204
0000c8  6060              STR      r0,[r4,#4]            ;204
                  |L3.202|
0000ca  7828              LDRB     r0,[r5,#0]            ;290
0000cc  06c0              LSLS     r0,r0,#27             ;290
0000ce  d505              BPL      |L3.220|
0000d0  6860              LDR      r0,[r4,#4]            ;296
0000d2  68e9              LDR      r1,[r5,#0xc]          ;296
0000d4  f4200080          BIC      r0,r0,#0x400000       ;296
0000d8  4308              ORRS     r0,r0,r1              ;296
0000da  6060              STR      r0,[r4,#4]            ;296
                  |L3.220|
0000dc  2000              MOVS     r0,#0                 ;300
0000de  e7db              B        |L3.152|
;;;302    
                          ENDP

                  |L3.224|
                          DCD      0x40021000
                  |L3.228|
                          DCD      0x40007000
                  |L3.232|
                          DCD      0x42420440

;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_rcc_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____REVSH|
#line 402
|__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____RRX|
#line 587
|__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
