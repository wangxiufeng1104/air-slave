; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\stm32f1xx_hal_gpio.o --asm_dir=.\air_slave\ --list_dir=.\air_slave\ --depend=.\stm32f1xx_hal_gpio.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I.\RTE\_air_slave -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=525 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=.\stm32f1xx_hal_gpio.crf ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_gpio.c]
                          THUMB

                          AREA ||i.HAL_GPIO_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_DeInit PROC
;;;364      */
;;;365    void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;366    {
;;;367      uint32_t position = 0x00U;
000004  2300              MOVS     r3,#0
;;;368      uint32_t iocurrent = 0x00U;
;;;369      uint32_t tmp = 0x00U;
;;;370      __IO uint32_t *configregister; /* Store the address of CRL or CRH register based on pin number */
;;;371      uint32_t registeroffset = 0U;
;;;372    
;;;373      /* Check the parameters */
;;;374      assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
;;;375      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;376    
;;;377      /* Configure the port pins */
;;;378      while ((GPIO_Pin >> position) != 0U)
;;;379      {
;;;380        /* Get current io position */
;;;381        iocurrent = (GPIO_Pin) & (1U << position);
;;;382    
;;;383        if (iocurrent)
;;;384        {
;;;385          /*------------------------- GPIO Mode Configuration --------------------*/
;;;386          /* Check if the current bit belongs to first half or last half of the pin count number
;;;387           in order to address CRH or CRL register */
;;;388          configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
;;;389          registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2U) : ((position - 8U) << 2U);
;;;390    
;;;391          /* CRL/CRH default value is floating input(0x04) shifted to correct position */
;;;392          MODIFY_REG(*configregister, ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), GPIO_CRL_CNF0_0 << registeroffset);
000006  240f              MOVS     r4,#0xf
;;;393    
;;;394          /* ODR default value is 0 */
;;;395          CLEAR_BIT(GPIOx->ODR, iocurrent);
;;;396    
;;;397          /*------------------------- EXTI Mode Configuration --------------------*/
;;;398          /* Clear the External Interrupt or Event for the current IO */
;;;399    
;;;400          tmp = AFIO->EXTICR[position >> 2U];
000008  f8dfc0c0          LDR      r12,|L1.204|
00000c  e059              B        |L1.194|
                  |L1.14|
00000e  2201              MOVS     r2,#1                 ;381
000010  409a              LSLS     r2,r2,r3              ;381
000012  400a              ANDS     r2,r2,r1              ;381
000014  d054              BEQ      |L1.192|
000016  2aff              CMP      r2,#0xff              ;388
000018  d801              BHI      |L1.30|
00001a  4607              MOV      r7,r0                 ;388
00001c  e001              B        |L1.34|
                  |L1.30|
00001e  f1000704          ADD      r7,r0,#4              ;388
                  |L1.34|
000022  ea4f0683          LSL      r6,r3,#2              ;388
000026  d901              BLS      |L1.44|
000028  f1a60620          SUB      r6,r6,#0x20           ;389
                  |L1.44|
00002c  f8d78000          LDR      r8,[r7,#0]            ;392
000030  fa04f506          LSL      r5,r4,r6              ;392
000034  f04f0904          MOV      r9,#4                 ;392
000038  ea280805          BIC      r8,r8,r5              ;392
00003c  fa09f906          LSL      r9,r9,r6              ;392
000040  ea480809          ORR      r8,r8,r9              ;392
000044  f8c78000          STR      r8,[r7,#0]            ;392
000048  68c5              LDR      r5,[r0,#0xc]          ;395
00004a  ea250502          BIC      r5,r5,r2              ;395
00004e  60c5              STR      r5,[r0,#0xc]          ;395
000050  f0230503          BIC      r5,r3,#3
000054  4465              ADD      r5,r5,r12
000056  68af              LDR      r7,[r5,#8]
;;;401          tmp &= 0x0FU << (4U * (position & 0x03U));
000058  ea4f7683          LSL      r6,r3,#30
00005c  ea4f7616          LSR      r6,r6,#28
000060  fa04f906          LSL      r9,r4,r6
000064  ea090807          AND      r8,r9,r7
;;;402          if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
000068  4f19              LDR      r7,|L1.208|
00006a  42b8              CMP      r0,r7
00006c  d101              BNE      |L1.114|
00006e  2700              MOVS     r7,#0
000070  e00f              B        |L1.146|
                  |L1.114|
000072  4f18              LDR      r7,|L1.212|
000074  42b8              CMP      r0,r7
000076  d101              BNE      |L1.124|
000078  2701              MOVS     r7,#1
00007a  e00a              B        |L1.146|
                  |L1.124|
00007c  4f16              LDR      r7,|L1.216|
00007e  42b8              CMP      r0,r7
000080  d101              BNE      |L1.134|
000082  2702              MOVS     r7,#2
000084  e005              B        |L1.146|
                  |L1.134|
000086  4f15              LDR      r7,|L1.220|
000088  42b8              CMP      r0,r7
00008a  d101              BNE      |L1.144|
00008c  2703              MOVS     r7,#3
00008e  e000              B        |L1.146|
                  |L1.144|
000090  2704              MOVS     r7,#4
                  |L1.146|
000092  40b7              LSLS     r7,r7,r6
000094  4547              CMP      r7,r8
000096  d113              BNE      |L1.192|
;;;403          {
;;;404            tmp = 0x0FU << (4U * (position & 0x03U));
;;;405            CLEAR_BIT(AFIO->EXTICR[position >> 2U], tmp);
000098  68af              LDR      r7,[r5,#8]
00009a  ea270709          BIC      r7,r7,r9
00009e  60af              STR      r7,[r5,#8]
;;;406    
;;;407            /* Clear EXTI line configuration */
;;;408            CLEAR_BIT(EXTI->IMR, (uint32_t)iocurrent);
0000a0  4d0f              LDR      r5,|L1.224|
0000a2  682e              LDR      r6,[r5,#0]
0000a4  4396              BICS     r6,r6,r2
0000a6  602e              STR      r6,[r5,#0]
;;;409            CLEAR_BIT(EXTI->EMR, (uint32_t)iocurrent);
0000a8  1d2d              ADDS     r5,r5,#4
0000aa  682e              LDR      r6,[r5,#0]
0000ac  4396              BICS     r6,r6,r2
0000ae  602e              STR      r6,[r5,#0]
;;;410    
;;;411            /* Clear Rising Falling edge configuration */
;;;412            CLEAR_BIT(EXTI->RTSR, (uint32_t)iocurrent);
0000b0  1d2d              ADDS     r5,r5,#4
0000b2  682e              LDR      r6,[r5,#0]
0000b4  4396              BICS     r6,r6,r2
0000b6  602e              STR      r6,[r5,#0]
;;;413            CLEAR_BIT(EXTI->FTSR, (uint32_t)iocurrent);
0000b8  1d2d              ADDS     r5,r5,#4
0000ba  682e              LDR      r6,[r5,#0]
0000bc  4396              BICS     r6,r6,r2
0000be  602e              STR      r6,[r5,#0]
                  |L1.192|
0000c0  1c5b              ADDS     r3,r3,#1
                  |L1.194|
0000c2  fa31f203          LSRS     r2,r1,r3              ;378
0000c6  d1a2              BNE      |L1.14|
;;;414          }
;;;415        }
;;;416    
;;;417        position++;
;;;418      }
;;;419    }
0000c8  e8bd83f0          POP      {r4-r9,pc}
;;;420    
                          ENDP

                  |L1.204|
                          DCD      0x40010000
                  |L1.208|
                          DCD      0x40010800
                  |L1.212|
                          DCD      0x40010c00
                  |L1.216|
                          DCD      0x40011000
                  |L1.220|
                          DCD      0x40011400
                  |L1.224|
                          DCD      0x40010400

                          AREA ||i.HAL_GPIO_EXTI_Callback||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_EXTI_Callback PROC
;;;568      */
;;;569    __weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
000000  4770              BX       lr
;;;570    {
;;;571      /* Prevent unused argument(s) compilation warning */
;;;572      UNUSED(GPIO_Pin);
;;;573      /* NOTE: This function Should not be modified, when the callback is needed,
;;;574               the HAL_GPIO_EXTI_Callback could be implemented in the user file
;;;575       */
;;;576    }
;;;577    
                          ENDP


                          AREA ||i.HAL_GPIO_EXTI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_EXTI_IRQHandler PROC
;;;553      */
;;;554    void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
000000  4904              LDR      r1,|L3.20|
;;;555    {
000002  b510              PUSH     {r4,lr}
;;;556      /* EXTI line interrupt detected */
;;;557      if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
000004  680a              LDR      r2,[r1,#0]
000006  4202              TST      r2,r0
000008  d002              BEQ      |L3.16|
;;;558      {
;;;559        __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
00000a  6008              STR      r0,[r1,#0]
;;;560        HAL_GPIO_EXTI_Callback(GPIO_Pin);
00000c  f7fffffe          BL       HAL_GPIO_EXTI_Callback
                  |L3.16|
;;;561      }
;;;562    }
000010  bd10              POP      {r4,pc}
;;;563    
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0x40010414

                          AREA ||i.HAL_GPIO_Init||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_Init PROC
;;;193      */
;;;194    void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;195    {
;;;196      uint32_t position;
;;;197      uint32_t ioposition = 0x00U;
;;;198      uint32_t iocurrent = 0x00U;
;;;199      uint32_t temp = 0x00U;
;;;200      uint32_t config = 0x00U;
;;;201      __IO uint32_t *configregister; /* Store the address of CRL or CRH register based on pin number */
;;;202      uint32_t registeroffset = 0U; /* offset used during computation of CNF and MODE bits placement inside CRL or CRH register */
;;;203    
;;;204      /* Check the parameters */
;;;205      assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
;;;206      assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
;;;207      assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
;;;208    
;;;209      /* Configure the port pins */
;;;210      for (position = 0U; position < GPIO_NUMBER; position++)
;;;211      {
;;;212        /* Get the IO position */
;;;213        ioposition = (0x01U << position);
;;;214    
;;;215        /* Get the current IO position */
;;;216        iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
;;;217    
;;;218        if (iocurrent == ioposition)
;;;219        {
;;;220          /* Check the Alternate function parameters */
;;;221          assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
;;;222    
;;;223          /* Based on the required mode, filling config variable with MODEy[1:0] and CNFy[3:2] corresponding bits */
;;;224          switch (GPIO_Init->Mode)
;;;225          {
;;;226            /* If we are configuring the pin in OUTPUT push-pull mode */
;;;227            case GPIO_MODE_OUTPUT_PP:
;;;228              /* Check the GPIO speed parameter */
;;;229              assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
;;;230              config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_PP;
;;;231              break;
;;;232    
;;;233            /* If we are configuring the pin in OUTPUT open-drain mode */
;;;234            case GPIO_MODE_OUTPUT_OD:
;;;235              /* Check the GPIO speed parameter */
;;;236              assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
;;;237              config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_OD;
;;;238              break;
;;;239    
;;;240            /* If we are configuring the pin in ALTERNATE FUNCTION push-pull mode */
;;;241            case GPIO_MODE_AF_PP:
;;;242              /* Check the GPIO speed parameter */
;;;243              assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
;;;244              config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_PP;
;;;245              break;
;;;246    
;;;247            /* If we are configuring the pin in ALTERNATE FUNCTION open-drain mode */
;;;248            case GPIO_MODE_AF_OD:
;;;249              /* Check the GPIO speed parameter */
;;;250              assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
;;;251              config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_OD;
;;;252              break;
;;;253    
;;;254            /* If we are configuring the pin in INPUT (also applicable to EVENT and IT mode) */
;;;255            case GPIO_MODE_INPUT:
;;;256            case GPIO_MODE_IT_RISING:
;;;257            case GPIO_MODE_IT_FALLING:
;;;258            case GPIO_MODE_IT_RISING_FALLING:
;;;259            case GPIO_MODE_EVT_RISING:
;;;260            case GPIO_MODE_EVT_FALLING:
;;;261            case GPIO_MODE_EVT_RISING_FALLING:
;;;262              /* Check the GPIO pull parameter */
;;;263              assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
;;;264              if (GPIO_Init->Pull == GPIO_NOPULL)
;;;265              {
;;;266                config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_FLOATING;
;;;267              }
;;;268              else if (GPIO_Init->Pull == GPIO_PULLUP)
;;;269              {
;;;270                config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
;;;271    
;;;272                /* Set the corresponding ODR bit */
;;;273                GPIOx->BSRR = ioposition;
;;;274              }
;;;275              else /* GPIO_PULLDOWN */
;;;276              {
;;;277                config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
;;;278    
;;;279                /* Reset the corresponding ODR bit */
;;;280                GPIOx->BRR = ioposition;
;;;281              }
;;;282              break;
;;;283    
;;;284            /* If we are configuring the pin in INPUT analog mode */
;;;285            case GPIO_MODE_ANALOG:
;;;286              config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_ANALOG;
;;;287              break;
;;;288    
;;;289            /* Parameters are checked with assert_param */
;;;290            default:
;;;291              break;
;;;292          }
;;;293    
;;;294          /* Check if the current bit belongs to first half or last half of the pin count number
;;;295           in order to address CRH or CRL register*/
;;;296          configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
;;;297          registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2U) : ((position - 8U) << 2U);
;;;298    
;;;299          /* Apply the new configuration of the pin to the register */
;;;300          MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), (config << registeroffset));
;;;301    
;;;302          /*--------------------- EXTI Mode Configuration ------------------------*/
;;;303          /* Configure the External Interrupt or event for the current IO */
;;;304          if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
;;;305          {
;;;306            /* Enable AFIO Clock */
;;;307            __HAL_RCC_AFIO_CLK_ENABLE();
;;;308            temp = AFIO->EXTICR[position >> 2U];
;;;309            CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
;;;310            SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
;;;311            AFIO->EXTICR[position >> 2U] = temp;
;;;312    
;;;313    
;;;314            /* Configure the interrupt mask */
;;;315            if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
;;;316            {
;;;317              SET_BIT(EXTI->IMR, iocurrent);
000004  f8dfa190          LDR      r10,|L4.408|
000008  2200              MOVS     r2,#0                 ;200
;;;318            }
;;;319            else
;;;320            {
;;;321              CLEAR_BIT(EXTI->IMR, iocurrent);
;;;322            }
;;;323    
;;;324            /* Configure the event mask */
;;;325            if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
;;;326            {
;;;327              SET_BIT(EXTI->EMR, iocurrent);
00000a  f10a0b04          ADD      r11,r10,#4
00000e  4614              MOV      r4,r2                 ;210
000010  2701              MOVS     r7,#1                 ;213
000012  f04f090f          MOV      r9,#0xf               ;300
;;;328            }
;;;329            else
;;;330            {
;;;331              CLEAR_BIT(EXTI->EMR, iocurrent);
;;;332            }
;;;333    
;;;334            /* Enable or disable the rising trigger */
;;;335            if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
;;;336            {
;;;337              SET_BIT(EXTI->RTSR, iocurrent);
000016  f10b0e04          ADD      lr,r11,#4
00001a  bf00              NOP                            ;213
                  |L4.28|
00001c  680b              LDR      r3,[r1,#0]            ;216
00001e  fa07f504          LSL      r5,r7,r4              ;213
000022  402b              ANDS     r3,r3,r5              ;216
000024  42ab              CMP      r3,r5                 ;218
000026  d174              BNE      |L4.274|
000028  f8dfc170          LDR      r12,|L4.412|
00002c  684e              LDR      r6,[r1,#4]            ;224
00002e  eba6080c          SUB      r8,r6,r12             ;224
000032  4566              CMP      r6,r12                ;224
000034  d02b              BEQ      |L4.142|
000036  dc0d              BGT      |L4.84|
000038  2e03              CMP      r6,#3                 ;224
00003a  d034              BEQ      |L4.166|
00003c  dc05              BGT      |L4.74|
00003e  b336              CBZ      r6,|L4.142|
000040  2e01              CMP      r6,#1                 ;224
000042  d019              BEQ      |L4.120|
000044  2e02              CMP      r6,#2                 ;224
000046  d12f              BNE      |L4.168|
000048  e01b              B        |L4.130|
                  |L4.74|
00004a  2e11              CMP      r6,#0x11              ;224
00004c  d016              BEQ      |L4.124|
00004e  2e12              CMP      r6,#0x12              ;224
000050  d12a              BNE      |L4.168|
000052  e019              B        |L4.136|
                  |L4.84|
000054  f5b81f88          CMP      r8,#0x110000          ;224
000058  d019              BEQ      |L4.142|
00005a  dc06              BGT      |L4.106|
00005c  f5b83f80          CMP      r8,#0x10000           ;224
000060  d015              BEQ      |L4.142|
000062  f5b81f80          CMP      r8,#0x100000          ;224
000066  d11f              BNE      |L4.168|
000068  e011              B        |L4.142|
                  |L4.106|
00006a  f5b81f00          CMP      r8,#0x200000          ;224
00006e  d00e              BEQ      |L4.142|
000070  f5b81f04          CMP      r8,#0x210000          ;224
000074  d118              BNE      |L4.168|
000076  e00a              B        |L4.142|
                  |L4.120|
000078  68ca              LDR      r2,[r1,#0xc]          ;231
00007a  e015              B        |L4.168|
                  |L4.124|
00007c  68ca              LDR      r2,[r1,#0xc]          ;237
00007e  1d12              ADDS     r2,r2,#4              ;237
000080  e012              B        |L4.168|
                  |L4.130|
000082  68ca              LDR      r2,[r1,#0xc]          ;244
000084  3208              ADDS     r2,r2,#8              ;244
000086  e00f              B        |L4.168|
                  |L4.136|
000088  68ca              LDR      r2,[r1,#0xc]          ;251
00008a  320c              ADDS     r2,r2,#0xc            ;251
00008c  e00c              B        |L4.168|
                  |L4.142|
00008e  688a              LDR      r2,[r1,#8]            ;264
000090  b12a              CBZ      r2,|L4.158|
000092  2a01              CMP      r2,#1                 ;268
000094  f04f0208          MOV      r2,#8                 ;277
000098  d003              BEQ      |L4.162|
00009a  6145              STR      r5,[r0,#0x14]         ;280
00009c  e004              B        |L4.168|
                  |L4.158|
00009e  2204              MOVS     r2,#4                 ;266
0000a0  e002              B        |L4.168|
                  |L4.162|
0000a2  6105              STR      r5,[r0,#0x10]         ;273
0000a4  e000              B        |L4.168|
                  |L4.166|
0000a6  2200              MOVS     r2,#0                 ;286
                  |L4.168|
0000a8  2bff              CMP      r3,#0xff              ;296
0000aa  d801              BHI      |L4.176|
0000ac  4606              MOV      r6,r0                 ;296
0000ae  e001              B        |L4.180|
                  |L4.176|
0000b0  f1000604          ADD      r6,r0,#4              ;296
                  |L4.180|
0000b4  ea4f0584          LSL      r5,r4,#2              ;296
0000b8  d901              BLS      |L4.190|
0000ba  f1a50520          SUB      r5,r5,#0x20           ;297
                  |L4.190|
0000be  f8d6c000          LDR      r12,[r6,#0]           ;300
0000c2  fa09f805          LSL      r8,r9,r5              ;300
0000c6  ea2c0c08          BIC      r12,r12,r8            ;300
0000ca  fa02f505          LSL      r5,r2,r5              ;300
0000ce  ea4c0c05          ORR      r12,r12,r5            ;300
0000d2  f8c6c000          STR      r12,[r6,#0]           ;300
0000d6  684d              LDR      r5,[r1,#4]            ;304
0000d8  00ed              LSLS     r5,r5,#3              ;304
0000da  d557              BPL      |L4.396|
0000dc  4d30              LDR      r5,|L4.416|
0000de  69ae              LDR      r6,[r5,#0x18]         ;307
0000e0  f0460601          ORR      r6,r6,#1              ;307
0000e4  61ae              STR      r6,[r5,#0x18]         ;307
0000e6  69ad              LDR      r5,[r5,#0x18]         ;307
0000e8  f0240603          BIC      r6,r4,#3              ;308
0000ec  f0050501          AND      r5,r5,#1              ;307
0000f0  9500              STR      r5,[sp,#0]            ;308
0000f2  4d2c              LDR      r5,|L4.420|
0000f4  eb060c05          ADD      r12,r6,r5             ;308
0000f8  f8dc5008          LDR      r5,[r12,#8]           ;308
0000fc  07a6              LSLS     r6,r4,#30             ;309
0000fe  ea4f7816          LSR      r8,r6,#28             ;309
000102  fa09f608          LSL      r6,r9,r8              ;309
000106  43b5              BICS     r5,r5,r6              ;309
000108  4e27              LDR      r6,|L4.424|
00010a  42b0              CMP      r0,r6                 ;310
00010c  d102              BNE      |L4.276|
00010e  2600              MOVS     r6,#0                 ;310
000110  e010              B        |L4.308|
                  |L4.274|
000112  e03b              B        |L4.396|
                  |L4.276|
000114  4e25              LDR      r6,|L4.428|
000116  42b0              CMP      r0,r6                 ;310
000118  d101              BNE      |L4.286|
00011a  2601              MOVS     r6,#1                 ;310
00011c  e00a              B        |L4.308|
                  |L4.286|
00011e  4e24              LDR      r6,|L4.432|
000120  42b0              CMP      r0,r6                 ;310
000122  d101              BNE      |L4.296|
000124  2602              MOVS     r6,#2                 ;310
000126  e005              B        |L4.308|
                  |L4.296|
000128  4e22              LDR      r6,|L4.436|
00012a  42b0              CMP      r0,r6                 ;310
00012c  d101              BNE      |L4.306|
00012e  2603              MOVS     r6,#3                 ;310
000130  e000              B        |L4.308|
                  |L4.306|
000132  2604              MOVS     r6,#4                 ;310
                  |L4.308|
000134  fa06f608          LSL      r6,r6,r8              ;310
000138  432e              ORRS     r6,r6,r5              ;310
00013a  f8cc6008          STR      r6,[r12,#8]           ;311
00013e  684d              LDR      r5,[r1,#4]            ;315
000140  f8da6000          LDR      r6,[r10,#0]           ;321
000144  03ed              LSLS     r5,r5,#15             ;315
000146  4655              MOV      r5,r10                ;321
000148  d501              BPL      |L4.334|
00014a  431e              ORRS     r6,r6,r3              ;317
00014c  e000              B        |L4.336|
                  |L4.334|
00014e  439e              BICS     r6,r6,r3              ;321
                  |L4.336|
000150  602e              STR      r6,[r5,#0]            ;321
000152  684d              LDR      r5,[r1,#4]            ;325
000154  f8db6000          LDR      r6,[r11,#0]           ;331
000158  03ad              LSLS     r5,r5,#14             ;325
00015a  465d              MOV      r5,r11                ;331
00015c  d501              BPL      |L4.354|
00015e  431e              ORRS     r6,r6,r3              ;327
000160  e000              B        |L4.356|
                  |L4.354|
000162  439e              BICS     r6,r6,r3              ;331
                  |L4.356|
000164  602e              STR      r6,[r5,#0]            ;331
000166  684d              LDR      r5,[r1,#4]            ;335
;;;338            }
;;;339            else
;;;340            {
;;;341              CLEAR_BIT(EXTI->RTSR, iocurrent);
000168  f8de6000          LDR      r6,[lr,#0]
00016c  02ed              LSLS     r5,r5,#11             ;335
00016e  4675              MOV      r5,lr
000170  d501              BPL      |L4.374|
000172  431e              ORRS     r6,r6,r3              ;337
000174  e000              B        |L4.376|
                  |L4.374|
000176  439e              BICS     r6,r6,r3
                  |L4.376|
000178  602e              STR      r6,[r5,#0]
;;;342            }
;;;343    
;;;344            /* Enable or disable the falling trigger */
;;;345            if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
00017a  684d              LDR      r5,[r1,#4]
00017c  02ad              LSLS     r5,r5,#10
;;;346            {
;;;347              SET_BIT(EXTI->FTSR, iocurrent);
;;;348            }
;;;349            else
;;;350            {
;;;351              CLEAR_BIT(EXTI->FTSR, iocurrent);
00017e  4d0e              LDR      r5,|L4.440|
000180  682e              LDR      r6,[r5,#0]
000182  d501              BPL      |L4.392|
000184  431e              ORRS     r6,r6,r3              ;347
000186  e000              B        |L4.394|
                  |L4.392|
000188  439e              BICS     r6,r6,r3
                  |L4.394|
00018a  602e              STR      r6,[r5,#0]            ;347
                  |L4.396|
00018c  1c64              ADDS     r4,r4,#1              ;347
00018e  2c10              CMP      r4,#0x10              ;210
000190  f4ffaf44          BCC      |L4.28|
;;;352            }
;;;353          }
;;;354        }
;;;355      }
;;;356    }
000194  e8bd8ff8          POP      {r3-r11,pc}
;;;357    
                          ENDP

                  |L4.408|
                          DCD      0x40010400
                  |L4.412|
                          DCD      0x10110000
                  |L4.416|
                          DCD      0x40021000
                  |L4.420|
                          DCD      0x40010000
                  |L4.424|
                          DCD      0x40010800
                  |L4.428|
                          DCD      0x40010c00
                  |L4.432|
                          DCD      0x40011000
                  |L4.436|
                          DCD      0x40011400
                  |L4.440|
                          DCD      0x4001040c

                          AREA ||i.HAL_GPIO_LockPin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_LockPin PROC
;;;519    */
;;;520    HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
000000  b508              PUSH     {r3,lr}
;;;521    {
;;;522      __IO uint32_t tmp = GPIO_LCKR_LCKK;
;;;523    
;;;524      /* Check the parameters */
;;;525      assert_param(IS_GPIO_LOCK_INSTANCE(GPIOx));
;;;526      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;527    
;;;528      /* Apply lock key write sequence */
;;;529      SET_BIT(tmp, GPIO_Pin);
000002  f4413280          ORR      r2,r1,#0x10000
;;;530      /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
;;;531      GPIOx->LCKR = tmp;
000006  9200              STR      r2,[sp,#0]
000008  6182              STR      r2,[r0,#0x18]
;;;532      /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
;;;533      GPIOx->LCKR = GPIO_Pin;
00000a  6181              STR      r1,[r0,#0x18]
;;;534      /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
;;;535      GPIOx->LCKR = tmp;
00000c  9900              LDR      r1,[sp,#0]
00000e  6181              STR      r1,[r0,#0x18]
;;;536      /* Read LCKK bit*/
;;;537      tmp = GPIOx->LCKR;
000010  6981              LDR      r1,[r0,#0x18]
;;;538    
;;;539      if ((uint32_t)(GPIOx->LCKR & GPIO_LCKR_LCKK))
000012  9100              STR      r1,[sp,#0]
000014  6980              LDR      r0,[r0,#0x18]
000016  03c0              LSLS     r0,r0,#15
000018  d501              BPL      |L5.30|
;;;540      {
;;;541        return HAL_OK;
00001a  2000              MOVS     r0,#0
;;;542      }
;;;543      else
;;;544      {
;;;545        return HAL_ERROR;
;;;546      }
;;;547    }
00001c  bd08              POP      {r3,pc}
                  |L5.30|
00001e  2001              MOVS     r0,#1                 ;545
000020  bd08              POP      {r3,pc}
;;;548    
                          ENDP


                          AREA ||i.HAL_GPIO_ReadPin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_ReadPin PROC
;;;445      */
;;;446    GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
000000  6880              LDR      r0,[r0,#8]
;;;447    {
;;;448      GPIO_PinState bitstatus;
;;;449    
;;;450      /* Check the parameters */
;;;451      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;452    
;;;453      if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
000002  4008              ANDS     r0,r0,r1
000004  d000              BEQ      |L6.8|
;;;454      {
;;;455        bitstatus = GPIO_PIN_SET;
000006  2001              MOVS     r0,#1
                  |L6.8|
;;;456      }
;;;457      else
;;;458      {
;;;459        bitstatus = GPIO_PIN_RESET;
;;;460      }
;;;461      return bitstatus;
;;;462    }
000008  4770              BX       lr
;;;463    
                          ENDP


                          AREA ||i.HAL_GPIO_TogglePin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_TogglePin PROC
;;;501      */
;;;502    void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
000000  68c2              LDR      r2,[r0,#0xc]
;;;503    {
;;;504      /* Check the parameters */
;;;505      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;506    
;;;507      GPIOx->ODR ^= GPIO_Pin;
000002  404a              EORS     r2,r2,r1
000004  60c2              STR      r2,[r0,#0xc]
;;;508    }
000006  4770              BX       lr
;;;509    
                          ENDP


                          AREA ||i.HAL_GPIO_WritePin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_WritePin PROC
;;;479      */
;;;480    void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
000000  b10a              CBZ      r2,|L8.6|
                  |L8.2|
;;;481    {
;;;482      /* Check the parameters */
;;;483      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;484      assert_param(IS_GPIO_PIN_ACTION(PinState));
;;;485    
;;;486      if (PinState != GPIO_PIN_RESET)
;;;487      {
;;;488        GPIOx->BSRR = GPIO_Pin;
000002  6101              STR      r1,[r0,#0x10]
;;;489      }
;;;490      else
;;;491      {
;;;492        GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
;;;493      }
;;;494    }
000004  4770              BX       lr
                  |L8.6|
000006  0409              LSLS     r1,r1,#16             ;492
000008  e7fb              B        |L8.2|
;;;495    
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_gpio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_gpio_c_ea787061____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___20_stm32f1xx_hal_gpio_c_ea787061____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_gpio_c_ea787061____REVSH|
#line 402
|__asm___20_stm32f1xx_hal_gpio_c_ea787061____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_gpio_c_ea787061____RRX|
#line 587
|__asm___20_stm32f1xx_hal_gpio_c_ea787061____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
