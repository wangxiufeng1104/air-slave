; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\stm32f1xx_hal_rcc.o --asm_dir=.\air_slave\ --list_dir=.\air_slave\ --depend=.\stm32f1xx_hal_rcc.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I.\RTE\_air_slave -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=525 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=.\stm32f1xx_hal_rcc.crf ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_rcc.c]
                          THUMB

                          AREA ||i.HAL_RCC_CSSCallback||, CODE, READONLY, ALIGN=1

                  HAL_RCC_CSSCallback PROC
;;;1378     */
;;;1379   __weak void HAL_RCC_CSSCallback(void)
000000  4770              BX       lr
;;;1380   {
;;;1381     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1382       the HAL_RCC_CSSCallback could be implemented in the user file
;;;1383       */ 
;;;1384   }
;;;1385   
                          ENDP


                          AREA ||i.HAL_RCC_ClockConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_ClockConfig PROC
;;;808      */
;;;809    HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;810    {
;;;811      uint32_t tickstart = 0U;
;;;812      
;;;813      /* Check the parameters */
;;;814      assert_param(RCC_ClkInitStruct != NULL);
;;;815      assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
;;;816      assert_param(IS_FLASH_LATENCY(FLatency));
;;;817    
;;;818      /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
;;;819      must be correctly programmed according to the frequency of the CPU clock 
;;;820        (HCLK) of the device. */
;;;821    
;;;822    #if defined(FLASH_ACR_LATENCY)
;;;823      /* Increasing the number of wait states because of higher CPU frequency */
;;;824      if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
000004  f8df813c          LDR      r8,|L2.324|
000008  4605              MOV      r5,r0                 ;810
00000a  460e              MOV      r6,r1                 ;810
00000c  f8d80000          LDR      r0,[r8,#0]
000010  f0000007          AND      r0,r0,#7
000014  42b0              CMP      r0,r6
000016  d20c              BCS      |L2.50|
;;;825      {    
;;;826        /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
;;;827        __HAL_FLASH_SET_LATENCY(FLatency);
000018  f8d81000          LDR      r1,[r8,#0]
00001c  f0210107          BIC      r1,r1,#7
000020  4331              ORRS     r1,r1,r6
000022  f8c81000          STR      r1,[r8,#0]
;;;828        
;;;829        /* Check that the new number of wait states is taken into account to access the Flash
;;;830        memory by reading the FLASH_ACR register */
;;;831        if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
000026  f8d80000          LDR      r0,[r8,#0]
00002a  f0000007          AND      r0,r0,#7
00002e  42b0              CMP      r0,r6
000030  d163              BNE      |L2.250|
                  |L2.50|
;;;832        {
;;;833          return HAL_ERROR;
;;;834        }
;;;835      }
;;;836    
;;;837    #endif /* FLASH_ACR_LATENCY */
;;;838      /*-------------------------- HCLK Configuration --------------------------*/
;;;839      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
000032  7828              LDRB     r0,[r5,#0]
;;;840      {
;;;841        assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
;;;842        MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
000034  4c44              LDR      r4,|L2.328|
000036  0780              LSLS     r0,r0,#30             ;839
000038  d505              BPL      |L2.70|
00003a  6860              LDR      r0,[r4,#4]
00003c  68a9              LDR      r1,[r5,#8]
00003e  f02000f0          BIC      r0,r0,#0xf0
000042  4308              ORRS     r0,r0,r1
000044  6060              STR      r0,[r4,#4]
                  |L2.70|
;;;843      }
;;;844    
;;;845      /*------------------------- SYSCLK Configuration ---------------------------*/ 
;;;846      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
000046  7828              LDRB     r0,[r5,#0]
000048  07c0              LSLS     r0,r0,#31
00004a  d045              BEQ      |L2.216|
;;;847      {    
;;;848        assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
;;;849        
;;;850        /* HSE is selected as System Clock Source */
;;;851        if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
00004c  6868              LDR      r0,[r5,#4]
00004e  2801              CMP      r0,#1
000050  d016              BEQ      |L2.128|
;;;852        {
;;;853          /* Check the HSE ready flag */  
;;;854          if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
;;;855          {
;;;856            return HAL_ERROR;
;;;857          }
;;;858        }
;;;859        /* PLL is selected as System Clock Source */
;;;860        else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
;;;861        {
;;;862          /* Check the PLL ready flag */  
;;;863          if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
;;;864          {
;;;865            return HAL_ERROR;
;;;866          }
;;;867        }
;;;868        /* HSI is selected as System Clock Source */
;;;869        else
;;;870        {
;;;871          /* Check the HSI ready flag */  
;;;872          if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
000052  6821              LDR      r1,[r4,#0]
000054  2802              CMP      r0,#2                 ;860
000056  d016              BEQ      |L2.134|
000058  0789              LSLS     r1,r1,#30
                  |L2.90|
00005a  2900              CMP      r1,#0
00005c  da4d              BGE      |L2.250|
;;;873          {
;;;874            return HAL_ERROR;
;;;875          }
;;;876        }
;;;877        __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
00005e  6861              LDR      r1,[r4,#4]
000060  f0210103          BIC      r1,r1,#3
000064  4301              ORRS     r1,r1,r0
000066  6061              STR      r1,[r4,#4]
;;;878    
;;;879        /* Get Start Tick */
;;;880        tickstart = HAL_GetTick();
000068  f7fffffe          BL       HAL_GetTick
;;;881        
;;;882        if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
00006c  6869              LDR      r1,[r5,#4]
00006e  4607              MOV      r7,r0                 ;880
;;;883        {
;;;884          while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
;;;885          {
;;;886            if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
000070  f2413088          MOV      r0,#0x1388
000074  2901              CMP      r1,#1                 ;882
000076  d00f              BEQ      |L2.152|
;;;887            {
;;;888              return HAL_TIMEOUT;
;;;889            }
;;;890          }
;;;891        }
;;;892        else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
000078  2902              CMP      r1,#2
00007a  4681              MOV      r9,r0                 ;886
00007c  d019              BEQ      |L2.178|
00007e  e027              B        |L2.208|
                  |L2.128|
000080  6821              LDR      r1,[r4,#0]            ;854
000082  0389              LSLS     r1,r1,#14             ;854
000084  e7e9              B        |L2.90|
                  |L2.134|
000086  0189              LSLS     r1,r1,#6              ;863
000088  e7e7              B        |L2.90|
00008a  bf00              NOP                            ;886
                  |L2.140|
00008c  f7fffffe          BL       HAL_GetTick
000090  1bc1              SUBS     r1,r0,r7              ;886
000092  4549              CMP      r1,r9                 ;886
000094  d901              BLS      |L2.154|
000096  e018              B        |L2.202|
                  |L2.152|
000098  4681              MOV      r9,r0                 ;886
                  |L2.154|
00009a  6860              LDR      r0,[r4,#4]            ;884
00009c  f3c00081          UBFX     r0,r0,#2,#2           ;884
0000a0  2801              CMP      r0,#1                 ;884
0000a2  d1f3              BNE      |L2.140|
0000a4  e018              B        |L2.216|
;;;893        {
;;;894          while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
;;;895          {
;;;896            if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
0000a6  bf00              NOP      
                  |L2.168|
0000a8  f7fffffe          BL       HAL_GetTick
0000ac  1bc1              SUBS     r1,r0,r7
0000ae  4549              CMP      r1,r9
0000b0  d80b              BHI      |L2.202|
                  |L2.178|
0000b2  6860              LDR      r0,[r4,#4]            ;894
0000b4  f3c00081          UBFX     r0,r0,#2,#2           ;894
0000b8  2802              CMP      r0,#2                 ;894
0000ba  d1f5              BNE      |L2.168|
0000bc  e00c              B        |L2.216|
;;;897            {
;;;898              return HAL_TIMEOUT;
;;;899            }
;;;900          }
;;;901        }
;;;902        else
;;;903        {
;;;904          while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
;;;905          {
;;;906            if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
0000be  bf00              NOP      
                  |L2.192|
0000c0  f7fffffe          BL       HAL_GetTick
0000c4  1bc1              SUBS     r1,r0,r7
0000c6  4549              CMP      r1,r9
0000c8  d902              BLS      |L2.208|
                  |L2.202|
;;;907            {
;;;908              return HAL_TIMEOUT;
0000ca  2003              MOVS     r0,#3
                  |L2.204|
;;;909            }
;;;910          }
;;;911        }      
;;;912      }    
;;;913    #if defined(FLASH_ACR_LATENCY)
;;;914      /* Decreasing the number of wait states because of lower CPU frequency */
;;;915      if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
;;;916      {    
;;;917        /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
;;;918        __HAL_FLASH_SET_LATENCY(FLatency);
;;;919        
;;;920        /* Check that the new number of wait states is taken into account to access the Flash
;;;921        memory by reading the FLASH_ACR register */
;;;922        if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
;;;923        {
;;;924          return HAL_ERROR;
;;;925        }
;;;926      }    
;;;927    #endif /* FLASH_ACR_LATENCY */
;;;928    
;;;929      /*-------------------------- PCLK1 Configuration ---------------------------*/ 
;;;930      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
;;;931      {
;;;932        assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
;;;933        MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
;;;934      }
;;;935      
;;;936      /*-------------------------- PCLK2 Configuration ---------------------------*/ 
;;;937      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
;;;938      {
;;;939        assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
;;;940        MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
;;;941      }
;;;942     
;;;943      /* Update the SystemCoreClock global variable */
;;;944      SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
;;;945    
;;;946      /* Configure the source of time base considering new system clocks settings*/
;;;947      HAL_InitTick (TICK_INT_PRIORITY);
;;;948      
;;;949      return HAL_OK;
;;;950    }
0000cc  e8bd87f0          POP      {r4-r10,pc}
                  |L2.208|
0000d0  6860              LDR      r0,[r4,#4]            ;904
0000d2  f0100f0c          TST      r0,#0xc               ;904
0000d6  d1f3              BNE      |L2.192|
                  |L2.216|
0000d8  f8d81000          LDR      r1,[r8,#0]            ;915
0000dc  4640              MOV      r0,r8                 ;915
0000de  f0010107          AND      r1,r1,#7              ;915
0000e2  42b1              CMP      r1,r6                 ;915
0000e4  d90b              BLS      |L2.254|
0000e6  6801              LDR      r1,[r0,#0]            ;918
0000e8  f0210107          BIC      r1,r1,#7              ;918
0000ec  4331              ORRS     r1,r1,r6              ;918
0000ee  6001              STR      r1,[r0,#0]            ;918
0000f0  6800              LDR      r0,[r0,#0]            ;922
0000f2  f0000007          AND      r0,r0,#7              ;922
0000f6  42b0              CMP      r0,r6                 ;922
0000f8  d001              BEQ      |L2.254|
                  |L2.250|
0000fa  2001              MOVS     r0,#1                 ;924
0000fc  e7e6              B        |L2.204|
                  |L2.254|
0000fe  7828              LDRB     r0,[r5,#0]            ;930
000100  0740              LSLS     r0,r0,#29             ;930
000102  d505              BPL      |L2.272|
000104  6860              LDR      r0,[r4,#4]            ;933
000106  68e9              LDR      r1,[r5,#0xc]          ;933
000108  f42060e0          BIC      r0,r0,#0x700          ;933
00010c  4308              ORRS     r0,r0,r1              ;933
00010e  6060              STR      r0,[r4,#4]            ;933
                  |L2.272|
000110  7828              LDRB     r0,[r5,#0]            ;937
000112  0700              LSLS     r0,r0,#28             ;937
000114  d506              BPL      |L2.292|
000116  6860              LDR      r0,[r4,#4]            ;940
000118  6929              LDR      r1,[r5,#0x10]         ;940
00011a  f4205060          BIC      r0,r0,#0x3800         ;940
00011e  ea4000c1          ORR      r0,r0,r1,LSL #3       ;940
000122  6060              STR      r0,[r4,#4]            ;940
                  |L2.292|
000124  f7fffffe          BL       HAL_RCC_GetSysClockFreq
000128  6861              LDR      r1,[r4,#4]            ;944
00012a  4a08              LDR      r2,|L2.332|
00012c  f3c11103          UBFX     r1,r1,#4,#4           ;944
000130  5c51              LDRB     r1,[r2,r1]            ;944
000132  40c8              LSRS     r0,r0,r1              ;944
000134  4906              LDR      r1,|L2.336|
000136  6008              STR      r0,[r1,#0]            ;947  ; SystemCoreClock
000138  2000              MOVS     r0,#0                 ;947
00013a  f7fffffe          BL       HAL_InitTick
00013e  2000              MOVS     r0,#0                 ;949
000140  e7c4              B        |L2.204|
;;;951    
                          ENDP

000142  0000              DCW      0x0000
                  |L2.324|
                          DCD      0x40022000
                  |L2.328|
                          DCD      0x40021000
                  |L2.332|
                          DCD      AHBPrescTable
                  |L2.336|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_RCC_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_RCC_DeInit PROC
;;;217      */
;;;218    HAL_StatusTypeDef HAL_RCC_DeInit(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;219    {
;;;220      uint32_t tickstart;
;;;221    
;;;222      /* Get Start Tick */
;;;223      tickstart = HAL_GetTick();
000004  f7fffffe          BL       HAL_GetTick
;;;224    
;;;225      /* Set HSION bit */
;;;226      SET_BIT(RCC->CR, RCC_CR_HSION);
000008  4c30              LDR      r4,|L3.204|
00000a  4605              MOV      r5,r0                 ;223
00000c  6820              LDR      r0,[r4,#0]
00000e  f0400001          ORR      r0,r0,#1
000012  6020              STR      r0,[r4,#0]
;;;227    
;;;228      /* Wait till HSI is ready */
;;;229      while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == RESET)
000014  e005              B        |L3.34|
;;;230      {
;;;231        if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
000016  bf00              NOP      
                  |L3.24|
000018  f7fffffe          BL       HAL_GetTick
00001c  1b40              SUBS     r0,r0,r5
00001e  2802              CMP      r0,#2
000020  d843              BHI      |L3.170|
                  |L3.34|
000022  6820              LDR      r0,[r4,#0]            ;229
000024  0780              LSLS     r0,r0,#30             ;229
000026  d5f7              BPL      |L3.24|
;;;232        {
;;;233          return HAL_TIMEOUT;
;;;234        }
;;;235      }
;;;236    
;;;237      /* Set HSITRIM bits to the reset value */
;;;238      MODIFY_REG(RCC->CR, RCC_CR_HSITRIM, (0x10U << RCC_CR_HSITRIM_Pos));
000028  6820              LDR      r0,[r4,#0]
00002a  f02000f8          BIC      r0,r0,#0xf8
00002e  f0400080          ORR      r0,r0,#0x80
000032  6020              STR      r0,[r4,#0]
;;;239    
;;;240      /* Get Start Tick */
;;;241      tickstart = HAL_GetTick();
000034  f7fffffe          BL       HAL_GetTick
;;;242    
;;;243      /* Reset CFGR register */
;;;244      CLEAR_REG(RCC->CFGR);
000038  2500              MOVS     r5,#0
00003a  4606              MOV      r6,r0                 ;241
00003c  6065              STR      r5,[r4,#4]
;;;245    
;;;246      /* Wait till clock switch is ready */
;;;247      while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != RESET)
;;;248      {
;;;249        if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
00003e  f2413788          MOV      r7,#0x1388
000042  e004              B        |L3.78|
                  |L3.68|
000044  f7fffffe          BL       HAL_GetTick
000048  1b80              SUBS     r0,r0,r6
00004a  42b8              CMP      r0,r7
00004c  d82d              BHI      |L3.170|
                  |L3.78|
00004e  6860              LDR      r0,[r4,#4]            ;247
000050  f0100f0c          TST      r0,#0xc               ;247
000054  d1f6              BNE      |L3.68|
;;;250        {
;;;251          return HAL_TIMEOUT;
;;;252        }
;;;253      }
;;;254    
;;;255      /* Update the SystemCoreClock global variable */
;;;256      SystemCoreClock = HSI_VALUE;
000056  491f              LDR      r1,|L3.212|
000058  481d              LDR      r0,|L3.208|
;;;257    
;;;258      /* Adapt Systick interrupt period */
;;;259      if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
00005a  6008              STR      r0,[r1,#0]  ; SystemCoreClock
00005c  2000              MOVS     r0,#0
00005e  f7fffffe          BL       HAL_InitTick
000062  b110              CBZ      r0,|L3.106|
;;;260      {
;;;261        return HAL_ERROR;
000064  2001              MOVS     r0,#1
                  |L3.102|
;;;262      }
;;;263    
;;;264      /* Get Start Tick */
;;;265      tickstart = HAL_GetTick();
;;;266    
;;;267      /* Second step is to clear PLLON bit */
;;;268      CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
;;;269    
;;;270      /* Wait till PLL is disabled */
;;;271      while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET)
;;;272      {
;;;273        if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
;;;274        {
;;;275          return HAL_TIMEOUT;
;;;276        }
;;;277      }
;;;278    
;;;279      /* Ensure to reset PLLSRC and PLLMUL bits */
;;;280      CLEAR_REG(RCC->CFGR);
;;;281    
;;;282      /* Get Start Tick */
;;;283      tickstart = HAL_GetTick();
;;;284    
;;;285      /* Reset HSEON & CSSON bits */
;;;286      CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_CSSON);
;;;287    
;;;288      /* Wait till HSE is disabled */
;;;289      while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != RESET)
;;;290      {
;;;291        if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
;;;292        {
;;;293          return HAL_TIMEOUT;
;;;294        }
;;;295      }
;;;296    
;;;297      /* Reset HSEBYP bit */
;;;298      CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
;;;299    
;;;300    #if defined(RCC_PLL2_SUPPORT)
;;;301      /* Get Start Tick */
;;;302      tickstart = HAL_GetTick();
;;;303    
;;;304      /* Clear PLL2ON bit */
;;;305      CLEAR_BIT(RCC->CR, RCC_CR_PLL2ON);
;;;306    
;;;307      /* Wait till PLL2 is disabled */
;;;308      while (READ_BIT(RCC->CR, RCC_CR_PLL2RDY) != RESET)
;;;309      {
;;;310        if ((HAL_GetTick() - tickstart) > PLL2_TIMEOUT_VALUE)
;;;311        {
;;;312          return HAL_TIMEOUT;
;;;313        }
;;;314      }
;;;315    #endif /* RCC_PLL2_SUPPORT */
;;;316    
;;;317    #if defined(RCC_PLLI2S_SUPPORT)
;;;318      /* Get Start Tick */
;;;319      tickstart = HAL_GetTick();
;;;320    
;;;321      /* Clear PLL3ON bit */
;;;322      CLEAR_BIT(RCC->CR, RCC_CR_PLL3ON);
;;;323    
;;;324      /* Wait till PLL3 is disabled */
;;;325      while (READ_BIT(RCC->CR, RCC_CR_PLL3RDY) != RESET)
;;;326      {
;;;327        if ((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
;;;328        {
;;;329          return HAL_TIMEOUT;
;;;330        }
;;;331      }
;;;332    #endif /* RCC_PLLI2S_SUPPORT */
;;;333    
;;;334    #if defined(RCC_CFGR2_PREDIV1)
;;;335      /* Reset CFGR2 register */
;;;336      CLEAR_REG(RCC->CFGR2);
;;;337    #endif /* RCC_CFGR2_PREDIV1 */
;;;338    
;;;339      /* Reset all CSR flags */
;;;340      SET_BIT(RCC->CSR, RCC_CSR_RMVF);
;;;341    
;;;342      /* Disable all interrupts */
;;;343      CLEAR_REG(RCC->CIR);
;;;344    
;;;345      return HAL_OK;
;;;346    }
000066  e8bd81f0          POP      {r4-r8,pc}
                  |L3.106|
00006a  f7fffffe          BL       HAL_GetTick
00006e  4606              MOV      r6,r0                 ;265
000070  6820              LDR      r0,[r4,#0]            ;268
000072  f0207080          BIC      r0,r0,#0x1000000      ;268
000076  6020              STR      r0,[r4,#0]            ;268
000078  e005              B        |L3.134|
00007a  bf00              NOP                            ;273
                  |L3.124|
00007c  f7fffffe          BL       HAL_GetTick
000080  1b80              SUBS     r0,r0,r6              ;273
000082  2802              CMP      r0,#2                 ;273
000084  d811              BHI      |L3.170|
                  |L3.134|
000086  6820              LDR      r0,[r4,#0]            ;271
000088  0180              LSLS     r0,r0,#6              ;271
00008a  d4f7              BMI      |L3.124|
00008c  6065              STR      r5,[r4,#4]            ;280
00008e  f7fffffe          BL       HAL_GetTick
000092  4606              MOV      r6,r0                 ;283
000094  6820              LDR      r0,[r4,#0]            ;286
000096  f4202010          BIC      r0,r0,#0x90000        ;286
00009a  6020              STR      r0,[r4,#0]            ;286
00009c  e007              B        |L3.174|
00009e  bf00              NOP                            ;291
                  |L3.160|
0000a0  f7fffffe          BL       HAL_GetTick
0000a4  1b80              SUBS     r0,r0,r6              ;291
0000a6  2864              CMP      r0,#0x64              ;291
0000a8  d901              BLS      |L3.174|
                  |L3.170|
0000aa  2003              MOVS     r0,#3                 ;293
0000ac  e7db              B        |L3.102|
                  |L3.174|
0000ae  6820              LDR      r0,[r4,#0]            ;289
0000b0  0380              LSLS     r0,r0,#14             ;289
0000b2  d4f5              BMI      |L3.160|
0000b4  6820              LDR      r0,[r4,#0]            ;298
0000b6  f4202080          BIC      r0,r0,#0x40000        ;298
0000ba  6020              STR      r0,[r4,#0]            ;298
0000bc  6a60              LDR      r0,[r4,#0x24]         ;340
0000be  f0407080          ORR      r0,r0,#0x1000000      ;340
0000c2  6260              STR      r0,[r4,#0x24]         ;340
0000c4  60a5              STR      r5,[r4,#8]            ;343
0000c6  2000              MOVS     r0,#0                 ;345
0000c8  e7cd              B        |L3.102|
;;;347    
                          ENDP

0000ca  0000              DCW      0x0000
                  |L3.204|
                          DCD      0x40021000
                  |L3.208|
                          DCD      0x007a1200
                  |L3.212|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_RCC_DisableCSS||, CODE, READONLY, ALIGN=2

                  HAL_RCC_DisableCSS PROC
;;;1047     */
;;;1048   void HAL_RCC_DisableCSS(void)
000000  4901              LDR      r1,|L4.8|
;;;1049   {
;;;1050     *(__IO uint32_t *) RCC_CR_CSSON_BB = (uint32_t)DISABLE;
000002  2000              MOVS     r0,#0
000004  64c8              STR      r0,[r1,#0x4c]
;;;1051   }
000006  4770              BX       lr
;;;1052   
                          ENDP

                  |L4.8|
                          DCD      0x42420000

                          AREA ||i.HAL_RCC_EnableCSS||, CODE, READONLY, ALIGN=2

                  HAL_RCC_EnableCSS PROC
;;;1038     */
;;;1039   void HAL_RCC_EnableCSS(void)
000000  4901              LDR      r1,|L5.8|
;;;1040   {
;;;1041     *(__IO uint32_t *) RCC_CR_CSSON_BB = (uint32_t)ENABLE;
000002  2001              MOVS     r0,#1
000004  64c8              STR      r0,[r1,#0x4c]
;;;1042   }
000006  4770              BX       lr
;;;1043   
                          ENDP

                  |L5.8|
                          DCD      0x42420000

                          AREA ||i.HAL_RCC_GetClockConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetClockConfig PROC
;;;1311     */
;;;1312   void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
000000  220f              MOVS     r2,#0xf
;;;1313   {
;;;1314     /* Check the parameters */
;;;1315     assert_param(RCC_ClkInitStruct != NULL);
;;;1316     assert_param(pFLatency != NULL);
;;;1317   
;;;1318     /* Set all possible values for the Clock type parameter --------------------*/
;;;1319     RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
;;;1320     
;;;1321     /* Get the SYSCLK configuration --------------------------------------------*/ 
;;;1322     RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
000002  6002              STR      r2,[r0,#0]
000004  4a0c              LDR      r2,|L6.56|
000006  6853              LDR      r3,[r2,#4]
000008  f0030303          AND      r3,r3,#3
;;;1323     
;;;1324     /* Get the HCLK configuration ----------------------------------------------*/ 
;;;1325     RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE); 
00000c  6043              STR      r3,[r0,#4]
00000e  6853              LDR      r3,[r2,#4]
000010  f00303f0          AND      r3,r3,#0xf0
;;;1326     
;;;1327     /* Get the APB1 configuration ----------------------------------------------*/ 
;;;1328     RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);   
000014  6083              STR      r3,[r0,#8]
000016  6853              LDR      r3,[r2,#4]
000018  f40363e0          AND      r3,r3,#0x700
;;;1329     
;;;1330     /* Get the APB2 configuration ----------------------------------------------*/ 
;;;1331     RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
00001c  60c3              STR      r3,[r0,#0xc]
00001e  6852              LDR      r2,[r2,#4]
;;;1332     
;;;1333   #if   defined(FLASH_ACR_LATENCY)
;;;1334     /* Get the Flash Wait State (Latency) configuration ------------------------*/   
;;;1335     *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY); 
;;;1336   #else
;;;1337     /* For VALUE lines devices, only LATENCY_0 can be set*/
;;;1338     *pFLatency = (uint32_t)FLASH_LATENCY_0; 
;;;1339   #endif
;;;1340   }
000020  f44f63e0          MOV      r3,#0x700
000024  ea0302d2          AND      r2,r3,r2,LSR #3
000028  6102              STR      r2,[r0,#0x10]         ;1335
00002a  4804              LDR      r0,|L6.60|
00002c  6800              LDR      r0,[r0,#0]            ;1335
00002e  f0000007          AND      r0,r0,#7              ;1335
000032  6008              STR      r0,[r1,#0]            ;1335
000034  4770              BX       lr
;;;1341   
                          ENDP

000036  0000              DCW      0x0000
                  |L6.56|
                          DCD      0x40021000
                  |L6.60|
                          DCD      0x40022000

                          AREA ||i.HAL_RCC_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetHCLKFreq PROC
;;;1175     */
;;;1176   uint32_t HAL_RCC_GetHCLKFreq(void)
000000  4801              LDR      r0,|L7.8|
;;;1177   {
;;;1178     return SystemCoreClock;
000002  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;1179   }
000004  4770              BX       lr
;;;1180   
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_RCC_GetOscConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetOscConfig PROC
;;;1211     */
;;;1212   void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
000000  b510              PUSH     {r4,lr}
;;;1213   {
;;;1214     /* Check the parameters */
;;;1215     assert_param(RCC_OscInitStruct != NULL);
;;;1216   
;;;1217     /* Set all possible values for the Oscillator type parameter ---------------*/
;;;1218     RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI  \
000002  210f              MOVS     r1,#0xf
;;;1219                     | RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI;
;;;1220   
;;;1221   #if defined(RCC_CFGR2_PREDIV1SRC)
;;;1222     /* Get the Prediv1 source --------------------------------------------------*/
;;;1223     RCC_OscInitStruct->Prediv1Source = READ_BIT(RCC->CFGR2,RCC_CFGR2_PREDIV1SRC);
;;;1224   #endif /* RCC_CFGR2_PREDIV1SRC */
;;;1225   
;;;1226     /* Get the HSE configuration -----------------------------------------------*/
;;;1227     if((RCC->CR &RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
000004  6001              STR      r1,[r0,#0]
000006  4921              LDR      r1,|L8.140|
000008  680a              LDR      r2,[r1,#0]
00000a  0353              LSLS     r3,r2,#13
00000c  f04f0200          MOV      r2,#0
000010  d502              BPL      |L8.24|
;;;1228     {
;;;1229       RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
000012  f44f23a0          MOV      r3,#0x50000
000016  e004              B        |L8.34|
                  |L8.24|
;;;1230     }
;;;1231     else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)
000018  680b              LDR      r3,[r1,#0]
00001a  03db              LSLS     r3,r3,#15
00001c  d503              BPL      |L8.38|
;;;1232     {
;;;1233       RCC_OscInitStruct->HSEState = RCC_HSE_ON;
00001e  f44f3380          MOV      r3,#0x10000
                  |L8.34|
000022  6043              STR      r3,[r0,#4]
000024  e000              B        |L8.40|
                  |L8.38|
;;;1234     }
;;;1235     else
;;;1236     {
;;;1237       RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
000026  6042              STR      r2,[r0,#4]
                  |L8.40|
;;;1238     }
;;;1239     RCC_OscInitStruct->HSEPredivValue = __HAL_RCC_HSE_GET_PREDIV();
000028  684b              LDR      r3,[r1,#4]
00002a  f4033300          AND      r3,r3,#0x20000
;;;1240   
;;;1241     /* Get the HSI configuration -----------------------------------------------*/
;;;1242     if((RCC->CR &RCC_CR_HSION) == RCC_CR_HSION)
00002e  6083              STR      r3,[r0,#8]
000030  680b              LDR      r3,[r1,#0]
000032  07dc              LSLS     r4,r3,#31
;;;1243     {
;;;1244       RCC_OscInitStruct->HSIState = RCC_HSI_ON;
000034  f04f0301          MOV      r3,#1
000038  d001              BEQ      |L8.62|
00003a  6103              STR      r3,[r0,#0x10]
00003c  e000              B        |L8.64|
                  |L8.62|
;;;1245     }
;;;1246     else
;;;1247     {
;;;1248       RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
00003e  6102              STR      r2,[r0,#0x10]
                  |L8.64|
;;;1249     }
;;;1250     
;;;1251     RCC_OscInitStruct->HSICalibrationValue = (uint32_t)((RCC->CR & RCC_CR_HSITRIM) >> RCC_CR_HSITRIM_Pos);
000040  680c              LDR      r4,[r1,#0]
000042  f3c404c4          UBFX     r4,r4,#3,#5
;;;1252     
;;;1253     /* Get the LSE configuration -----------------------------------------------*/
;;;1254     if((RCC->BDCR &RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
000046  6144              STR      r4,[r0,#0x14]
000048  6a0c              LDR      r4,[r1,#0x20]
00004a  0764              LSLS     r4,r4,#29
00004c  d502              BPL      |L8.84|
;;;1255     {
;;;1256       RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
00004e  2405              MOVS     r4,#5
000050  60c4              STR      r4,[r0,#0xc]
000052  e005              B        |L8.96|
                  |L8.84|
;;;1257     }
;;;1258     else if((RCC->BDCR &RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
000054  6a0c              LDR      r4,[r1,#0x20]
000056  07e4              LSLS     r4,r4,#31
000058  d001              BEQ      |L8.94|
;;;1259     {
;;;1260       RCC_OscInitStruct->LSEState = RCC_LSE_ON;
00005a  60c3              STR      r3,[r0,#0xc]
00005c  e000              B        |L8.96|
                  |L8.94|
;;;1261     }
;;;1262     else
;;;1263     {
;;;1264       RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
00005e  60c2              STR      r2,[r0,#0xc]
                  |L8.96|
;;;1265     }
;;;1266     
;;;1267     /* Get the LSI configuration -----------------------------------------------*/
;;;1268     if((RCC->CSR &RCC_CSR_LSION) == RCC_CSR_LSION)
000060  6a4c              LDR      r4,[r1,#0x24]
000062  07e4              LSLS     r4,r4,#31
000064  d001              BEQ      |L8.106|
;;;1269     {
;;;1270       RCC_OscInitStruct->LSIState = RCC_LSI_ON;
000066  6183              STR      r3,[r0,#0x18]
000068  e000              B        |L8.108|
                  |L8.106|
;;;1271     }
;;;1272     else
;;;1273     {
;;;1274       RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
00006a  6182              STR      r2,[r0,#0x18]
                  |L8.108|
;;;1275     }
;;;1276     
;;;1277   
;;;1278     /* Get the PLL configuration -----------------------------------------------*/
;;;1279     if((RCC->CR &RCC_CR_PLLON) == RCC_CR_PLLON)
00006c  680a              LDR      r2,[r1,#0]
00006e  01d2              LSLS     r2,r2,#7
000070  d502              BPL      |L8.120|
;;;1280     {
;;;1281       RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
000072  2202              MOVS     r2,#2
000074  61c2              STR      r2,[r0,#0x1c]
000076  e000              B        |L8.122|
                  |L8.120|
;;;1282     }
;;;1283     else
;;;1284     {
;;;1285       RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
000078  61c3              STR      r3,[r0,#0x1c]
                  |L8.122|
;;;1286     }
;;;1287     RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLSRC);
00007a  684a              LDR      r2,[r1,#4]
00007c  f4023280          AND      r2,r2,#0x10000
;;;1288     RCC_OscInitStruct->PLL.PLLMUL = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLMULL);
000080  6202              STR      r2,[r0,#0x20]
000082  6849              LDR      r1,[r1,#4]
000084  f4011170          AND      r1,r1,#0x3c0000
000088  6241              STR      r1,[r0,#0x24]
;;;1289   #if defined(RCC_CR_PLL2ON)
;;;1290     /* Get the PLL2 configuration -----------------------------------------------*/
;;;1291     if((RCC->CR &RCC_CR_PLL2ON) == RCC_CR_PLL2ON)
;;;1292     {
;;;1293       RCC_OscInitStruct->PLL2.PLL2State = RCC_PLL2_ON;
;;;1294     }
;;;1295     else
;;;1296     {
;;;1297       RCC_OscInitStruct->PLL2.PLL2State = RCC_PLL2_OFF;
;;;1298     }
;;;1299     RCC_OscInitStruct->PLL2.HSEPrediv2Value = __HAL_RCC_HSE_GET_PREDIV2();
;;;1300     RCC_OscInitStruct->PLL2.PLL2MUL = (uint32_t)(RCC->CFGR2 & RCC_CFGR2_PLL2MUL);
;;;1301   #endif /* RCC_CR_PLL2ON */
;;;1302   }
00008a  bd10              POP      {r4,pc}
;;;1303   
                          ENDP

                  |L8.140|
                          DCD      0x40021000

                          AREA ||i.HAL_RCC_GetPCLK1Freq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetPCLK1Freq PROC
;;;1186     */
;;;1187   uint32_t HAL_RCC_GetPCLK1Freq(void)
000000  4804              LDR      r0,|L9.20|
;;;1188   {
;;;1189     /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
;;;1190     return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
000002  4905              LDR      r1,|L9.24|
000004  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000006  6849              LDR      r1,[r1,#4]
000008  4a04              LDR      r2,|L9.28|
00000a  f3c12102          UBFX     r1,r1,#8,#3
00000e  5c51              LDRB     r1,[r2,r1]
000010  40c8              LSRS     r0,r0,r1
;;;1191   }    
000012  4770              BX       lr
;;;1192   
                          ENDP

                  |L9.20|
                          DCD      SystemCoreClock
                  |L9.24|
                          DCD      0x40021000
                  |L9.28|
                          DCD      APBPrescTable

                          AREA ||i.HAL_RCC_GetPCLK2Freq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetPCLK2Freq PROC
;;;1198     */
;;;1199   uint32_t HAL_RCC_GetPCLK2Freq(void)
000000  4804              LDR      r0,|L10.20|
;;;1200   {
;;;1201     /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
;;;1202     return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
000002  4905              LDR      r1,|L10.24|
000004  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000006  6849              LDR      r1,[r1,#4]
000008  4a04              LDR      r2,|L10.28|
00000a  f3c121c2          UBFX     r1,r1,#11,#3
00000e  5c51              LDRB     r1,[r2,r1]
000010  40c8              LSRS     r0,r0,r1
;;;1203   } 
000012  4770              BX       lr
;;;1204   
                          ENDP

                  |L10.20|
                          DCD      SystemCoreClock
                  |L10.24|
                          DCD      0x40021000
                  |L10.28|
                          DCD      APBPrescTable

                          AREA ||i.HAL_RCC_GetSysClockFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetSysClockFreq PROC
;;;1081     */
;;;1082   uint32_t HAL_RCC_GetSysClockFreq(void)
000000  a112              ADR      r1,|L11.76|
;;;1083   {
000002  b085              SUB      sp,sp,#0x14
;;;1084   #if defined(RCC_CFGR2_PREDIV1SRC)
;;;1085     const uint8_t aPLLMULFactorTable[14] = {0, 0, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 13};
;;;1086     const uint8_t aPredivFactorTable[16] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
;;;1087   #else
;;;1088     const uint8_t aPLLMULFactorTable[16] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16};
000004  c90f              LDM      r1,{r0-r3}
000006  e88d000f          STM      sp,{r0-r3}
;;;1089   #if defined(RCC_CFGR2_PREDIV1)
;;;1090     const uint8_t aPredivFactorTable[16] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
;;;1091   #else
;;;1092     const uint8_t aPredivFactorTable[2] = {1, 2};
00000a  a014              ADR      r0,|L11.92|
;;;1093   #endif /*RCC_CFGR2_PREDIV1*/
;;;1094   
;;;1095   #endif
;;;1096     uint32_t tmpreg = 0U, prediv = 0U, pllclk = 0U, pllmul = 0U;
;;;1097     uint32_t sysclockfreq = 0U;
;;;1098   #if defined(RCC_CFGR2_PREDIV1SRC)
;;;1099     uint32_t prediv2 = 0U, pll2mul = 0U;
;;;1100   #endif /*RCC_CFGR2_PREDIV1SRC*/
;;;1101   
;;;1102     tmpreg = RCC->CFGR;
00000c  4a14              LDR      r2,|L11.96|
00000e  6800              LDR      r0,[r0,#0]            ;1092
000010  9004              STR      r0,[sp,#0x10]
000012  6851              LDR      r1,[r2,#4]
;;;1103   
;;;1104     /* Get SYSCLK source -------------------------------------------------------*/
;;;1105     switch (tmpreg & RCC_CFGR_SWS)
;;;1106     {
;;;1107       case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock */
;;;1108       {
;;;1109         sysclockfreq = HSE_VALUE;
000014  4813              LDR      r0,|L11.100|
000016  f001030c          AND      r3,r1,#0xc            ;1105
00001a  2b04              CMP      r3,#4                 ;1105
00001c  d010              BEQ      |L11.64|
00001e  2b08              CMP      r3,#8                 ;1105
000020  d10e              BNE      |L11.64|
;;;1110         break;
;;;1111       }
;;;1112       case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
;;;1113       {
;;;1114         pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMULL) >> RCC_CFGR_PLLMULL_Pos];
000022  f3c14383          UBFX     r3,r1,#18,#4
;;;1115         if ((tmpreg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
000026  03c9              LSLS     r1,r1,#15
000028  f81d0003          LDRB     r0,[sp,r3]            ;1114
00002c  d50a              BPL      |L11.68|
;;;1116         {
;;;1117   #if defined(RCC_CFGR2_PREDIV1)
;;;1118           prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV1) >> RCC_CFGR2_PREDIV1_Pos];
;;;1119   #else
;;;1120           prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos];
00002e  6851              LDR      r1,[r2,#4]
000030  aa04              ADD      r2,sp,#0x10
000032  f3c14140          UBFX     r1,r1,#17,#1
000036  5c51              LDRB     r1,[r2,r1]
;;;1121   #endif /*RCC_CFGR2_PREDIV1*/
;;;1122   #if defined(RCC_CFGR2_PREDIV1SRC)
;;;1123   
;;;1124           if(HAL_IS_BIT_SET(RCC->CFGR2, RCC_CFGR2_PREDIV1SRC))
;;;1125           {
;;;1126             /* PLL2 selected as Prediv1 source */
;;;1127             /* PLLCLK = PLL2CLK / PREDIV1 * PLLMUL with PLL2CLK = HSE/PREDIV2 * PLL2MUL */
;;;1128             prediv2 = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> RCC_CFGR2_PREDIV2_Pos) + 1;
;;;1129             pll2mul = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> RCC_CFGR2_PLL2MUL_Pos) + 2;
;;;1130             pllclk = (uint32_t)(((uint64_t)HSE_VALUE * (uint64_t)pll2mul * (uint64_t)pllmul) / ((uint64_t)prediv2 * (uint64_t)prediv));
;;;1131           }
;;;1132           else
;;;1133           {
;;;1134             /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
;;;1135             pllclk = (uint32_t)((HSE_VALUE * pllmul) / prediv);
;;;1136           }
;;;1137   
;;;1138           /* If PLLMUL was set to 13 means that it was to cover the case PLLMUL 6.5 (avoid using float) */
;;;1139           /* In this case need to divide pllclk by 2 */
;;;1140           if (pllmul == aPLLMULFactorTable[(uint32_t)(RCC_CFGR_PLLMULL6_5) >> RCC_CFGR_PLLMULL_Pos])
;;;1141           {
;;;1142               pllclk = pllclk / 2;
;;;1143           }
;;;1144   #else
;;;1145           /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
;;;1146           pllclk = (uint32_t)((HSE_VALUE  * pllmul) / prediv);
000038  4a0a              LDR      r2,|L11.100|
00003a  4350              MULS     r0,r2,r0
00003c  fbb0f0f1          UDIV     r0,r0,r1
                  |L11.64|
;;;1147   #endif /*RCC_CFGR2_PREDIV1SRC*/
;;;1148         }
;;;1149         else
;;;1150         {
;;;1151           /* HSI used as PLL clock source : PLLCLK = HSI/2 * PLLMUL */
;;;1152           pllclk = (uint32_t)((HSI_VALUE >> 1) * pllmul);
;;;1153         }
;;;1154         sysclockfreq = pllclk;
;;;1155         break;
;;;1156       }
;;;1157       case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
;;;1158       default: /* HSI used as system clock */
;;;1159       {
;;;1160         sysclockfreq = HSI_VALUE;
;;;1161         break;
;;;1162       }
;;;1163     }
;;;1164     return sysclockfreq;
;;;1165   }
000040  b005              ADD      sp,sp,#0x14
000042  4770              BX       lr
                  |L11.68|
000044  4908              LDR      r1,|L11.104|
000046  4348              MULS     r0,r1,r0              ;1152
000048  e7fa              B        |L11.64|
;;;1166   
                          ENDP

00004a  0000              DCW      0x0000
                  |L11.76|
00004c  02030405          DCB      2,3,4,5,6,"\a\b\t\n\v\f\r",14,15,16,16
000050  06070809
000054  0a0b0c0d
000058  0e0f1010
                  |L11.92|
00005c  010200            DCB      1,2,0
00005f  00                DCB      0
                  |L11.96|
                          DCD      0x40021000
                  |L11.100|
                          DCD      0x007a1200
                  |L11.104|
                          DCD      0x003d0900

                          AREA ||i.HAL_RCC_MCOConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_MCOConfig PROC
;;;1001     */
;;;1002   void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
000000  b530              PUSH     {r4,r5,lr}
;;;1003   {
000002  b085              SUB      sp,sp,#0x14
;;;1004     GPIO_InitTypeDef gpio = {0U};
000004  2000              MOVS     r0,#0
;;;1005   
;;;1006     /* Check the parameters */
;;;1007     assert_param(IS_RCC_MCO(RCC_MCOx));
;;;1008     assert_param(IS_RCC_MCODIV(RCC_MCODiv));
;;;1009     assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));
;;;1010   
;;;1011     /* Prevent unused argument(s) compilation warning */
;;;1012     UNUSED(RCC_MCOx);
;;;1013     UNUSED(RCC_MCODiv);
;;;1014   
;;;1015     /* Configure the MCO1 pin in alternate function mode */
;;;1016     gpio.Mode      = GPIO_MODE_AF_PP;
000006  9002              STR      r0,[sp,#8]
000008  2002              MOVS     r0,#2
;;;1017     gpio.Speed     = GPIO_SPEED_FREQ_HIGH;
00000a  9001              STR      r0,[sp,#4]
00000c  2003              MOVS     r0,#3
;;;1018     gpio.Pull      = GPIO_NOPULL;
;;;1019     gpio.Pin       = MCO1_PIN;
00000e  9003              STR      r0,[sp,#0xc]
;;;1020   
;;;1021     /* MCO1 Clock Enable */
;;;1022     MCO1_CLK_ENABLE();
000010  4c0b              LDR      r4,|L12.64|
000012  f44f7080          MOV      r0,#0x100             ;1019
000016  9000              STR      r0,[sp,#0]
000018  69a0              LDR      r0,[r4,#0x18]
00001a  460d              MOV      r5,r1                 ;1003
00001c  f0400004          ORR      r0,r0,#4
000020  61a0              STR      r0,[r4,#0x18]
000022  69a0              LDR      r0,[r4,#0x18]
;;;1023   
;;;1024     HAL_GPIO_Init(MCO1_GPIO_PORT, &gpio);
000024  4669              MOV      r1,sp
000026  f0000004          AND      r0,r0,#4              ;1022
00002a  9004              STR      r0,[sp,#0x10]
00002c  4805              LDR      r0,|L12.68|
00002e  f7fffffe          BL       HAL_GPIO_Init
;;;1025   
;;;1026     /* Configure the MCO clock source */
;;;1027     __HAL_RCC_MCO1_CONFIG(RCC_MCOSource, RCC_MCODiv);
000032  6860              LDR      r0,[r4,#4]
000034  f02060e0          BIC      r0,r0,#0x7000000
000038  4328              ORRS     r0,r0,r5
00003a  6060              STR      r0,[r4,#4]
;;;1028   }
00003c  b005              ADD      sp,sp,#0x14
00003e  bd30              POP      {r4,r5,pc}
;;;1029   
                          ENDP

                  |L12.64|
                          DCD      0x40021000
                  |L12.68|
                          DCD      0x40010800

                          AREA ||i.HAL_RCC_NMI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_RCC_NMI_IRQHandler PROC
;;;1346     */
;;;1347   void HAL_RCC_NMI_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1348   {
;;;1349     /* Check RCC CSSF flag  */
;;;1350     if(__HAL_RCC_GET_IT(RCC_IT_CSS))
000002  4c04              LDR      r4,|L13.20|
000004  68a0              LDR      r0,[r4,#8]
000006  0600              LSLS     r0,r0,#24
000008  d503              BPL      |L13.18|
;;;1351     {
;;;1352       /* RCC Clock Security System interrupt user callback */
;;;1353       HAL_RCC_CSSCallback();
00000a  f7fffffe          BL       HAL_RCC_CSSCallback
;;;1354       
;;;1355       /* Clear RCC CSS pending bit */
;;;1356       __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
00000e  2080              MOVS     r0,#0x80
000010  72a0              STRB     r0,[r4,#0xa]
                  |L13.18|
;;;1357     }
;;;1358   }
000012  bd10              POP      {r4,pc}
;;;1359   
                          ENDP

                  |L13.20|
                          DCD      0x40021000

                          AREA ||i.HAL_RCC_OscConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_OscConfig PROC
;;;362      */
;;;363    HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;364    {
000004  4604              MOV      r4,r0
;;;365       uint32_t tickstart = 0U;
;;;366      
;;;367      /* Check the parameters */
;;;368      assert_param(RCC_OscInitStruct != NULL);
;;;369      assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
;;;370      
;;;371      /*------------------------------- HSE Configuration ------------------------*/ 
;;;372      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
000006  7800              LDRB     r0,[r0,#0]
;;;373      {
;;;374        /* Check the parameters */
;;;375        assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
;;;376            
;;;377        /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
;;;378        if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
000008  4db9              LDR      r5,|L14.752|
00000a  07c0              LSLS     r0,r0,#31             ;372
00000c  d048              BEQ      |L14.160|
00000e  6868              LDR      r0,[r5,#4]
000010  f3c00081          UBFX     r0,r0,#2,#2
000014  2801              CMP      r0,#1
000016  d007              BEQ      |L14.40|
;;;379           || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
000018  6868              LDR      r0,[r5,#4]
00001a  f3c00081          UBFX     r0,r0,#2,#2
00001e  2802              CMP      r0,#2
000020  d109              BNE      |L14.54|
000022  6868              LDR      r0,[r5,#4]
000024  03c0              LSLS     r0,r0,#15
000026  d506              BPL      |L14.54|
                  |L14.40|
;;;380        {
;;;381          if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
000028  6828              LDR      r0,[r5,#0]
00002a  0380              LSLS     r0,r0,#14
00002c  d538              BPL      |L14.160|
00002e  6860              LDR      r0,[r4,#4]
000030  2800              CMP      r0,#0
000032  d06f              BEQ      |L14.276|
000034  e034              B        |L14.160|
                  |L14.54|
;;;382          {
;;;383            return HAL_ERROR;
;;;384          }
;;;385        }
;;;386        else
;;;387        {
;;;388          /* Set the new HSE configuration ---------------------------------------*/
;;;389          __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
000036  6860              LDR      r0,[r4,#4]
000038  f5b03f80          CMP      r0,#0x10000
00003c  d00b              BEQ      |L14.86|
00003e  b110              CBZ      r0,|L14.70|
000040  f5b02fa0          CMP      r0,#0x50000
000044  d011              BEQ      |L14.106|
                  |L14.70|
000046  6828              LDR      r0,[r5,#0]
000048  f4203080          BIC      r0,r0,#0x10000
00004c  6028              STR      r0,[r5,#0]
00004e  6828              LDR      r0,[r5,#0]
000050  f4202080          BIC      r0,r0,#0x40000
000054  e002              B        |L14.92|
                  |L14.86|
000056  6828              LDR      r0,[r5,#0]
000058  f4403080          ORR      r0,r0,#0x10000
                  |L14.92|
00005c  6028              STR      r0,[r5,#0]
;;;390          
;;;391    
;;;392           /* Check the HSE State */
;;;393          if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
00005e  6860              LDR      r0,[r4,#4]
000060  b188              CBZ      r0,|L14.134|
;;;394          {
;;;395            /* Get Start Tick */
;;;396            tickstart = HAL_GetTick();
000062  f7fffffe          BL       HAL_GetTick
000066  4606              MOV      r6,r0
;;;397            
;;;398            /* Wait till HSE is ready */
;;;399            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
000068  e009              B        |L14.126|
                  |L14.106|
00006a  6828              LDR      r0,[r5,#0]            ;389
00006c  f4402080          ORR      r0,r0,#0x40000        ;389
000070  6028              STR      r0,[r5,#0]            ;389
000072  e7f0              B        |L14.86|
                  |L14.116|
;;;400            {
;;;401              if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
000074  f7fffffe          BL       HAL_GetTick
000078  1b80              SUBS     r0,r0,r6
00007a  2864              CMP      r0,#0x64
                  |L14.124|
00007c  d875              BHI      |L14.362|
                  |L14.126|
00007e  6828              LDR      r0,[r5,#0]            ;399
000080  0380              LSLS     r0,r0,#14             ;399
000082  d5f7              BPL      |L14.116|
000084  e00c              B        |L14.160|
                  |L14.134|
;;;402              {
;;;403                return HAL_TIMEOUT;
;;;404              }
;;;405            }
;;;406          }
;;;407          else
;;;408          {
;;;409            /* Get Start Tick */
;;;410            tickstart = HAL_GetTick();
000086  f7fffffe          BL       HAL_GetTick
00008a  4606              MOV      r6,r0
;;;411            
;;;412            /* Wait till HSE is disabled */
;;;413            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
00008c  e005              B        |L14.154|
;;;414            {
;;;415               if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
00008e  bf00              NOP      
                  |L14.144|
000090  f7fffffe          BL       HAL_GetTick
000094  1b80              SUBS     r0,r0,r6
000096  2864              CMP      r0,#0x64
000098  d8f0              BHI      |L14.124|
                  |L14.154|
00009a  6828              LDR      r0,[r5,#0]            ;413
00009c  0380              LSLS     r0,r0,#14             ;413
00009e  d4f7              BMI      |L14.144|
                  |L14.160|
;;;416              {
;;;417                return HAL_TIMEOUT;
;;;418              }
;;;419            }
;;;420          }
;;;421        }
;;;422      }
;;;423      /*----------------------------- HSI Configuration --------------------------*/ 
;;;424      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
0000a0  7820              LDRB     r0,[r4,#0]
;;;425      {
;;;426        /* Check the parameters */
;;;427        assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
;;;428        assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
;;;429        
;;;430        /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
;;;431        if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
;;;432           || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI_DIV2)))
;;;433        {
;;;434          /* When HSI is used as system clock it will not disabled */
;;;435          if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
;;;436          {
;;;437            return HAL_ERROR;
;;;438          }
;;;439          /* Otherwise, just the calibration is allowed */
;;;440          else
;;;441          {
;;;442            /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
;;;443            __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
;;;444          }
;;;445        }
;;;446        else
;;;447        {
;;;448          /* Check the HSI State */
;;;449          if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
;;;450          {
;;;451           /* Enable the Internal High Speed oscillator (HSI). */
;;;452            __HAL_RCC_HSI_ENABLE();
0000a2  4e94              LDR      r6,|L14.756|
0000a4  0780              LSLS     r0,r0,#30             ;424
0000a6  f04f0901          MOV      r9,#1                 ;383
0000aa  f04f0800          MOV      r8,#0                 ;383
0000ae  d53b              BPL      |L14.296|
0000b0  6868              LDR      r0,[r5,#4]            ;431
0000b2  f0100f0c          TST      r0,#0xc               ;431
0000b6  d007              BEQ      |L14.200|
0000b8  6868              LDR      r0,[r5,#4]            ;432
0000ba  f3c00081          UBFX     r0,r0,#2,#2           ;432
0000be  2802              CMP      r0,#2                 ;432
0000c0  d109              BNE      |L14.214|
0000c2  6868              LDR      r0,[r5,#4]            ;432
0000c4  03c0              LSLS     r0,r0,#15             ;432
0000c6  d406              BMI      |L14.214|
                  |L14.200|
0000c8  6828              LDR      r0,[r5,#0]            ;435
0000ca  0780              LSLS     r0,r0,#30             ;435
0000cc  d514              BPL      |L14.248|
0000ce  6920              LDR      r0,[r4,#0x10]         ;435
0000d0  2801              CMP      r0,#1                 ;435
0000d2  d11f              BNE      |L14.276|
0000d4  e010              B        |L14.248|
                  |L14.214|
0000d6  6920              LDR      r0,[r4,#0x10]         ;449
0000d8  b1b0              CBZ      r0,|L14.264|
0000da  f8c69000          STR      r9,[r6,#0]
;;;453            
;;;454            /* Get Start Tick */
;;;455            tickstart = HAL_GetTick();
0000de  f7fffffe          BL       HAL_GetTick
0000e2  4607              MOV      r7,r0
;;;456            
;;;457            /* Wait till HSI is ready */
;;;458            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
0000e4  e005              B        |L14.242|
;;;459            {
;;;460              if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
0000e6  bf00              NOP      
                  |L14.232|
0000e8  f7fffffe          BL       HAL_GetTick
0000ec  1bc0              SUBS     r0,r0,r7
0000ee  2802              CMP      r0,#2
0000f0  d8c4              BHI      |L14.124|
                  |L14.242|
0000f2  6828              LDR      r0,[r5,#0]            ;458
0000f4  0780              LSLS     r0,r0,#30             ;458
0000f6  d5f7              BPL      |L14.232|
                  |L14.248|
;;;461              {
;;;462                return HAL_TIMEOUT;
;;;463              }
;;;464            }
;;;465                    
;;;466            /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
;;;467            __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
0000f8  6828              LDR      r0,[r5,#0]
0000fa  6961              LDR      r1,[r4,#0x14]
0000fc  f02000f8          BIC      r0,r0,#0xf8
000100  ea4000c1          ORR      r0,r0,r1,LSL #3
000104  6028              STR      r0,[r5,#0]
000106  e00f              B        |L14.296|
                  |L14.264|
;;;468          }
;;;469          else
;;;470          {
;;;471            /* Disable the Internal High Speed oscillator (HSI). */
;;;472            __HAL_RCC_HSI_DISABLE();
000108  f8c68000          STR      r8,[r6,#0]
;;;473            
;;;474            /* Get Start Tick */
;;;475            tickstart = HAL_GetTick();
00010c  f7fffffe          BL       HAL_GetTick
000110  4607              MOV      r7,r0
;;;476            
;;;477            /* Wait till HSI is disabled */
;;;478            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
000112  e006              B        |L14.290|
                  |L14.276|
000114  e0e9              B        |L14.746|
;;;479            {
;;;480              if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
000116  bf00              NOP      
                  |L14.280|
000118  f7fffffe          BL       HAL_GetTick
00011c  1bc0              SUBS     r0,r0,r7
00011e  2802              CMP      r0,#2
000120  d823              BHI      |L14.362|
                  |L14.290|
000122  6828              LDR      r0,[r5,#0]            ;478
000124  0780              LSLS     r0,r0,#30             ;478
000126  d4f7              BMI      |L14.280|
                  |L14.296|
;;;481              {
;;;482                return HAL_TIMEOUT;
;;;483              }
;;;484            }
;;;485          }
;;;486        }
;;;487      }
;;;488      /*------------------------------ LSI Configuration -------------------------*/ 
;;;489      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
000128  7820              LDRB     r0,[r4,#0]
00012a  0700              LSLS     r0,r0,#28
00012c  d52c              BPL      |L14.392|
;;;490      {
;;;491        /* Check the parameters */
;;;492        assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
;;;493        
;;;494        /* Check the LSI State */
;;;495        if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
;;;496        {
;;;497          /* Enable the Internal Low Speed oscillator (LSI). */
;;;498          __HAL_RCC_LSI_ENABLE();
00012e  4872              LDR      r0,|L14.760|
000130  69a1              LDR      r1,[r4,#0x18]         ;495
000132  b1d9              CBZ      r1,|L14.364|
000134  f8c09000          STR      r9,[r0,#0]
;;;499          
;;;500          /* Get Start Tick */
;;;501          tickstart = HAL_GetTick();
000138  f7fffffe          BL       HAL_GetTick
00013c  4607              MOV      r7,r0
;;;502          
;;;503          /* Wait till LSI is ready */  
;;;504          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
00013e  e004              B        |L14.330|
                  |L14.320|
;;;505          {
;;;506            if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
000140  f7fffffe          BL       HAL_GetTick
000144  1bc0              SUBS     r0,r0,r7
000146  2802              CMP      r0,#2
000148  d80f              BHI      |L14.362|
                  |L14.330|
00014a  6a68              LDR      r0,[r5,#0x24]         ;504
00014c  0780              LSLS     r0,r0,#30             ;504
00014e  d5f7              BPL      |L14.320|
000150  486a              LDR      r0,|L14.764|
000152  f44f51fa          MOV      r1,#0x1f40            ;504
000156  6800              LDR      r0,[r0,#0]            ;504  ; SystemCoreClock
000158  fbb0f0f1          UDIV     r0,r0,r1              ;504
00015c  9000              STR      r0,[sp,#0]            ;504
                  |L14.350|
00015e  bf00              NOP                            ;504
000160  9800              LDR      r0,[sp,#0]            ;504
000162  1e41              SUBS     r1,r0,#1              ;504
000164  9100              STR      r1,[sp,#0]            ;504
000166  d2fa              BCS      |L14.350|
000168  e00e              B        |L14.392|
                  |L14.362|
00016a  e080              B        |L14.622|
                  |L14.364|
;;;507            {
;;;508              return HAL_TIMEOUT;
;;;509            }
;;;510          }
;;;511          /*  To have a fully stabilized clock in the specified range, a software delay of 1ms 
;;;512              should be added.*/
;;;513          RCC_Delay(1);
;;;514        }
;;;515        else
;;;516        {
;;;517          /* Disable the Internal Low Speed oscillator (LSI). */
;;;518          __HAL_RCC_LSI_DISABLE();
00016c  f8c08000          STR      r8,[r0,#0]
;;;519          
;;;520          /* Get Start Tick */
;;;521          tickstart = HAL_GetTick();
000170  f7fffffe          BL       HAL_GetTick
000174  4607              MOV      r7,r0
;;;522          
;;;523          /* Wait till LSI is disabled */  
;;;524          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
000176  e004              B        |L14.386|
                  |L14.376|
;;;525          {
;;;526            if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
000178  f7fffffe          BL       HAL_GetTick
00017c  1bc0              SUBS     r0,r0,r7
00017e  2802              CMP      r0,#2
000180  d875              BHI      |L14.622|
                  |L14.386|
000182  6a68              LDR      r0,[r5,#0x24]         ;524
000184  0780              LSLS     r0,r0,#30             ;524
000186  d4f7              BMI      |L14.376|
                  |L14.392|
;;;527            {
;;;528              return HAL_TIMEOUT;
;;;529            }
;;;530          }
;;;531        }
;;;532      }
;;;533      /*------------------------------ LSE Configuration -------------------------*/ 
;;;534      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
000188  7820              LDRB     r0,[r4,#0]
00018a  0740              LSLS     r0,r0,#29
00018c  d560              BPL      |L14.592|
;;;535      {
;;;536        FlagStatus       pwrclkchanged = RESET;
;;;537        
;;;538        /* Check the parameters */
;;;539        assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
;;;540    
;;;541        /* Update LSE configuration in Backup Domain control register    */
;;;542        /* Requires to enable write access to Backup Domain of necessary */
;;;543        if(__HAL_RCC_PWR_IS_CLK_DISABLED())
00018e  69e8              LDR      r0,[r5,#0x1c]
000190  2700              MOVS     r7,#0                 ;536
000192  00c0              LSLS     r0,r0,#3
000194  d408              BMI      |L14.424|
;;;544        {
;;;545          __HAL_RCC_PWR_CLK_ENABLE();
000196  69e8              LDR      r0,[r5,#0x1c]
000198  f0405080          ORR      r0,r0,#0x10000000
00019c  61e8              STR      r0,[r5,#0x1c]
00019e  69e8              LDR      r0,[r5,#0x1c]
;;;546          pwrclkchanged = SET;
0001a0  2701              MOVS     r7,#1
0001a2  f0005080          AND      r0,r0,#0x10000000     ;545
0001a6  9000              STR      r0,[sp,#0]
                  |L14.424|
;;;547        }
;;;548        
;;;549        if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
0001a8  4855              LDR      r0,|L14.768|
0001aa  6801              LDR      r1,[r0,#0]
0001ac  05c9              LSLS     r1,r1,#23
0001ae  d413              BMI      |L14.472|
;;;550        {
;;;551          /* Enable write access to Backup domain */
;;;552          SET_BIT(PWR->CR, PWR_CR_DBP);
0001b0  6801              LDR      r1,[r0,#0]
0001b2  4683              MOV      r11,r0
0001b4  f4417180          ORR      r1,r1,#0x100
0001b8  6001              STR      r1,[r0,#0]
;;;553          
;;;554          /* Wait for Backup domain Write protection disable */
;;;555          tickstart = HAL_GetTick();
0001ba  f7fffffe          BL       HAL_GetTick
0001be  4682              MOV      r10,r0
;;;556    
;;;557          while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
0001c0  e006              B        |L14.464|
;;;558          {
;;;559            if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
0001c2  bf00              NOP      
                  |L14.452|
0001c4  f7fffffe          BL       HAL_GetTick
0001c8  eba0000a          SUB      r0,r0,r10
0001cc  2864              CMP      r0,#0x64
0001ce  d84e              BHI      |L14.622|
                  |L14.464|
0001d0  f8db0000          LDR      r0,[r11,#0]           ;557
0001d4  05c0              LSLS     r0,r0,#23             ;557
0001d6  d5f5              BPL      |L14.452|
                  |L14.472|
;;;560            {
;;;561              return HAL_TIMEOUT;
;;;562            }
;;;563          }
;;;564        }
;;;565    
;;;566        /* Set the new LSE configuration -----------------------------------------*/
;;;567        __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
0001d8  68e0              LDR      r0,[r4,#0xc]
0001da  2801              CMP      r0,#1
0001dc  d00a              BEQ      |L14.500|
0001de  b108              CBZ      r0,|L14.484|
0001e0  2805              CMP      r0,#5
0001e2  d013              BEQ      |L14.524|
                  |L14.484|
0001e4  6a28              LDR      r0,[r5,#0x20]
0001e6  f0200001          BIC      r0,r0,#1
0001ea  6228              STR      r0,[r5,#0x20]
0001ec  6a28              LDR      r0,[r5,#0x20]
0001ee  f0200004          BIC      r0,r0,#4
0001f2  e002              B        |L14.506|
                  |L14.500|
0001f4  6a28              LDR      r0,[r5,#0x20]
0001f6  f0400001          ORR      r0,r0,#1
                  |L14.506|
0001fa  6228              STR      r0,[r5,#0x20]
;;;568        /* Check the LSE State */
;;;569        if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
;;;570        {
;;;571          /* Get Start Tick */
;;;572          tickstart = HAL_GetTick();
;;;573          
;;;574          /* Wait till LSE is ready */  
;;;575          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
;;;576          {
;;;577            if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
0001fc  68e0              LDR      r0,[r4,#0xc]
0001fe  f2413b88          MOV      r11,#0x1388
000202  b198              CBZ      r0,|L14.556|
000204  f7fffffe          BL       HAL_GetTick
000208  4682              MOV      r10,r0                ;572
00020a  e00b              B        |L14.548|
                  |L14.524|
00020c  6a28              LDR      r0,[r5,#0x20]         ;567
00020e  f0400004          ORR      r0,r0,#4              ;567
000212  6228              STR      r0,[r5,#0x20]         ;567
000214  e7ee              B        |L14.500|
000216  bf00              NOP      
                  |L14.536|
000218  f7fffffe          BL       HAL_GetTick
00021c  eba0010a          SUB      r1,r0,r10
000220  4559              CMP      r1,r11
000222  d85a              BHI      |L14.730|
                  |L14.548|
000224  6a28              LDR      r0,[r5,#0x20]         ;575
000226  0780              LSLS     r0,r0,#30             ;575
000228  d5f6              BPL      |L14.536|
00022a  e00c              B        |L14.582|
                  |L14.556|
;;;578            {
;;;579              return HAL_TIMEOUT;
;;;580            }
;;;581          }
;;;582        }
;;;583        else
;;;584        {
;;;585          /* Get Start Tick */
;;;586          tickstart = HAL_GetTick();
00022c  f7fffffe          BL       HAL_GetTick
000230  4682              MOV      r10,r0
;;;587          
;;;588          /* Wait till LSE is disabled */  
;;;589          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
000232  e005              B        |L14.576|
                  |L14.564|
;;;590          {
;;;591            if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
000234  f7fffffe          BL       HAL_GetTick
000238  eba0010a          SUB      r1,r0,r10
00023c  4559              CMP      r1,r11
00023e  d84c              BHI      |L14.730|
                  |L14.576|
000240  6a28              LDR      r0,[r5,#0x20]         ;589
000242  0780              LSLS     r0,r0,#30             ;589
000244  d4f6              BMI      |L14.564|
                  |L14.582|
;;;592            {
;;;593              return HAL_TIMEOUT;
;;;594            }
;;;595          }
;;;596        }
;;;597    
;;;598        /* Require to disable power clock if necessary */
;;;599        if(pwrclkchanged == SET)
000246  b11f              CBZ      r7,|L14.592|
;;;600        {
;;;601          __HAL_RCC_PWR_CLK_DISABLE();
000248  69e8              LDR      r0,[r5,#0x1c]
00024a  f0205080          BIC      r0,r0,#0x10000000
00024e  61e8              STR      r0,[r5,#0x1c]
                  |L14.592|
;;;602        }
;;;603      }
;;;604    
;;;605    #if defined(RCC_CR_PLL2ON)
;;;606      /*-------------------------------- PLL2 Configuration -----------------------*/
;;;607      /* Check the parameters */
;;;608      assert_param(IS_RCC_PLL2(RCC_OscInitStruct->PLL2.PLL2State));
;;;609      if ((RCC_OscInitStruct->PLL2.PLL2State) != RCC_PLL2_NONE)
;;;610      {
;;;611        /* This bit can not be cleared if the PLL2 clock is used indirectly as system 
;;;612          clock (i.e. it is used as PLL clock entry that is used as system clock). */
;;;613        if((__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE) && \
;;;614            (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && \
;;;615            ((READ_BIT(RCC->CFGR2,RCC_CFGR2_PREDIV1SRC)) == RCC_CFGR2_PREDIV1SRC_PLL2))
;;;616        {
;;;617          return HAL_ERROR;
;;;618        }
;;;619        else
;;;620        {
;;;621          if((RCC_OscInitStruct->PLL2.PLL2State) == RCC_PLL2_ON)
;;;622          {
;;;623            /* Check the parameters */
;;;624            assert_param(IS_RCC_PLL2_MUL(RCC_OscInitStruct->PLL2.PLL2MUL));
;;;625            assert_param(IS_RCC_HSE_PREDIV2(RCC_OscInitStruct->PLL2.HSEPrediv2Value));
;;;626    
;;;627            /* Prediv2 can be written only when the PLLI2S is disabled. */
;;;628            /* Return an error only if new value is different from the programmed value */
;;;629            if (HAL_IS_BIT_SET(RCC->CR,RCC_CR_PLL3ON) && \
;;;630              (__HAL_RCC_HSE_GET_PREDIV2() != RCC_OscInitStruct->PLL2.HSEPrediv2Value))
;;;631            {
;;;632              return HAL_ERROR;
;;;633            }
;;;634            
;;;635            /* Disable the main PLL2. */
;;;636            __HAL_RCC_PLL2_DISABLE();
;;;637            
;;;638            /* Get Start Tick */
;;;639            tickstart = HAL_GetTick();
;;;640            
;;;641            /* Wait till PLL2 is disabled */
;;;642            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != RESET)
;;;643            {
;;;644              if((HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
;;;645              {
;;;646                return HAL_TIMEOUT;
;;;647              }
;;;648            }
;;;649            
;;;650            /* Configure the HSE prediv2 factor --------------------------------*/
;;;651            __HAL_RCC_HSE_PREDIV2_CONFIG(RCC_OscInitStruct->PLL2.HSEPrediv2Value);
;;;652    
;;;653            /* Configure the main PLL2 multiplication factors. */
;;;654            __HAL_RCC_PLL2_CONFIG(RCC_OscInitStruct->PLL2.PLL2MUL);
;;;655            
;;;656            /* Enable the main PLL2. */
;;;657            __HAL_RCC_PLL2_ENABLE();
;;;658            
;;;659            /* Get Start Tick */
;;;660            tickstart = HAL_GetTick();
;;;661            
;;;662            /* Wait till PLL2 is ready */
;;;663            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY)  == RESET)
;;;664            {
;;;665              if((HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
;;;666              {
;;;667                return HAL_TIMEOUT;
;;;668              }
;;;669            }
;;;670          }
;;;671          else
;;;672          {
;;;673           /* Set PREDIV1 source to HSE */
;;;674            CLEAR_BIT(RCC->CFGR2, RCC_CFGR2_PREDIV1SRC);
;;;675    
;;;676            /* Disable the main PLL2. */
;;;677            __HAL_RCC_PLL2_DISABLE();
;;;678     
;;;679            /* Get Start Tick */
;;;680            tickstart = HAL_GetTick();
;;;681            
;;;682            /* Wait till PLL2 is disabled */  
;;;683            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY)  != RESET)
;;;684            {
;;;685              if((HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
;;;686              {
;;;687                return HAL_TIMEOUT;
;;;688              }
;;;689            }
;;;690          }
;;;691        }
;;;692      }
;;;693    
;;;694    #endif /* RCC_CR_PLL2ON */
;;;695      /*-------------------------------- PLL Configuration -----------------------*/
;;;696      /* Check the parameters */
;;;697      assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
;;;698      if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
000250  69e0              LDR      r0,[r4,#0x1c]
000252  b388              CBZ      r0,|L14.696|
;;;699      {
;;;700        /* Check if the PLL is used as system clock or not */
;;;701        if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
000254  6869              LDR      r1,[r5,#4]
000256  f3c10181          UBFX     r1,r1,#2,#2
00025a  2902              CMP      r1,#2
00025c  d045              BEQ      |L14.746|
;;;702        { 
;;;703          if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
00025e  2802              CMP      r0,#2
;;;704          {
;;;705            /* Check the parameters */
;;;706            assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
;;;707            assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
;;;708      
;;;709            /* Disable the main PLL. */
;;;710            __HAL_RCC_PLL_DISABLE();
;;;711            
;;;712            /* Get Start Tick */
;;;713            tickstart = HAL_GetTick();
;;;714            
;;;715            /* Wait till PLL is disabled */
;;;716            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
;;;717            {
;;;718              if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
;;;719              {
;;;720                return HAL_TIMEOUT;
;;;721              }
;;;722            }
;;;723    
;;;724            /* Configure the HSE prediv factor --------------------------------*/
;;;725            /* It can be written only when the PLL is disabled. Not used in PLL source is different than HSE */
;;;726            if(RCC_OscInitStruct->PLL.PLLSource == RCC_PLLSOURCE_HSE)
;;;727            {
;;;728              /* Check the parameter */
;;;729              assert_param(IS_RCC_HSE_PREDIV(RCC_OscInitStruct->HSEPredivValue));
;;;730    #if defined(RCC_CFGR2_PREDIV1SRC)
;;;731              assert_param(IS_RCC_PREDIV1_SOURCE(RCC_OscInitStruct->Prediv1Source));
;;;732              
;;;733              /* Set PREDIV1 source */
;;;734              SET_BIT(RCC->CFGR2, RCC_OscInitStruct->Prediv1Source);
;;;735    #endif /* RCC_CFGR2_PREDIV1SRC */
;;;736    
;;;737              /* Set PREDIV1 Value */
;;;738              __HAL_RCC_HSE_PREDIV_CONFIG(RCC_OscInitStruct->HSEPredivValue);
;;;739            }
;;;740    
;;;741            /* Configure the main PLL clock source and multiplication factors. */
;;;742            __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
;;;743                                 RCC_OscInitStruct->PLL.PLLMUL);
;;;744            /* Enable the main PLL. */
;;;745            __HAL_RCC_PLL_ENABLE();
;;;746            
;;;747            /* Get Start Tick */
;;;748            tickstart = HAL_GetTick();
;;;749            
;;;750            /* Wait till PLL is ready */
;;;751            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
;;;752            {
;;;753              if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
;;;754              {
;;;755                return HAL_TIMEOUT;
;;;756              }
;;;757            }
;;;758          }
;;;759          else
;;;760          {
;;;761            /* Disable the main PLL. */
;;;762            __HAL_RCC_PLL_DISABLE();
000260  f8c68060          STR      r8,[r6,#0x60]
000264  d004              BEQ      |L14.624|
;;;763     
;;;764            /* Get Start Tick */
;;;765            tickstart = HAL_GetTick();
000266  f7fffffe          BL       HAL_GetTick
00026a  4604              MOV      r4,r0
;;;766            
;;;767            /* Wait till PLL is disabled */  
;;;768            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
00026c  e038              B        |L14.736|
                  |L14.622|
00026e  e034              B        |L14.730|
                  |L14.624|
000270  f7fffffe          BL       HAL_GetTick
000274  4607              MOV      r7,r0                 ;713
000276  e004              B        |L14.642|
                  |L14.632|
000278  f7fffffe          BL       HAL_GetTick
00027c  1bc0              SUBS     r0,r0,r7              ;718
00027e  2802              CMP      r0,#2                 ;718
000280  d82b              BHI      |L14.730|
                  |L14.642|
000282  6828              LDR      r0,[r5,#0]            ;716
000284  0180              LSLS     r0,r0,#6              ;716
000286  d4f7              BMI      |L14.632|
000288  6a20              LDR      r0,[r4,#0x20]         ;726
00028a  f5b03f80          CMP      r0,#0x10000           ;726
00028e  d105              BNE      |L14.668|
000290  6868              LDR      r0,[r5,#4]            ;738
000292  68a1              LDR      r1,[r4,#8]            ;738
000294  f4203000          BIC      r0,r0,#0x20000        ;738
000298  4308              ORRS     r0,r0,r1              ;738
00029a  6068              STR      r0,[r5,#4]            ;738
                  |L14.668|
00029c  e9d40108          LDRD     r0,r1,[r4,#0x20]      ;738
0002a0  4308              ORRS     r0,r0,r1              ;742
0002a2  6869              LDR      r1,[r5,#4]            ;742
0002a4  f4211174          BIC      r1,r1,#0x3d0000       ;742
0002a8  4308              ORRS     r0,r0,r1              ;742
0002aa  6068              STR      r0,[r5,#4]            ;742
0002ac  f8c69060          STR      r9,[r6,#0x60]         ;745
0002b0  f7fffffe          BL       HAL_GetTick
0002b4  4604              MOV      r4,r0                 ;748
0002b6  e006              B        |L14.710|
                  |L14.696|
0002b8  e015              B        |L14.742|
0002ba  bf00              NOP                            ;753
                  |L14.700|
0002bc  f7fffffe          BL       HAL_GetTick
0002c0  1b00              SUBS     r0,r0,r4              ;753
0002c2  2802              CMP      r0,#2                 ;753
0002c4  d809              BHI      |L14.730|
                  |L14.710|
0002c6  6828              LDR      r0,[r5,#0]            ;751
0002c8  0180              LSLS     r0,r0,#6              ;751
0002ca  d5f7              BPL      |L14.700|
0002cc  e00b              B        |L14.742|
;;;769            {
;;;770              if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
0002ce  bf00              NOP      
                  |L14.720|
0002d0  f7fffffe          BL       HAL_GetTick
0002d4  1b00              SUBS     r0,r0,r4
0002d6  2802              CMP      r0,#2
0002d8  d902              BLS      |L14.736|
                  |L14.730|
;;;771              {
;;;772                return HAL_TIMEOUT;
0002da  2003              MOVS     r0,#3
                  |L14.732|
;;;773              }
;;;774            }
;;;775          }
;;;776        }
;;;777        else
;;;778        {
;;;779          return HAL_ERROR;
;;;780        }
;;;781      }
;;;782      
;;;783      return HAL_OK;
;;;784    }
0002dc  e8bd8ff8          POP      {r3-r11,pc}
                  |L14.736|
0002e0  6828              LDR      r0,[r5,#0]            ;768
0002e2  0180              LSLS     r0,r0,#6              ;768
0002e4  d4f4              BMI      |L14.720|
                  |L14.742|
0002e6  2000              MOVS     r0,#0                 ;783
0002e8  e7f8              B        |L14.732|
                  |L14.746|
0002ea  2001              MOVS     r0,#1                 ;779
0002ec  e7f6              B        |L14.732|
;;;785    
                          ENDP

0002ee  0000              DCW      0x0000
                  |L14.752|
                          DCD      0x40021000
                  |L14.756|
                          DCD      0x42420000
                  |L14.760|
                          DCD      0x42420480
                  |L14.764|
                          DCD      SystemCoreClock
                  |L14.768|
                          DCD      0x40007000

;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_rcc_c_b7071a4b____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___19_stm32f1xx_hal_rcc_c_b7071a4b____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_rcc_c_b7071a4b____REVSH|
#line 402
|__asm___19_stm32f1xx_hal_rcc_c_b7071a4b____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_rcc_c_b7071a4b____RRX|
#line 587
|__asm___19_stm32f1xx_hal_rcc_c_b7071a4b____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
