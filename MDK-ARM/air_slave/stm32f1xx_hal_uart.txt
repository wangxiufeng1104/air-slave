; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\stm32f1xx_hal_uart.o --asm_dir=.\air_slave\ --list_dir=.\air_slave\ --depend=.\stm32f1xx_hal_uart.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I.\RTE\_air_slave -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=525 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=.\stm32f1xx_hal_uart.crf ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_uart.c]
                          THUMB

                          AREA ||i.HAL_HalfDuplex_EnableReceiver||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableReceiver PROC
;;;1939     */
;;;1940   HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;1941   {
;;;1942     uint32_t tmpreg = 0x00U;
;;;1943   
;;;1944     /* Process Locked */
;;;1945     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d012              BEQ      |L1.46|
000008  2101              MOVS     r1,#1
00000a  f8001f38          STRB     r1,[r0,#0x38]!
;;;1946   
;;;1947     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  7041              STRB     r1,[r0,#1]
;;;1948   
;;;1949     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;1950     tmpreg = huart->Instance->CR1;
000012  f8501c38          LDR      r1,[r0,#-0x38]
000016  68ca              LDR      r2,[r1,#0xc]
;;;1951   
;;;1952     /* Clear TE and RE bits */
;;;1953     tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
000018  f022020c          BIC      r2,r2,#0xc
;;;1954   
;;;1955     /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
;;;1956     tmpreg |= (uint32_t)USART_CR1_RE;
00001c  f0420204          ORR      r2,r2,#4
;;;1957   
;;;1958     /* Write to USART CR1 */
;;;1959     WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
000020  60ca              STR      r2,[r1,#0xc]
;;;1960   
;;;1961     huart->gState = HAL_UART_STATE_READY;
000022  2120              MOVS     r1,#0x20
000024  7041              STRB     r1,[r0,#1]
;;;1962   
;;;1963     /* Process Unlocked */
;;;1964     __HAL_UNLOCK(huart);
000026  2100              MOVS     r1,#0
000028  7001              STRB     r1,[r0,#0]
;;;1965     
;;;1966     return HAL_OK; 
00002a  4608              MOV      r0,r1
;;;1967   }
00002c  4770              BX       lr
                  |L1.46|
00002e  2002              MOVS     r0,#2                 ;1945
000030  4770              BX       lr
;;;1968   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_EnableTransmitter||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableTransmitter PROC
;;;1904     */
;;;1905   HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;1906   {
;;;1907     uint32_t tmpreg = 0x00U;
;;;1908   
;;;1909     /* Process Locked */
;;;1910     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d012              BEQ      |L2.46|
000008  2101              MOVS     r1,#1
00000a  f8001f38          STRB     r1,[r0,#0x38]!
;;;1911     
;;;1912     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  7041              STRB     r1,[r0,#1]
;;;1913   
;;;1914     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;1915     tmpreg = huart->Instance->CR1;
000012  f8501c38          LDR      r1,[r0,#-0x38]
000016  68ca              LDR      r2,[r1,#0xc]
;;;1916   
;;;1917     /* Clear TE and RE bits */
;;;1918     tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
000018  f022020c          BIC      r2,r2,#0xc
;;;1919   
;;;1920     /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
;;;1921     tmpreg |= (uint32_t)USART_CR1_TE;
00001c  f0420208          ORR      r2,r2,#8
;;;1922   
;;;1923     /* Write to USART CR1 */
;;;1924     WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
000020  60ca              STR      r2,[r1,#0xc]
;;;1925   
;;;1926     huart->gState = HAL_UART_STATE_READY;
000022  2120              MOVS     r1,#0x20
000024  7041              STRB     r1,[r0,#1]
;;;1927     
;;;1928     /* Process Unlocked */
;;;1929     __HAL_UNLOCK(huart);
000026  2100              MOVS     r1,#0
000028  7001              STRB     r1,[r0,#0]
;;;1930     
;;;1931     return HAL_OK; 
00002a  4608              MOV      r0,r1
;;;1932   }
00002c  4770              BX       lr
                  |L2.46|
00002e  2002              MOVS     r0,#2                 ;1910
000030  4770              BX       lr
;;;1933   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_Init||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_Init PROC
;;;323      */
;;;324    HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;325    {
000002  0004              MOVS     r4,r0
000004  d004              BEQ      |L3.16|
;;;326      /* Check the UART handle allocation */
;;;327      if(huart == NULL)
;;;328      {
;;;329        return HAL_ERROR;
;;;330      }
;;;331     
;;;332      /* Check the parameters */ 
;;;333      assert_param(IS_UART_HALFDUPLEX_INSTANCE(huart->Instance));
;;;334      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;335    #if defined(USART_CR1_OVER8)
;;;336      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;337    #endif /* USART_CR1_OVER8 */
;;;338      if(huart->gState == HAL_UART_STATE_RESET)
000006  f8940039          LDRB     r0,[r4,#0x39]
00000a  2500              MOVS     r5,#0
00000c  b110              CBZ      r0,|L3.20|
00000e  e006              B        |L3.30|
                  |L3.16|
000010  2001              MOVS     r0,#1                 ;329
;;;339      {
;;;340        /* Allocate lock resource and initialize it */
;;;341        huart->Lock = HAL_UNLOCKED;
;;;342        /* Init the low level hardware */
;;;343        HAL_UART_MspInit(huart);
;;;344      }
;;;345    
;;;346      huart->gState = HAL_UART_STATE_BUSY;
;;;347    
;;;348      /* Disable the peripheral */
;;;349      __HAL_UART_DISABLE(huart);
;;;350      
;;;351      /* Set the UART Communication parameters */
;;;352      UART_SetConfig(huart);
;;;353      
;;;354      /* In half-duplex mode, the following bits must be kept cleared:
;;;355         - LINEN and CLKEN bits in the USART_CR2 register,
;;;356         - SCEN and IREN bits in the USART_CR3 register.*/
;;;357      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;358      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
;;;359      
;;;360      /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;361      SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
;;;362     
;;;363      /* Enable the peripheral */
;;;364      __HAL_UART_ENABLE(huart);
;;;365      
;;;366      /* Initialize the UART state*/
;;;367      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;368      huart->gState= HAL_UART_STATE_READY;
;;;369      huart->RxState= HAL_UART_STATE_READY;
;;;370      
;;;371      return HAL_OK;
;;;372    }
000012  bd70              POP      {r4-r6,pc}
                  |L3.20|
000014  f8845038          STRB     r5,[r4,#0x38]         ;341
000018  4620              MOV      r0,r4                 ;343
00001a  f7fffffe          BL       HAL_UART_MspInit
                  |L3.30|
00001e  2024              MOVS     r0,#0x24              ;346
000020  f8840039          STRB     r0,[r4,#0x39]         ;346
000024  6820              LDR      r0,[r4,#0]            ;349
000026  68c1              LDR      r1,[r0,#0xc]          ;349
000028  f4215100          BIC      r1,r1,#0x2000         ;349
00002c  60c1              STR      r1,[r0,#0xc]          ;349
00002e  4620              MOV      r0,r4                 ;352
000030  f7fffffe          BL       UART_SetConfig
000034  6820              LDR      r0,[r4,#0]            ;357
000036  6901              LDR      r1,[r0,#0x10]         ;357
000038  f4214190          BIC      r1,r1,#0x4800         ;357
00003c  6101              STR      r1,[r0,#0x10]         ;357
00003e  6820              LDR      r0,[r4,#0]            ;358
000040  6941              LDR      r1,[r0,#0x14]         ;358
000042  f0210122          BIC      r1,r1,#0x22           ;358
000046  6141              STR      r1,[r0,#0x14]         ;358
000048  6820              LDR      r0,[r4,#0]            ;361
00004a  6941              LDR      r1,[r0,#0x14]         ;361
00004c  f0410108          ORR      r1,r1,#8              ;361
000050  6141              STR      r1,[r0,#0x14]         ;361
000052  6820              LDR      r0,[r4,#0]            ;364
000054  68c1              LDR      r1,[r0,#0xc]          ;364
000056  f4415100          ORR      r1,r1,#0x2000         ;364
00005a  60c1              STR      r1,[r0,#0xc]          ;364
00005c  63e5              STR      r5,[r4,#0x3c]         ;367
00005e  2020              MOVS     r0,#0x20              ;368
000060  f8840039          STRB     r0,[r4,#0x39]         ;368
000064  f884003a          STRB     r0,[r4,#0x3a]         ;369
000068  2000              MOVS     r0,#0                 ;371
00006a  bd70              POP      {r4-r6,pc}
;;;373    
                          ENDP


                          AREA ||i.HAL_LIN_Init||, CODE, READONLY, ALIGN=1

                  HAL_LIN_Init PROC
;;;384      */
;;;385    HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
000000  b570              PUSH     {r4-r6,lr}
;;;386    {
000002  460e              MOV      r6,r1
000004  0004              MOVS     r4,r0
000006  d004              BEQ      |L4.18|
;;;387      /* Check the UART handle allocation */
;;;388      if(huart == NULL)
;;;389      {
;;;390        return HAL_ERROR;
;;;391      }
;;;392      
;;;393      /* Check the LIN UART instance */  
;;;394      assert_param(IS_UART_LIN_INSTANCE(huart->Instance));
;;;395      /* Check the Break detection length parameter */
;;;396      assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
;;;397      assert_param(IS_UART_LIN_WORD_LENGTH(huart->Init.WordLength));
;;;398    #if defined(USART_CR1_OVER8)
;;;399      assert_param(IS_UART_LIN_OVERSAMPLING(huart->Init.OverSampling));
;;;400    #endif /* USART_CR1_OVER8 */
;;;401      
;;;402      if(huart->gState == HAL_UART_STATE_RESET)
000008  f8940039          LDRB     r0,[r4,#0x39]
00000c  2500              MOVS     r5,#0
00000e  b110              CBZ      r0,|L4.22|
000010  e006              B        |L4.32|
                  |L4.18|
000012  2001              MOVS     r0,#1                 ;390
;;;403      {
;;;404        /* Allocate lock resource and initialize it */
;;;405        huart->Lock = HAL_UNLOCKED;
;;;406        /* Init the low level hardware */
;;;407        HAL_UART_MspInit(huart);
;;;408      }
;;;409    
;;;410      huart->gState = HAL_UART_STATE_BUSY;
;;;411    
;;;412      /* Disable the peripheral */
;;;413      __HAL_UART_DISABLE(huart);
;;;414      
;;;415      /* Set the UART Communication parameters */
;;;416      UART_SetConfig(huart);
;;;417      
;;;418      /* In LIN mode, the following bits must be kept cleared: 
;;;419         - CLKEN bits in the USART_CR2 register,
;;;420         - SCEN and IREN bits in the USART_CR3 register.*/
;;;421      CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
;;;422      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
;;;423      
;;;424      /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;425      SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
;;;426      
;;;427      /* Set the USART LIN Break detection length. */
;;;428      MODIFY_REG(huart->Instance->CR2, USART_CR2_LBDL, BreakDetectLength);
;;;429      
;;;430      /* Enable the peripheral */
;;;431      __HAL_UART_ENABLE(huart);
;;;432      
;;;433      /* Initialize the UART state*/
;;;434      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;435      huart->gState= HAL_UART_STATE_READY;
;;;436      huart->RxState= HAL_UART_STATE_READY;
;;;437      
;;;438      return HAL_OK;
;;;439    }
000014  bd70              POP      {r4-r6,pc}
                  |L4.22|
000016  f8845038          STRB     r5,[r4,#0x38]         ;405
00001a  4620              MOV      r0,r4                 ;407
00001c  f7fffffe          BL       HAL_UART_MspInit
                  |L4.32|
000020  2024              MOVS     r0,#0x24              ;410
000022  f8840039          STRB     r0,[r4,#0x39]         ;410
000026  6820              LDR      r0,[r4,#0]            ;413
000028  68c1              LDR      r1,[r0,#0xc]          ;413
00002a  f4215100          BIC      r1,r1,#0x2000         ;413
00002e  60c1              STR      r1,[r0,#0xc]          ;413
000030  4620              MOV      r0,r4                 ;416
000032  f7fffffe          BL       UART_SetConfig
000036  6820              LDR      r0,[r4,#0]            ;421
000038  6901              LDR      r1,[r0,#0x10]         ;421
00003a  f4216100          BIC      r1,r1,#0x800          ;421
00003e  6101              STR      r1,[r0,#0x10]         ;421
000040  6820              LDR      r0,[r4,#0]            ;422
000042  6941              LDR      r1,[r0,#0x14]         ;422
000044  f021012a          BIC      r1,r1,#0x2a           ;422
000048  6141              STR      r1,[r0,#0x14]         ;422
00004a  6820              LDR      r0,[r4,#0]            ;425
00004c  6901              LDR      r1,[r0,#0x10]         ;425
00004e  f4414180          ORR      r1,r1,#0x4000         ;425
000052  6101              STR      r1,[r0,#0x10]         ;425
000054  6820              LDR      r0,[r4,#0]            ;428
000056  6901              LDR      r1,[r0,#0x10]         ;428
000058  f0210120          BIC      r1,r1,#0x20           ;428
00005c  4331              ORRS     r1,r1,r6              ;428
00005e  6101              STR      r1,[r0,#0x10]         ;428
000060  6820              LDR      r0,[r4,#0]            ;431
000062  68c1              LDR      r1,[r0,#0xc]          ;431
000064  f4415100          ORR      r1,r1,#0x2000         ;431
000068  60c1              STR      r1,[r0,#0xc]          ;431
00006a  63e5              STR      r5,[r4,#0x3c]         ;434
00006c  2020              MOVS     r0,#0x20              ;435
00006e  f8840039          STRB     r0,[r4,#0x39]         ;435
000072  f884003a          STRB     r0,[r4,#0x3a]         ;436
000076  2000              MOVS     r0,#0                 ;438
000078  bd70              POP      {r4-r6,pc}
;;;440    
                          ENDP


                          AREA ||i.HAL_LIN_SendBreak||, CODE, READONLY, ALIGN=1

                  HAL_LIN_SendBreak PROC
;;;1823     */
;;;1824   HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;1825   {
;;;1826     /* Check the parameters */
;;;1827     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;1828     
;;;1829     /* Process Locked */
;;;1830     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d010              BEQ      |L5.42|
000008  2101              MOVS     r1,#1
00000a  f8001f38          STRB     r1,[r0,#0x38]!
;;;1831     
;;;1832     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  7041              STRB     r1,[r0,#1]
;;;1833     
;;;1834     /* Send break characters */
;;;1835     SET_BIT(huart->Instance->CR1, USART_CR1_SBK);
000012  f8501c38          LDR      r1,[r0,#-0x38]
000016  68ca              LDR      r2,[r1,#0xc]
000018  f0420201          ORR      r2,r2,#1
00001c  60ca              STR      r2,[r1,#0xc]
;;;1836    
;;;1837     huart->gState = HAL_UART_STATE_READY;
00001e  2120              MOVS     r1,#0x20
000020  7041              STRB     r1,[r0,#1]
;;;1838     
;;;1839     /* Process Unlocked */
;;;1840     __HAL_UNLOCK(huart);
000022  2100              MOVS     r1,#0
000024  7001              STRB     r1,[r0,#0]
;;;1841     
;;;1842     return HAL_OK; 
000026  4608              MOV      r0,r1
;;;1843   }
000028  4770              BX       lr
                  |L5.42|
00002a  2002              MOVS     r0,#2                 ;1830
00002c  4770              BX       lr
;;;1844   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnterMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnterMuteMode PROC
;;;1850     */
;;;1851   HAL_StatusTypeDef HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;1852   {
;;;1853     /* Check the parameters */
;;;1854     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;1855     
;;;1856     /* Process Locked */
;;;1857     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d010              BEQ      |L6.42|
000008  2101              MOVS     r1,#1
00000a  f8001f38          STRB     r1,[r0,#0x38]!
;;;1858     
;;;1859     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  7041              STRB     r1,[r0,#1]
;;;1860     
;;;1861     /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;1862     SET_BIT(huart->Instance->CR1, USART_CR1_RWU);
000012  f8501c38          LDR      r1,[r0,#-0x38]
000016  68ca              LDR      r2,[r1,#0xc]
000018  f0420202          ORR      r2,r2,#2
00001c  60ca              STR      r2,[r1,#0xc]
;;;1863     
;;;1864     huart->gState = HAL_UART_STATE_READY;
00001e  2120              MOVS     r1,#0x20
000020  7041              STRB     r1,[r0,#1]
;;;1865     
;;;1866     /* Process Unlocked */
;;;1867     __HAL_UNLOCK(huart);
000022  2100              MOVS     r1,#0
000024  7001              STRB     r1,[r0,#0]
;;;1868     
;;;1869     return HAL_OK; 
000026  4608              MOV      r0,r1
;;;1870   }
000028  4770              BX       lr
                  |L6.42|
00002a  2002              MOVS     r0,#2                 ;1857
00002c  4770              BX       lr
;;;1871   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_ExitMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_ExitMuteMode PROC
;;;1877     */
;;;1878   HAL_StatusTypeDef HAL_MultiProcessor_ExitMuteMode(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;1879   {
;;;1880     /* Check the parameters */
;;;1881     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;1882     
;;;1883     /* Process Locked */
;;;1884     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d010              BEQ      |L7.42|
000008  2101              MOVS     r1,#1
00000a  f8001f38          STRB     r1,[r0,#0x38]!
;;;1885     
;;;1886     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  7041              STRB     r1,[r0,#1]
;;;1887     
;;;1888     /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;1889     CLEAR_BIT(huart->Instance->CR1, USART_CR1_RWU);
000012  f8501c38          LDR      r1,[r0,#-0x38]
000016  68ca              LDR      r2,[r1,#0xc]
000018  f0220202          BIC      r2,r2,#2
00001c  60ca              STR      r2,[r1,#0xc]
;;;1890     
;;;1891     huart->gState = HAL_UART_STATE_READY;
00001e  2120              MOVS     r1,#0x20
000020  7041              STRB     r1,[r0,#1]
;;;1892     
;;;1893     /* Process Unlocked */
;;;1894     __HAL_UNLOCK(huart);
000022  2100              MOVS     r1,#0
000024  7001              STRB     r1,[r0,#0]
;;;1895     
;;;1896     return HAL_OK; 
000026  4608              MOV      r0,r1
;;;1897   }
000028  4770              BX       lr
                  |L7.42|
00002a  2002              MOVS     r0,#2                 ;1884
00002c  4770              BX       lr
;;;1898   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_Init||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_Init PROC
;;;452      */
;;;453    HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;454    {
000004  4616              MOV      r6,r2
000006  460f              MOV      r7,r1
000008  0004              MOVS     r4,r0
00000a  d004              BEQ      |L8.22|
;;;455      /* Check the UART handle allocation */
;;;456      if(huart == NULL)
;;;457      {
;;;458        return HAL_ERROR;
;;;459      }
;;;460    
;;;461      /* Check UART instance capabilities */  
;;;462      assert_param(IS_UART_MULTIPROCESSOR_INSTANCE(huart->Instance));
;;;463    
;;;464      /* Check the Address & wake up method parameters */
;;;465      assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
;;;466      assert_param(IS_UART_ADDRESS(Address));
;;;467      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;468    #if defined(USART_CR1_OVER8)
;;;469      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;470    #endif /* USART_CR1_OVER8 */
;;;471    
;;;472      if(huart->gState == HAL_UART_STATE_RESET)
00000c  f8940039          LDRB     r0,[r4,#0x39]
000010  2500              MOVS     r5,#0
000012  b118              CBZ      r0,|L8.28|
000014  e007              B        |L8.38|
                  |L8.22|
000016  2001              MOVS     r0,#1                 ;458
                  |L8.24|
;;;473      {
;;;474        /* Allocate lock resource and initialize it */
;;;475        huart->Lock = HAL_UNLOCKED;
;;;476        /* Init the low level hardware */
;;;477        HAL_UART_MspInit(huart);
;;;478      }
;;;479    
;;;480      huart->gState = HAL_UART_STATE_BUSY;
;;;481    
;;;482      /* Disable the peripheral */
;;;483      __HAL_UART_DISABLE(huart);
;;;484      
;;;485      /* Set the UART Communication parameters */
;;;486      UART_SetConfig(huart);
;;;487      
;;;488      /* In Multi-Processor mode, the following bits must be kept cleared: 
;;;489         - LINEN and CLKEN bits in the USART_CR2 register,
;;;490         - SCEN, HDSEL and IREN  bits in the USART_CR3 register */
;;;491      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;492      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;493      
;;;494      /* Set the USART address node */
;;;495      MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, Address);
;;;496      
;;;497      /* Set the wake up method by setting the WAKE bit in the CR1 register */
;;;498      MODIFY_REG(huart->Instance->CR1, USART_CR1_WAKE, WakeUpMethod);
;;;499      
;;;500      /* Enable the peripheral */
;;;501      __HAL_UART_ENABLE(huart);
;;;502      
;;;503      /* Initialize the UART state */
;;;504      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;505      huart->gState = HAL_UART_STATE_READY;
;;;506      huart->RxState = HAL_UART_STATE_READY;
;;;507      
;;;508      return HAL_OK;
;;;509    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L8.28|
00001c  f8845038          STRB     r5,[r4,#0x38]         ;475
000020  4620              MOV      r0,r4                 ;477
000022  f7fffffe          BL       HAL_UART_MspInit
                  |L8.38|
000026  2024              MOVS     r0,#0x24              ;480
000028  f8840039          STRB     r0,[r4,#0x39]         ;480
00002c  6820              LDR      r0,[r4,#0]            ;483
00002e  68c1              LDR      r1,[r0,#0xc]          ;483
000030  f4215100          BIC      r1,r1,#0x2000         ;483
000034  60c1              STR      r1,[r0,#0xc]          ;483
000036  4620              MOV      r0,r4                 ;486
000038  f7fffffe          BL       UART_SetConfig
00003c  6820              LDR      r0,[r4,#0]            ;491
00003e  6901              LDR      r1,[r0,#0x10]         ;491
000040  f4214190          BIC      r1,r1,#0x4800         ;491
000044  6101              STR      r1,[r0,#0x10]         ;491
000046  6820              LDR      r0,[r4,#0]            ;492
000048  6941              LDR      r1,[r0,#0x14]         ;492
00004a  f021012a          BIC      r1,r1,#0x2a           ;492
00004e  6141              STR      r1,[r0,#0x14]         ;492
000050  6820              LDR      r0,[r4,#0]            ;495
000052  6901              LDR      r1,[r0,#0x10]         ;495
000054  f021010f          BIC      r1,r1,#0xf            ;495
000058  4339              ORRS     r1,r1,r7              ;495
00005a  6101              STR      r1,[r0,#0x10]         ;495
00005c  6820              LDR      r0,[r4,#0]            ;498
00005e  68c1              LDR      r1,[r0,#0xc]          ;498
000060  f4216100          BIC      r1,r1,#0x800          ;498
000064  4331              ORRS     r1,r1,r6              ;498
000066  60c1              STR      r1,[r0,#0xc]          ;498
000068  6820              LDR      r0,[r4,#0]            ;501
00006a  68c1              LDR      r1,[r0,#0xc]          ;501
00006c  f4415100          ORR      r1,r1,#0x2000         ;501
000070  60c1              STR      r1,[r0,#0xc]          ;501
000072  63e5              STR      r5,[r4,#0x3c]         ;504
000074  2020              MOVS     r0,#0x20              ;505
000076  f8840039          STRB     r0,[r4,#0x39]         ;505
00007a  f884003a          STRB     r0,[r4,#0x3a]         ;506
00007e  2000              MOVS     r0,#0                 ;508
000080  e7ca              B        |L8.24|
;;;510    
                          ENDP


                          AREA ||i.HAL_UART_Abort||, CODE, READONLY, ALIGN=1

                  HAL_UART_Abort PROC
;;;1158   */
;;;1159   HAL_StatusTypeDef HAL_UART_Abort(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1160   {
000002  4604              MOV      r4,r0
;;;1161     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1162     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6800              LDR      r0,[r0,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f42171f0          BIC      r1,r1,#0x1e0
00000c  60c1              STR      r1,[r0,#0xc]
;;;1163     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  f0210101          BIC      r1,r1,#1
000016  6141              STR      r1,[r0,#0x14]
;;;1164     
;;;1165     /* Disable the UART DMA Tx request if enabled */
;;;1166     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000018  6820              LDR      r0,[r4,#0]
00001a  6941              LDR      r1,[r0,#0x14]
00001c  f04f0500          MOV      r5,#0
000020  0609              LSLS     r1,r1,#24
000022  d509              BPL      |L9.56|
;;;1167     {
;;;1168       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000024  6941              LDR      r1,[r0,#0x14]
000026  f0210180          BIC      r1,r1,#0x80
00002a  6141              STR      r1,[r0,#0x14]
;;;1169   
;;;1170       /* Abort the UART DMA Tx channel: use blocking DMA Abort API (no callback) */
;;;1171       if(huart->hdmatx != NULL)
00002c  6b20              LDR      r0,[r4,#0x30]
00002e  b118              CBZ      r0,|L9.56|
;;;1172       {
;;;1173         /* Set the UART DMA Abort callback to Null. 
;;;1174            No call back execution at end of DMA abort procedure */
;;;1175         huart->hdmatx->XferAbortCallback = NULL;
;;;1176   
;;;1177         HAL_DMA_Abort(huart->hdmatx);
000030  6345              STR      r5,[r0,#0x34]
000032  6b20              LDR      r0,[r4,#0x30]
000034  f7fffffe          BL       HAL_DMA_Abort
                  |L9.56|
;;;1178       }
;;;1179     }
;;;1180   
;;;1181     /* Disable the UART DMA Rx request if enabled */
;;;1182     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000038  6820              LDR      r0,[r4,#0]
00003a  6941              LDR      r1,[r0,#0x14]
00003c  0649              LSLS     r1,r1,#25
00003e  d509              BPL      |L9.84|
;;;1183     {
;;;1184       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000040  6941              LDR      r1,[r0,#0x14]
000042  f0210140          BIC      r1,r1,#0x40
000046  6141              STR      r1,[r0,#0x14]
;;;1185   
;;;1186       /* Abort the UART DMA Rx channel: use blocking DMA Abort API (no callback) */
;;;1187       if(huart->hdmarx != NULL)
000048  6b60              LDR      r0,[r4,#0x34]
00004a  b118              CBZ      r0,|L9.84|
;;;1188       {
;;;1189         /* Set the UART DMA Abort callback to Null. 
;;;1190            No call back execution at end of DMA abort procedure */
;;;1191         huart->hdmarx->XferAbortCallback = NULL;
;;;1192   
;;;1193         HAL_DMA_Abort(huart->hdmarx);
00004c  6345              STR      r5,[r0,#0x34]
00004e  6b60              LDR      r0,[r4,#0x34]
000050  f7fffffe          BL       HAL_DMA_Abort
                  |L9.84|
;;;1194       }
;;;1195     }
;;;1196   
;;;1197     /* Reset Tx and Rx transfer counters */
;;;1198     huart->TxXferCount = 0x00U;
000054  84e5              STRH     r5,[r4,#0x26]
;;;1199     huart->RxXferCount = 0x00U;
000056  85e5              STRH     r5,[r4,#0x2e]
;;;1200   
;;;1201     /* Reset ErrorCode */
;;;1202     huart->ErrorCode = HAL_UART_ERROR_NONE;
000058  63e5              STR      r5,[r4,#0x3c]
;;;1203   
;;;1204     /* Restore huart->RxState and huart->gState to Ready */
;;;1205     huart->RxState = HAL_UART_STATE_READY;
00005a  2020              MOVS     r0,#0x20
00005c  f884003a          STRB     r0,[r4,#0x3a]
;;;1206     huart->gState = HAL_UART_STATE_READY;
000060  f8840039          STRB     r0,[r4,#0x39]
;;;1207   
;;;1208     return HAL_OK;
000064  2000              MOVS     r0,#0
;;;1209   }
000066  bd70              POP      {r4-r6,pc}
;;;1210   
                          ENDP


                          AREA ||i.HAL_UART_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortCpltCallback PROC
;;;1755     */
;;;1756   __weak void HAL_UART_AbortCpltCallback (UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1757   {
;;;1758     /* Prevent unused argument(s) compilation warning */
;;;1759     UNUSED(huart);
;;;1760   
;;;1761     /* NOTE : This function should not be modified, when the callback is needed,
;;;1762               the HAL_UART_AbortCpltCallback can be implemented in the user file.
;;;1763      */
;;;1764   }
;;;1765   /**
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceive PROC
;;;1264   */
;;;1265   HAL_StatusTypeDef HAL_UART_AbortReceive(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1266   {
000002  4604              MOV      r4,r0
;;;1267     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1268     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  6800              LDR      r0,[r0,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f4217190          BIC      r1,r1,#0x120
00000c  60c1              STR      r1,[r0,#0xc]
;;;1269     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  f0210101          BIC      r1,r1,#1
000016  6141              STR      r1,[r0,#0x14]
;;;1270   
;;;1271     /* Disable the UART DMA Rx request if enabled */
;;;1272     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000018  6820              LDR      r0,[r4,#0]
00001a  6941              LDR      r1,[r0,#0x14]
00001c  f04f0500          MOV      r5,#0
000020  0649              LSLS     r1,r1,#25
000022  d509              BPL      |L11.56|
;;;1273     {
;;;1274       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000024  6941              LDR      r1,[r0,#0x14]
000026  f0210140          BIC      r1,r1,#0x40
00002a  6141              STR      r1,[r0,#0x14]
;;;1275   
;;;1276       /* Abort the UART DMA Rx channel : use blocking DMA Abort API (no callback) */
;;;1277       if(huart->hdmarx != NULL)
00002c  6b60              LDR      r0,[r4,#0x34]
00002e  b118              CBZ      r0,|L11.56|
;;;1278       {
;;;1279         /* Set the UART DMA Abort callback to Null. 
;;;1280            No call back execution at end of DMA abort procedure */
;;;1281         huart->hdmarx->XferAbortCallback = NULL;
;;;1282   
;;;1283         HAL_DMA_Abort(huart->hdmarx);
000030  6345              STR      r5,[r0,#0x34]
000032  6b60              LDR      r0,[r4,#0x34]
000034  f7fffffe          BL       HAL_DMA_Abort
                  |L11.56|
;;;1284       }
;;;1285     }
;;;1286   
;;;1287     /* Reset Rx transfer counter */
;;;1288     huart->RxXferCount = 0x00U;
000038  85e5              STRH     r5,[r4,#0x2e]
;;;1289   
;;;1290     /* Restore huart->RxState to Ready */
;;;1291     huart->RxState = HAL_UART_STATE_READY;
00003a  2020              MOVS     r0,#0x20
00003c  f884003a          STRB     r0,[r4,#0x3a]
;;;1292   
;;;1293     return HAL_OK;
000040  2000              MOVS     r0,#0
;;;1294   }
000042  bd70              POP      {r4-r6,pc}
;;;1295   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceiveCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceiveCpltCallback PROC
;;;1784     */
;;;1785   __weak void HAL_UART_AbortReceiveCpltCallback (UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1786   {
;;;1787     /* Prevent unused argument(s) compilation warning */
;;;1788     UNUSED(huart);
;;;1789   
;;;1790     /* NOTE : This function should not be modified, when the callback is needed,
;;;1791               the HAL_UART_AbortReceiveCpltCallback can be implemented in the user file.
;;;1792      */
;;;1793   }
;;;1794   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortReceive_IT PROC
;;;1496   */
;;;1497   HAL_StatusTypeDef HAL_UART_AbortReceive_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1498   {
000002  4604              MOV      r4,r0
;;;1499     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1500     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  6800              LDR      r0,[r0,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f4217190          BIC      r1,r1,#0x120
00000c  60c1              STR      r1,[r0,#0xc]
;;;1501     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  f0210101          BIC      r1,r1,#1
000016  6141              STR      r1,[r0,#0x14]
;;;1502   
;;;1503     /* Disable the UART DMA Rx request if enabled */
;;;1504     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000018  6820              LDR      r0,[r4,#0]
00001a  6941              LDR      r1,[r0,#0x14]
;;;1505     {
;;;1506       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1507   
;;;1508       /* Abort the UART DMA Rx channel : use blocking DMA Abort API (no callback) */
;;;1509       if(huart->hdmarx != NULL)
;;;1510       {
;;;1511         /* Set the UART DMA Abort callback : 
;;;1512            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1513         huart->hdmarx->XferAbortCallback = UART_DMARxOnlyAbortCallback;
;;;1514   
;;;1515         /* Abort DMA RX */
;;;1516         if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
;;;1517         {
;;;1518           /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
;;;1519           huart->hdmarx->XferAbortCallback(huart->hdmarx);
;;;1520         }
;;;1521       }
;;;1522       else
;;;1523       {
;;;1524         /* Reset Rx transfer counter */
;;;1525         huart->RxXferCount = 0x00U;
;;;1526   
;;;1527         /* Restore huart->RxState to Ready */
;;;1528         huart->RxState = HAL_UART_STATE_READY;
00001c  f04f0220          MOV      r2,#0x20
000020  064b              LSLS     r3,r1,#25             ;1504
000022  f04f0100          MOV      r1,#0                 ;1504
000026  d50f              BPL      |L13.72|
000028  6943              LDR      r3,[r0,#0x14]         ;1506
00002a  f0230340          BIC      r3,r3,#0x40           ;1506
00002e  6143              STR      r3,[r0,#0x14]         ;1506
000030  6b60              LDR      r0,[r4,#0x34]         ;1509
000032  b148              CBZ      r0,|L13.72|
000034  4908              LDR      r1,|L13.88|
000036  6341              STR      r1,[r0,#0x34]         ;1516
000038  6b60              LDR      r0,[r4,#0x34]         ;1516
00003a  f7fffffe          BL       HAL_DMA_Abort_IT
00003e  b148              CBZ      r0,|L13.84|
000040  6b60              LDR      r0,[r4,#0x34]         ;1519
000042  6b41              LDR      r1,[r0,#0x34]         ;1519
000044  4788              BLX      r1                    ;1519
000046  e005              B        |L13.84|
                  |L13.72|
000048  85e1              STRH     r1,[r4,#0x2e]         ;1525
00004a  f884203a          STRB     r2,[r4,#0x3a]
;;;1529   
;;;1530         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1531         HAL_UART_AbortReceiveCpltCallback(huart);
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
                  |L13.84|
;;;1532       }
;;;1533     }
;;;1534     else
;;;1535     {
;;;1536       /* Reset Rx transfer counter */
;;;1537       huart->RxXferCount = 0x00U;
;;;1538   
;;;1539       /* Restore huart->RxState to Ready */
;;;1540       huart->RxState = HAL_UART_STATE_READY;
;;;1541   
;;;1542       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1543       HAL_UART_AbortReceiveCpltCallback(huart);
;;;1544     }
;;;1545   
;;;1546     return HAL_OK;
000054  2000              MOVS     r0,#0
;;;1547   }
000056  bd10              POP      {r4,pc}
;;;1548   
                          ENDP

                  |L13.88|
                          DCD      UART_DMARxOnlyAbortCallback

                          AREA ||i.HAL_UART_AbortTransmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmit PROC
;;;1222   */
;;;1223   HAL_StatusTypeDef HAL_UART_AbortTransmit(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1224   {
000002  4604              MOV      r4,r0
;;;1225     /* Disable TXEIE and TCIE interrupts */
;;;1226     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6800              LDR      r0,[r0,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f02101c0          BIC      r1,r1,#0xc0
00000c  60c1              STR      r1,[r0,#0xc]
;;;1227   
;;;1228     /* Disable the UART DMA Tx request if enabled */
;;;1229     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  f04f0500          MOV      r5,#0
000016  0609              LSLS     r1,r1,#24
000018  d509              BPL      |L14.46|
;;;1230     {
;;;1231       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00001a  6941              LDR      r1,[r0,#0x14]
00001c  f0210180          BIC      r1,r1,#0x80
000020  6141              STR      r1,[r0,#0x14]
;;;1232   
;;;1233       /* Abort the UART DMA Tx channel : use blocking DMA Abort API (no callback) */
;;;1234       if(huart->hdmatx != NULL)
000022  6b20              LDR      r0,[r4,#0x30]
000024  b118              CBZ      r0,|L14.46|
;;;1235       {
;;;1236         /* Set the UART DMA Abort callback to Null. 
;;;1237            No call back execution at end of DMA abort procedure */
;;;1238         huart->hdmatx->XferAbortCallback = NULL;
;;;1239   
;;;1240         HAL_DMA_Abort(huart->hdmatx);
000026  6345              STR      r5,[r0,#0x34]
000028  6b20              LDR      r0,[r4,#0x30]
00002a  f7fffffe          BL       HAL_DMA_Abort
                  |L14.46|
;;;1241       }
;;;1242     }
;;;1243   
;;;1244     /* Reset Tx transfer counter */
;;;1245     huart->TxXferCount = 0x00U;
00002e  84e5              STRH     r5,[r4,#0x26]
;;;1246   
;;;1247     /* Restore huart->gState to Ready */
;;;1248     huart->gState = HAL_UART_STATE_READY;
000030  2020              MOVS     r0,#0x20
000032  f8840039          STRB     r0,[r4,#0x39]
;;;1249   
;;;1250     return HAL_OK;
000036  2000              MOVS     r0,#0
;;;1251   }
000038  bd70              POP      {r4-r6,pc}
;;;1252   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmitCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmitCpltCallback PROC
;;;1769     */
;;;1770   __weak void HAL_UART_AbortTransmitCpltCallback (UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1771   {
;;;1772     /* Prevent unused argument(s) compilation warning */
;;;1773     UNUSED(huart);
;;;1774   
;;;1775     /* NOTE : This function should not be modified, when the callback is needed,
;;;1776               the HAL_UART_AbortTransmitCpltCallback can be implemented in the user file.
;;;1777      */
;;;1778   }
;;;1779   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortTransmit_IT PROC
;;;1431   */
;;;1432   HAL_StatusTypeDef HAL_UART_AbortTransmit_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1433   {
000002  4604              MOV      r4,r0
;;;1434     /* Disable TXEIE and TCIE interrupts */
;;;1435     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6800              LDR      r0,[r0,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f02101c0          BIC      r1,r1,#0xc0
00000c  60c1              STR      r1,[r0,#0xc]
;;;1436   
;;;1437     /* Disable the UART DMA Tx request if enabled */
;;;1438     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
;;;1439     {
;;;1440       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1441   
;;;1442       /* Abort the UART DMA Tx channel : use blocking DMA Abort API (no callback) */
;;;1443       if(huart->hdmatx != NULL)
;;;1444       {
;;;1445         /* Set the UART DMA Abort callback : 
;;;1446            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1447         huart->hdmatx->XferAbortCallback = UART_DMATxOnlyAbortCallback;
;;;1448   
;;;1449         /* Abort DMA TX */
;;;1450         if(HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
;;;1451         {
;;;1452           /* Call Directly huart->hdmatx->XferAbortCallback function in case of error */
;;;1453           huart->hdmatx->XferAbortCallback(huart->hdmatx);
;;;1454         }
;;;1455       }
;;;1456       else
;;;1457       {
;;;1458         /* Reset Tx transfer counter */
;;;1459         huart->TxXferCount = 0x00U;
;;;1460   
;;;1461         /* Restore huart->gState to Ready */
;;;1462         huart->gState = HAL_UART_STATE_READY;
000012  f04f0220          MOV      r2,#0x20
000016  060b              LSLS     r3,r1,#24             ;1438
000018  f04f0100          MOV      r1,#0                 ;1438
00001c  d50f              BPL      |L16.62|
00001e  6943              LDR      r3,[r0,#0x14]         ;1440
000020  f0230380          BIC      r3,r3,#0x80           ;1440
000024  6143              STR      r3,[r0,#0x14]         ;1440
000026  6b20              LDR      r0,[r4,#0x30]         ;1443
000028  b148              CBZ      r0,|L16.62|
00002a  4909              LDR      r1,|L16.80|
00002c  6341              STR      r1,[r0,#0x34]         ;1450
00002e  6b20              LDR      r0,[r4,#0x30]         ;1450
000030  f7fffffe          BL       HAL_DMA_Abort_IT
000034  b148              CBZ      r0,|L16.74|
000036  6b20              LDR      r0,[r4,#0x30]         ;1453
000038  6b41              LDR      r1,[r0,#0x34]         ;1453
00003a  4788              BLX      r1                    ;1453
00003c  e005              B        |L16.74|
                  |L16.62|
00003e  84e1              STRH     r1,[r4,#0x26]         ;1459
000040  f8842039          STRB     r2,[r4,#0x39]
;;;1463   
;;;1464         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1465         HAL_UART_AbortTransmitCpltCallback(huart);
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
                  |L16.74|
;;;1466       }
;;;1467     }
;;;1468     else
;;;1469     {
;;;1470       /* Reset Tx transfer counter */
;;;1471       huart->TxXferCount = 0x00U;
;;;1472   
;;;1473       /* Restore huart->gState to Ready */
;;;1474       huart->gState = HAL_UART_STATE_READY;
;;;1475   
;;;1476       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1477       HAL_UART_AbortTransmitCpltCallback(huart);
;;;1478     }
;;;1479   
;;;1480     return HAL_OK;
00004a  2000              MOVS     r0,#0
;;;1481   }
00004c  bd10              POP      {r4,pc}
;;;1482   
                          ENDP

00004e  0000              DCW      0x0000
                  |L16.80|
                          DCD      UART_DMATxOnlyAbortCallback

                          AREA ||i.HAL_UART_Abort_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_Abort_IT PROC
;;;1309   */
;;;1310   HAL_StatusTypeDef HAL_UART_Abort_IT(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1311   {
000002  4604              MOV      r4,r0
;;;1312     uint32_t AbortCplt = 0x01U;
;;;1313   
;;;1314     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1315     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6800              LDR      r0,[r0,#0]
000006  2601              MOVS     r6,#1                 ;1312
000008  68c1              LDR      r1,[r0,#0xc]
00000a  f42171f0          BIC      r1,r1,#0x1e0
00000e  60c1              STR      r1,[r0,#0xc]
;;;1316     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000010  6820              LDR      r0,[r4,#0]
000012  6941              LDR      r1,[r0,#0x14]
000014  f0210101          BIC      r1,r1,#1
000018  6141              STR      r1,[r0,#0x14]
00001a  6b20              LDR      r0,[r4,#0x30]         ;1311
;;;1317   
;;;1318     /* If DMA Tx and/or DMA Rx Handles are associated to UART Handle, DMA Abort complete callbacks should be initialised
;;;1319        before any call to DMA Abort functions */
;;;1320     /* DMA Tx Handle is valid */
;;;1321     if(huart->hdmatx != NULL)
00001c  2500              MOVS     r5,#0
00001e  b138              CBZ      r0,|L17.48|
;;;1322     {
;;;1323       /* Set DMA Abort Complete callback if UART DMA Tx request if enabled.
;;;1324          Otherwise, set it to NULL */
;;;1325       if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000020  6821              LDR      r1,[r4,#0]
000022  6949              LDR      r1,[r1,#0x14]
000024  0609              LSLS     r1,r1,#24
000026  d502              BPL      |L17.46|
;;;1326       {
;;;1327         huart->hdmatx->XferAbortCallback = UART_DMATxAbortCallback;
000028  491e              LDR      r1,|L17.164|
00002a  6341              STR      r1,[r0,#0x34]
00002c  e000              B        |L17.48|
                  |L17.46|
;;;1328       }
;;;1329       else
;;;1330       {
;;;1331         huart->hdmatx->XferAbortCallback = NULL;
00002e  6345              STR      r5,[r0,#0x34]
                  |L17.48|
;;;1332       }
;;;1333     }
;;;1334     /* DMA Rx Handle is valid */
;;;1335     if(huart->hdmarx != NULL)
000030  6b60              LDR      r0,[r4,#0x34]
000032  b138              CBZ      r0,|L17.68|
;;;1336     {
;;;1337       /* Set DMA Abort Complete callback if UART DMA Rx request if enabled.
;;;1338          Otherwise, set it to NULL */
;;;1339       if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000034  6821              LDR      r1,[r4,#0]
000036  6949              LDR      r1,[r1,#0x14]
000038  0649              LSLS     r1,r1,#25
00003a  d502              BPL      |L17.66|
;;;1340       {
;;;1341         huart->hdmarx->XferAbortCallback = UART_DMARxAbortCallback;
00003c  491a              LDR      r1,|L17.168|
00003e  6341              STR      r1,[r0,#0x34]
000040  e000              B        |L17.68|
                  |L17.66|
;;;1342       }
;;;1343       else
;;;1344       {
;;;1345         huart->hdmarx->XferAbortCallback = NULL;
000042  6345              STR      r5,[r0,#0x34]
                  |L17.68|
;;;1346       }
;;;1347     }
;;;1348   
;;;1349     /* Disable the UART DMA Tx request if enabled */
;;;1350     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000044  6820              LDR      r0,[r4,#0]
000046  6941              LDR      r1,[r0,#0x14]
000048  0609              LSLS     r1,r1,#24
00004a  d50c              BPL      |L17.102|
;;;1351     {
;;;1352       /* Disable DMA Tx at UART level */
;;;1353       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00004c  6941              LDR      r1,[r0,#0x14]
00004e  f0210180          BIC      r1,r1,#0x80
000052  6141              STR      r1,[r0,#0x14]
;;;1354   
;;;1355       /* Abort the UART DMA Tx channel : use non blocking DMA Abort API (callback) */
;;;1356       if(huart->hdmatx != NULL)
000054  6b20              LDR      r0,[r4,#0x30]
000056  b130              CBZ      r0,|L17.102|
;;;1357       {
;;;1358         /* UART Tx DMA Abort callback has already been initialised : 
;;;1359            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1360   
;;;1361         /* Abort DMA TX */
;;;1362         if(HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
000058  f7fffffe          BL       HAL_DMA_Abort_IT
00005c  b110              CBZ      r0,|L17.100|
;;;1363         {
;;;1364           huart->hdmatx->XferAbortCallback = NULL;
00005e  6b20              LDR      r0,[r4,#0x30]
000060  6345              STR      r5,[r0,#0x34]
000062  e000              B        |L17.102|
                  |L17.100|
;;;1365         }
;;;1366         else
;;;1367         {
;;;1368           AbortCplt = 0x00U;
000064  2600              MOVS     r6,#0
                  |L17.102|
;;;1369         }
;;;1370       }
;;;1371     }
;;;1372   
;;;1373     /* Disable the UART DMA Rx request if enabled */
;;;1374     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000066  6820              LDR      r0,[r4,#0]
000068  6941              LDR      r1,[r0,#0x14]
00006a  0649              LSLS     r1,r1,#25
00006c  d50b              BPL      |L17.134|
;;;1375     {
;;;1376       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
00006e  6941              LDR      r1,[r0,#0x14]
000070  f0210140          BIC      r1,r1,#0x40
000074  6141              STR      r1,[r0,#0x14]
;;;1377   
;;;1378       /* Abort the UART DMA Rx channel : use non blocking DMA Abort API (callback) */
;;;1379       if(huart->hdmarx != NULL)
000076  6b60              LDR      r0,[r4,#0x34]
000078  b128              CBZ      r0,|L17.134|
;;;1380       {
;;;1381         /* UART Rx DMA Abort callback has already been initialised : 
;;;1382            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1383   
;;;1384         /* Abort DMA RX */
;;;1385         if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
00007a  f7fffffe          BL       HAL_DMA_Abort_IT
00007e  b170              CBZ      r0,|L17.158|
;;;1386         {
;;;1387           huart->hdmarx->XferAbortCallback = NULL;
000080  6b60              LDR      r0,[r4,#0x34]
;;;1388           AbortCplt = 0x01U;
000082  6345              STR      r5,[r0,#0x34]
000084  e000              B        |L17.136|
                  |L17.134|
;;;1389         }
;;;1390         else
;;;1391         {
;;;1392           AbortCplt = 0x00U;
;;;1393         }
;;;1394       }
;;;1395     }
;;;1396   
;;;1397     /* if no DMA abort complete callback execution is required => call user Abort Complete callback */
;;;1398     if(AbortCplt == 0x01U)
000086  b156              CBZ      r6,|L17.158|
                  |L17.136|
;;;1399     {
;;;1400       /* Reset Tx and Rx transfer counters */
;;;1401       huart->TxXferCount = 0x00U; 
000088  84e5              STRH     r5,[r4,#0x26]
;;;1402       huart->RxXferCount = 0x00U;
00008a  85e5              STRH     r5,[r4,#0x2e]
;;;1403   
;;;1404       /* Reset ErrorCode */
;;;1405       huart->ErrorCode = HAL_UART_ERROR_NONE;
00008c  63e5              STR      r5,[r4,#0x3c]
;;;1406   
;;;1407       /* Restore huart->gState and huart->RxState to Ready */
;;;1408       huart->gState  = HAL_UART_STATE_READY;
00008e  2020              MOVS     r0,#0x20
000090  f8840039          STRB     r0,[r4,#0x39]
;;;1409       huart->RxState = HAL_UART_STATE_READY;
000094  f884003a          STRB     r0,[r4,#0x3a]
;;;1410   
;;;1411       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1412       HAL_UART_AbortCpltCallback(huart);
000098  4620              MOV      r0,r4
00009a  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L17.158|
;;;1413     }
;;;1414   
;;;1415     return HAL_OK;
00009e  2000              MOVS     r0,#0
;;;1416   }
0000a0  bd70              POP      {r4-r6,pc}
;;;1417   
                          ENDP

0000a2  0000              DCW      0x0000
                  |L17.164|
                          DCD      UART_DMATxAbortCallback
                  |L17.168|
                          DCD      UART_DMARxAbortCallback

                          AREA ||i.HAL_UART_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAPause PROC
;;;1033     */
;;;1034   HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;1035   {
;;;1036     uint32_t dmarequest = 0x00U;
;;;1037   
;;;1038     /* Process Locked */
;;;1039     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d00b              BEQ      |L18.32|
000008  2101              MOVS     r1,#1
00000a  f8801038          STRB     r1,[r0,#0x38]
;;;1040   
;;;1041     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
00000e  6801              LDR      r1,[r0,#0]
000010  694a              LDR      r2,[r1,#0x14]
;;;1042     if((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
000012  f8903039          LDRB     r3,[r0,#0x39]
000016  f3c212c0          UBFX     r2,r2,#7,#1           ;1041
00001a  2b21              CMP      r3,#0x21
00001c  d002              BEQ      |L18.36|
00001e  e006              B        |L18.46|
                  |L18.32|
000020  2002              MOVS     r0,#2                 ;1039
;;;1043     {
;;;1044       /* Disable the UART DMA Tx request */
;;;1045       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1046     }
;;;1047   
;;;1048     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
;;;1049     if((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
;;;1050     {
;;;1051       /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1052       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1053       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1054   
;;;1055       /* Disable the UART DMA Rx request */
;;;1056       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1057     }
;;;1058   
;;;1059     /* Process Unlocked */
;;;1060     __HAL_UNLOCK(huart);
;;;1061     
;;;1062     return HAL_OK;
;;;1063   }
000022  4770              BX       lr
                  |L18.36|
000024  b11a              CBZ      r2,|L18.46|
000026  694a              LDR      r2,[r1,#0x14]         ;1045
000028  f0220280          BIC      r2,r2,#0x80           ;1045
00002c  614a              STR      r2,[r1,#0x14]         ;1045
                  |L18.46|
00002e  6801              LDR      r1,[r0,#0]            ;1048
000030  694a              LDR      r2,[r1,#0x14]         ;1048
000032  f890303a          LDRB     r3,[r0,#0x3a]         ;1049
000036  f3c21280          UBFX     r2,r2,#6,#1           ;1048
00003a  2b22              CMP      r3,#0x22              ;1049
00003c  d10e              BNE      |L18.92|
00003e  b16a              CBZ      r2,|L18.92|
000040  68ca              LDR      r2,[r1,#0xc]          ;1052
000042  f4227280          BIC      r2,r2,#0x100          ;1052
000046  60ca              STR      r2,[r1,#0xc]          ;1052
000048  6801              LDR      r1,[r0,#0]            ;1053
00004a  694a              LDR      r2,[r1,#0x14]         ;1053
00004c  f0220201          BIC      r2,r2,#1              ;1053
000050  614a              STR      r2,[r1,#0x14]         ;1053
000052  6801              LDR      r1,[r0,#0]            ;1056
000054  694a              LDR      r2,[r1,#0x14]         ;1056
000056  f0220240          BIC      r2,r2,#0x40           ;1056
00005a  614a              STR      r2,[r1,#0x14]         ;1056
                  |L18.92|
00005c  2100              MOVS     r1,#0                 ;1060
00005e  f8801038          STRB     r1,[r0,#0x38]         ;1060
000062  4608              MOV      r0,r1                 ;1062
000064  4770              BX       lr
;;;1064   
                          ENDP


                          AREA ||i.HAL_UART_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAResume PROC
;;;1070     */
;;;1071   HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
000000  b508              PUSH     {r3,lr}
;;;1072   {
;;;1073     /* Process Locked */
;;;1074     __HAL_LOCK(huart);
000002  f8901038          LDRB     r1,[r0,#0x38]
000006  2901              CMP      r1,#1
000008  d007              BEQ      |L19.26|
00000a  2101              MOVS     r1,#1
00000c  f8801038          STRB     r1,[r0,#0x38]
;;;1075     
;;;1076     if(huart->gState == HAL_UART_STATE_BUSY_TX)
000010  f8901039          LDRB     r1,[r0,#0x39]
000014  2921              CMP      r1,#0x21
000016  d002              BEQ      |L19.30|
000018  e006              B        |L19.40|
                  |L19.26|
00001a  2002              MOVS     r0,#2                 ;1074
;;;1077     {
;;;1078       /* Enable the UART DMA Tx request */
;;;1079       SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1080     }
;;;1081   
;;;1082     if(huart->RxState == HAL_UART_STATE_BUSY_RX)
;;;1083     {
;;;1084       /* Clear the Overrun flag before resuming the Rx transfer*/
;;;1085       __HAL_UART_CLEAR_OREFLAG(huart);
;;;1086       
;;;1087       /* Reenable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1088       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1089       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1090       
;;;1091       /* Enable the UART DMA Rx request */
;;;1092       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1093     }
;;;1094   
;;;1095     /* Process Unlocked */
;;;1096     __HAL_UNLOCK(huart);
;;;1097     
;;;1098     return HAL_OK;
;;;1099   }
00001c  bd08              POP      {r3,pc}
                  |L19.30|
00001e  6801              LDR      r1,[r0,#0]            ;1079
000020  694a              LDR      r2,[r1,#0x14]         ;1079
000022  f0420280          ORR      r2,r2,#0x80           ;1079
000026  614a              STR      r2,[r1,#0x14]         ;1079
                  |L19.40|
000028  f890103a          LDRB     r1,[r0,#0x3a]         ;1082
00002c  2200              MOVS     r2,#0                 ;1082
00002e  2922              CMP      r1,#0x22              ;1082
000030  d111              BNE      |L19.86|
000032  6801              LDR      r1,[r0,#0]            ;1085
000034  680b              LDR      r3,[r1,#0]            ;1085
000036  684b              LDR      r3,[r1,#4]            ;1085
000038  9300              STR      r3,[sp,#0]            ;1088
00003a  68cb              LDR      r3,[r1,#0xc]          ;1088
00003c  f4437380          ORR      r3,r3,#0x100          ;1088
000040  60cb              STR      r3,[r1,#0xc]          ;1088
000042  6801              LDR      r1,[r0,#0]            ;1089
000044  694b              LDR      r3,[r1,#0x14]         ;1089
000046  f0430301          ORR      r3,r3,#1              ;1089
00004a  614b              STR      r3,[r1,#0x14]         ;1089
00004c  6801              LDR      r1,[r0,#0]            ;1092
00004e  694b              LDR      r3,[r1,#0x14]         ;1092
000050  f0430340          ORR      r3,r3,#0x40           ;1092
000054  614b              STR      r3,[r1,#0x14]         ;1092
                  |L19.86|
000056  f8802038          STRB     r2,[r0,#0x38]         ;1096
00005a  2000              MOVS     r0,#0                 ;1098
00005c  bd08              POP      {r3,pc}
;;;1100   
                          ENDP


                          AREA ||i.HAL_UART_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAStop PROC
;;;1106     */
;;;1107   HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1108   {
000002  4604              MOV      r4,r0
;;;1109     uint32_t dmarequest = 0x00U;
;;;1110     /* The Lock is not implemented on this API to allow the user application
;;;1111        to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback():
;;;1112        when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
;;;1113        and the correspond call back is executed HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback()
;;;1114        */
;;;1115   
;;;1116     /* Stop UART DMA Tx request if ongoing */
;;;1117     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
000004  6800              LDR      r0,[r0,#0]
000006  6941              LDR      r1,[r0,#0x14]
;;;1118     if((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
000008  f8942039          LDRB     r2,[r4,#0x39]
00000c  f3c111c0          UBFX     r1,r1,#7,#1           ;1117
000010  2a21              CMP      r2,#0x21
000012  d10b              BNE      |L20.44|
000014  b151              CBZ      r1,|L20.44|
;;;1119     {
;;;1120       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000016  6941              LDR      r1,[r0,#0x14]
000018  f0210180          BIC      r1,r1,#0x80
00001c  6141              STR      r1,[r0,#0x14]
;;;1121   
;;;1122       /* Abort the UART DMA Tx channel */
;;;1123       if(huart->hdmatx != NULL)
00001e  6b20              LDR      r0,[r4,#0x30]
000020  b108              CBZ      r0,|L20.38|
;;;1124       {
;;;1125         HAL_DMA_Abort(huart->hdmatx);
000022  f7fffffe          BL       HAL_DMA_Abort
                  |L20.38|
;;;1126       }
;;;1127       UART_EndTxTransfer(huart);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       UART_EndTxTransfer
                  |L20.44|
;;;1128     }
;;;1129   
;;;1130     /* Stop UART DMA Rx request if ongoing */
;;;1131     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
00002c  6820              LDR      r0,[r4,#0]
00002e  6941              LDR      r1,[r0,#0x14]
;;;1132     if((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
000030  f894203a          LDRB     r2,[r4,#0x3a]
000034  f3c11180          UBFX     r1,r1,#6,#1           ;1131
000038  2a22              CMP      r2,#0x22
00003a  d10b              BNE      |L20.84|
00003c  b151              CBZ      r1,|L20.84|
;;;1133     {
;;;1134       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
00003e  6941              LDR      r1,[r0,#0x14]
000040  f0210140          BIC      r1,r1,#0x40
000044  6141              STR      r1,[r0,#0x14]
;;;1135   
;;;1136       /* Abort the UART DMA Rx channel */
;;;1137       if(huart->hdmarx != NULL)
000046  6b60              LDR      r0,[r4,#0x34]
000048  b108              CBZ      r0,|L20.78|
;;;1138       {
;;;1139         HAL_DMA_Abort(huart->hdmarx);
00004a  f7fffffe          BL       HAL_DMA_Abort
                  |L20.78|
;;;1140       }
;;;1141       UART_EndRxTransfer(huart);
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       UART_EndRxTransfer
                  |L20.84|
;;;1142     }
;;;1143   
;;;1144     return HAL_OK;
000054  2000              MOVS     r0,#0
;;;1145   }
000056  bd10              POP      {r4,pc}
;;;1146   
                          ENDP


                          AREA ||i.HAL_UART_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_DeInit PROC
;;;516      */
;;;517    HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;518    {
000002  0004              MOVS     r4,r0
000004  d00e              BEQ      |L21.36|
;;;519      /* Check the UART handle allocation */
;;;520      if(huart == NULL)
;;;521      {
;;;522        return HAL_ERROR;
;;;523      }
;;;524    
;;;525      /* Check the parameters */
;;;526      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;527    
;;;528      huart->gState = HAL_UART_STATE_BUSY;
000006  2024              MOVS     r0,#0x24
000008  f8840039          STRB     r0,[r4,#0x39]
;;;529    
;;;530      /* DeInit the low level hardware */
;;;531      HAL_UART_MspDeInit(huart);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       HAL_UART_MspDeInit
;;;532    
;;;533      huart->ErrorCode = HAL_UART_ERROR_NONE;
000012  2000              MOVS     r0,#0
000014  63e0              STR      r0,[r4,#0x3c]
;;;534      huart->gState = HAL_UART_STATE_RESET;
000016  f8840039          STRB     r0,[r4,#0x39]
;;;535      huart->RxState = HAL_UART_STATE_RESET;
00001a  f884003a          STRB     r0,[r4,#0x3a]
;;;536    
;;;537      /* Process Unlock */
;;;538      __HAL_UNLOCK(huart);
00001e  f8840038          STRB     r0,[r4,#0x38]
;;;539    
;;;540      return HAL_OK;
;;;541    }
000022  bd10              POP      {r4,pc}
                  |L21.36|
000024  2001              MOVS     r0,#1                 ;522
000026  bd10              POP      {r4,pc}
;;;542    
                          ENDP


                          AREA ||i.HAL_UART_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_ErrorCallback PROC
;;;1741     */
;;;1742    __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1743   {
;;;1744     /* Prevent unused argument(s) compilation warning */
;;;1745     UNUSED(huart); 
;;;1746     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1747              the HAL_UART_ErrorCallback could be implemented in the user file
;;;1748      */ 
;;;1749   }
;;;1750   
                          ENDP


                          AREA ||i.HAL_UART_GetError||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetError PROC
;;;2011     */
;;;2012   uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
000000  6bc0              LDR      r0,[r0,#0x3c]
;;;2013   {
;;;2014     return huart->ErrorCode;
;;;2015   }
000002  4770              BX       lr
;;;2016   
                          ENDP


                          AREA ||i.HAL_UART_GetState||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetState PROC
;;;1996     */
;;;1997   HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
000000  f8101f39          LDRB     r1,[r0,#0x39]!
;;;1998   {
;;;1999     uint32_t temp1= 0x00U, temp2 = 0x00U;
;;;2000     temp1 = huart->gState;
;;;2001     temp2 = huart->RxState;
000004  7840              LDRB     r0,[r0,#1]
;;;2002     
;;;2003     return (HAL_UART_StateTypeDef)(temp1 | temp2);
000006  4308              ORRS     r0,r0,r1
;;;2004   }
000008  4770              BX       lr
;;;2005   
                          ENDP


                          AREA ||i.HAL_UART_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_UART_IRQHandler PROC
;;;1554     */
;;;1555   void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1556   {
;;;1557      uint32_t isrflags   = READ_REG(huart->Instance->SR);
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0                 ;1556
000006  6810              LDR      r0,[r2,#0]
;;;1558      uint32_t cr1its     = READ_REG(huart->Instance->CR1);
000008  68d1              LDR      r1,[r2,#0xc]
;;;1559      uint32_t cr3its     = READ_REG(huart->Instance->CR3);
00000a  6953              LDR      r3,[r2,#0x14]
;;;1560      uint32_t errorflags = 0x00U;
;;;1561      uint32_t dmarequest = 0x00U;
;;;1562   
;;;1563     /* If no error occurs */
;;;1564     errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
00000c  f0100f0f          TST      r0,#0xf
000010  d050              BEQ      |L25.180|
;;;1565     if(errorflags == RESET)
;;;1566     {
;;;1567       /* UART in mode Receiver -------------------------------------------------*/
;;;1568       if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
;;;1569       {
;;;1570         UART_Receive_IT(huart);
;;;1571         return;
;;;1572       }
;;;1573     }
;;;1574   
;;;1575     /* If some errors occur */
;;;1576     if((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET) || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
000012  f0030501          AND      r5,r3,#1
000016  f4017690          AND      r6,r1,#0x120
00001a  4335              ORRS     r5,r5,r6
00001c  d05d              BEQ      |L25.218|
;;;1577     {
;;;1578       /* UART parity error interrupt occurred ----------------------------------*/
;;;1579       if(((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
00001e  07c2              LSLS     r2,r0,#31
000020  d005              BEQ      |L25.46|
000022  05ca              LSLS     r2,r1,#23
000024  d503              BPL      |L25.46|
;;;1580       {
;;;1581         huart->ErrorCode |= HAL_UART_ERROR_PE;
000026  6be2              LDR      r2,[r4,#0x3c]
000028  f0420201          ORR      r2,r2,#1
00002c  63e2              STR      r2,[r4,#0x3c]
                  |L25.46|
;;;1582       }
;;;1583   
;;;1584       /* UART noise error interrupt occurred -----------------------------------*/
;;;1585       if(((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
00002e  0742              LSLS     r2,r0,#29
000030  d505              BPL      |L25.62|
000032  07da              LSLS     r2,r3,#31
000034  d003              BEQ      |L25.62|
;;;1586       {
;;;1587         huart->ErrorCode |= HAL_UART_ERROR_NE;
000036  6be2              LDR      r2,[r4,#0x3c]
000038  f0420202          ORR      r2,r2,#2
00003c  63e2              STR      r2,[r4,#0x3c]
                  |L25.62|
;;;1588       }
;;;1589   
;;;1590       /* UART frame error interrupt occurred -----------------------------------*/
;;;1591       if(((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
00003e  0782              LSLS     r2,r0,#30
000040  d505              BPL      |L25.78|
000042  07da              LSLS     r2,r3,#31
000044  d003              BEQ      |L25.78|
;;;1592       {
;;;1593         huart->ErrorCode |= HAL_UART_ERROR_FE;
000046  6be2              LDR      r2,[r4,#0x3c]
000048  f0420204          ORR      r2,r2,#4
00004c  63e2              STR      r2,[r4,#0x3c]
                  |L25.78|
;;;1594       }
;;;1595   
;;;1596       /* UART Over-Run interrupt occurred --------------------------------------*/
;;;1597       if(((isrflags & USART_SR_ORE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
00004e  0702              LSLS     r2,r0,#28
000050  d505              BPL      |L25.94|
000052  07da              LSLS     r2,r3,#31
000054  d003              BEQ      |L25.94|
;;;1598       { 
;;;1599         huart->ErrorCode |= HAL_UART_ERROR_ORE;
000056  6be2              LDR      r2,[r4,#0x3c]
000058  f0420208          ORR      r2,r2,#8
00005c  63e2              STR      r2,[r4,#0x3c]
                  |L25.94|
;;;1600       }
;;;1601   
;;;1602       /* Call UART Error Call back function if need be --------------------------*/
;;;1603       if(huart->ErrorCode != HAL_UART_ERROR_NONE)
00005e  6be2              LDR      r2,[r4,#0x3c]
000060  2a00              CMP      r2,#0
000062  d033              BEQ      |L25.204|
;;;1604       {
;;;1605         /* UART in mode Receiver -----------------------------------------------*/
;;;1606         if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
000064  0680              LSLS     r0,r0,#26
000066  d504              BPL      |L25.114|
000068  0688              LSLS     r0,r1,#26
00006a  d502              BPL      |L25.114|
;;;1607         {
;;;1608           UART_Receive_IT(huart);
00006c  4620              MOV      r0,r4
00006e  f7fffffe          BL       UART_Receive_IT
                  |L25.114|
;;;1609         }
;;;1610   
;;;1611         /* If Overrun error occurs, or if any error occurs in DMA mode reception,
;;;1612            consider error as blocking */
;;;1613         dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
000072  6820              LDR      r0,[r4,#0]
000074  6940              LDR      r0,[r0,#0x14]
;;;1614         if(((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
000076  6be1              LDR      r1,[r4,#0x3c]
000078  f3c01080          UBFX     r0,r0,#6,#1           ;1613
00007c  0709              LSLS     r1,r1,#28
00007e  d400              BMI      |L25.130|
000080  b328              CBZ      r0,|L25.206|
                  |L25.130|
;;;1615         {
;;;1616           /* Blocking error : transfer is aborted
;;;1617              Set the UART state ready to be able to start again the process,
;;;1618              Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
;;;1619           UART_EndRxTransfer(huart);
000082  4620              MOV      r0,r4
000084  f7fffffe          BL       UART_EndRxTransfer
;;;1620   
;;;1621           /* Disable the UART DMA Rx request if enabled */
;;;1622           if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000088  6820              LDR      r0,[r4,#0]
00008a  6941              LDR      r1,[r0,#0x14]
00008c  0649              LSLS     r1,r1,#25
00008e  d51a              BPL      |L25.198|
;;;1623           {
;;;1624             CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000090  6941              LDR      r1,[r0,#0x14]
000092  f0210140          BIC      r1,r1,#0x40
000096  6141              STR      r1,[r0,#0x14]
;;;1625   
;;;1626             /* Abort the UART DMA Rx channel */
;;;1627             if(huart->hdmarx != NULL)
000098  6b60              LDR      r0,[r4,#0x34]
00009a  b1a0              CBZ      r0,|L25.198|
;;;1628             {
;;;1629               /* Set the UART DMA Abort callback : 
;;;1630                  will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
;;;1631               huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
00009c  491b              LDR      r1,|L25.268|
;;;1632               if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
00009e  6341              STR      r1,[r0,#0x34]
0000a0  6b60              LDR      r0,[r4,#0x34]
0000a2  f7fffffe          BL       HAL_DMA_Abort_IT
0000a6  2800              CMP      r0,#0
0000a8  d010              BEQ      |L25.204|
;;;1633               {
;;;1634                 /* Call Directly XferAbortCallback function in case of error */
;;;1635                 huart->hdmarx->XferAbortCallback(huart->hdmarx);
0000aa  6b60              LDR      r0,[r4,#0x34]
0000ac  6b41              LDR      r1,[r0,#0x34]
0000ae  e8bd4070          POP      {r4-r6,lr}
0000b2  4708              BX       r1
                  |L25.180|
0000b4  0683              LSLS     r3,r0,#26             ;1568
0000b6  d510              BPL      |L25.218|
0000b8  068b              LSLS     r3,r1,#26             ;1568
0000ba  d50e              BPL      |L25.218|
0000bc  4620              MOV      r0,r4                 ;1570
0000be  e8bd4070          POP      {r4-r6,lr}            ;1570
0000c2  f7ffbffe          B.W      UART_Receive_IT
                  |L25.198|
;;;1636               }
;;;1637             }
;;;1638             else
;;;1639             {
;;;1640               /* Call user error callback */
;;;1641               HAL_UART_ErrorCallback(huart);
;;;1642             }
;;;1643           }
;;;1644           else
;;;1645           {
;;;1646             /* Call user error callback */
;;;1647             HAL_UART_ErrorCallback(huart);
0000c6  4620              MOV      r0,r4
0000c8  f7fffffe          BL       HAL_UART_ErrorCallback
                  |L25.204|
;;;1648           }
;;;1649         }
;;;1650         else
;;;1651         {
;;;1652           /* Non Blocking error : transfer could go on. 
;;;1653              Error is notified to user through user error callback */
;;;1654           HAL_UART_ErrorCallback(huart);
;;;1655           huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1656         }
;;;1657       }
;;;1658       return;
;;;1659     } /* End if some error occurs */
;;;1660   
;;;1661     /* UART in mode Transmitter ------------------------------------------------*/
;;;1662     if(((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
;;;1663     {
;;;1664       UART_Transmit_IT(huart);
;;;1665       return;
;;;1666     }
;;;1667     
;;;1668     /* UART in mode Transmitter end --------------------------------------------*/
;;;1669     if(((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
;;;1670     {
;;;1671       UART_EndTransmit_IT(huart);
;;;1672       return;
;;;1673     }
;;;1674   }
0000cc  bd70              POP      {r4-r6,pc}
                  |L25.206|
0000ce  4620              MOV      r0,r4                 ;1654
0000d0  f7fffffe          BL       HAL_UART_ErrorCallback
0000d4  2000              MOVS     r0,#0                 ;1655
0000d6  63e0              STR      r0,[r4,#0x3c]         ;1655
                  |L25.216|
0000d8  bd70              POP      {r4-r6,pc}
                  |L25.218|
0000da  0603              LSLS     r3,r0,#24             ;1662
0000dc  d506              BPL      |L25.236|
0000de  060b              LSLS     r3,r1,#24             ;1662
0000e0  d504              BPL      |L25.236|
0000e2  4620              MOV      r0,r4                 ;1664
0000e4  e8bd4070          POP      {r4-r6,lr}            ;1664
0000e8  f7ffbffe          B.W      UART_Transmit_IT
                  |L25.236|
0000ec  0640              LSLS     r0,r0,#25             ;1669
0000ee  d5f3              BPL      |L25.216|
0000f0  0648              LSLS     r0,r1,#25             ;1669
0000f2  d5f1              BPL      |L25.216|
0000f4  68d1              LDR      r1,[r2,#0xc]          ;1669
0000f6  4620              MOV      r0,r4                 ;1671
0000f8  f0210140          BIC      r1,r1,#0x40           ;1671
0000fc  60d1              STR      r1,[r2,#0xc]          ;1671
0000fe  2120              MOVS     r1,#0x20              ;1671
000100  f8841039          STRB     r1,[r4,#0x39]         ;1671
000104  f7fffffe          BL       HAL_UART_TxCpltCallback
000108  bd70              POP      {r4-r6,pc}
;;;1675   
                          ENDP

00010a  0000              DCW      0x0000
                  |L25.268|
                          DCD      UART_DMAAbortOnError

                          AREA ||i.HAL_UART_Init||, CODE, READONLY, ALIGN=1

                  HAL_UART_Init PROC
;;;258      */
;;;259    HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;260    {
000002  0004              MOVS     r4,r0
000004  d004              BEQ      |L26.16|
;;;261      /* Check the UART handle allocation */
;;;262      if(huart == NULL)
;;;263      {
;;;264        return HAL_ERROR;
;;;265      }
;;;266    
;;;267      /* Check the parameters */
;;;268      if(huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
;;;269      {
;;;270        /* The hardware flow control is available only for USART1, USART2, USART3 */
;;;271        assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
;;;272        assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
;;;273      }
;;;274      else
;;;275      {
;;;276        assert_param(IS_UART_INSTANCE(huart->Instance));
;;;277      }
;;;278      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;279    #if defined(USART_CR1_OVER8)
;;;280      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;281    #endif /* USART_CR1_OVER8 */
;;;282      
;;;283      if(huart->gState == HAL_UART_STATE_RESET)
000006  f8940039          LDRB     r0,[r4,#0x39]
00000a  2500              MOVS     r5,#0
00000c  b110              CBZ      r0,|L26.20|
00000e  e006              B        |L26.30|
                  |L26.16|
000010  2001              MOVS     r0,#1                 ;264
;;;284      {  
;;;285        /* Allocate lock resource and initialize it */
;;;286        huart->Lock = HAL_UNLOCKED;
;;;287    
;;;288        /* Init the low level hardware */
;;;289        HAL_UART_MspInit(huart);
;;;290      }
;;;291    
;;;292      huart->gState = HAL_UART_STATE_BUSY;
;;;293    
;;;294      /* Disable the peripheral */
;;;295      __HAL_UART_DISABLE(huart);
;;;296      
;;;297      /* Set the UART Communication parameters */
;;;298      UART_SetConfig(huart);
;;;299      
;;;300      /* In asynchronous mode, the following bits must be kept cleared: 
;;;301         - LINEN and CLKEN bits in the USART_CR2 register,
;;;302         - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
;;;303      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;304      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;305      
;;;306      /* Enable the peripheral */
;;;307      __HAL_UART_ENABLE(huart);
;;;308      
;;;309      /* Initialize the UART state */
;;;310      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;311      huart->gState= HAL_UART_STATE_READY;
;;;312      huart->RxState= HAL_UART_STATE_READY;
;;;313      
;;;314      return HAL_OK;
;;;315    }
000012  bd70              POP      {r4-r6,pc}
                  |L26.20|
000014  f8845038          STRB     r5,[r4,#0x38]         ;286
000018  4620              MOV      r0,r4                 ;289
00001a  f7fffffe          BL       HAL_UART_MspInit
                  |L26.30|
00001e  2024              MOVS     r0,#0x24              ;292
000020  f8840039          STRB     r0,[r4,#0x39]         ;292
000024  6820              LDR      r0,[r4,#0]            ;295
000026  68c1              LDR      r1,[r0,#0xc]          ;295
000028  f4215100          BIC      r1,r1,#0x2000         ;295
00002c  60c1              STR      r1,[r0,#0xc]          ;295
00002e  4620              MOV      r0,r4                 ;298
000030  f7fffffe          BL       UART_SetConfig
000034  6820              LDR      r0,[r4,#0]            ;303
000036  6901              LDR      r1,[r0,#0x10]         ;303
000038  f4214190          BIC      r1,r1,#0x4800         ;303
00003c  6101              STR      r1,[r0,#0x10]         ;303
00003e  6820              LDR      r0,[r4,#0]            ;304
000040  6941              LDR      r1,[r0,#0x14]         ;304
000042  f021012a          BIC      r1,r1,#0x2a           ;304
000046  6141              STR      r1,[r0,#0x14]         ;304
000048  6820              LDR      r0,[r4,#0]            ;307
00004a  68c1              LDR      r1,[r0,#0xc]          ;307
00004c  f4415100          ORR      r1,r1,#0x2000         ;307
000050  60c1              STR      r1,[r0,#0xc]          ;307
000052  63e5              STR      r5,[r4,#0x3c]         ;310
000054  2020              MOVS     r0,#0x20              ;311
000056  f8840039          STRB     r0,[r4,#0x39]         ;311
00005a  f884003a          STRB     r0,[r4,#0x3a]         ;312
00005e  2000              MOVS     r0,#0                 ;314
000060  bd70              POP      {r4-r6,pc}
;;;316    
                          ENDP


                          AREA ||i.HAL_UART_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspDeInit PROC
;;;563      */
;;;564    __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;565    {
;;;566      /* Prevent unused argument(s) compilation warning */
;;;567      UNUSED(huart);
;;;568      /* NOTE: This function should not be modified, when the callback is needed,
;;;569               the HAL_UART_MspDeInit could be implemented in the user file
;;;570       */
;;;571    }
;;;572    
                          ENDP


                          AREA ||i.HAL_UART_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspInit PROC
;;;548      */
;;;549    __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;550    {
;;;551      /* Prevent unused argument(s) compilation warning */
;;;552      UNUSED(huart);
;;;553      /* NOTE: This function should not be modified, when the callback is needed,
;;;554               the HAL_UART_MspInit could be implemented in the user file
;;;555       */
;;;556    }
;;;557    
                          ENDP


                          AREA ||i.HAL_UART_Receive||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive PROC
;;;724      */
;;;725    HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;726    {
000004  4604              MOV      r4,r0
;;;727      uint16_t* tmp;
;;;728      uint32_t tickstart = 0U;
;;;729      
;;;730      /* Check that a Rx process is not already ongoing */
;;;731      if(huart->RxState == HAL_UART_STATE_READY)
000006  f890003a          LDRB     r0,[r0,#0x3a]
00000a  4699              MOV      r9,r3                 ;726
00000c  4616              MOV      r6,r2                 ;726
00000e  460d              MOV      r5,r1                 ;726
000010  2820              CMP      r0,#0x20
000012  d14f              BNE      |L29.180|
;;;732      {
;;;733        if((pData == NULL) || (Size == 0U))
000014  b195              CBZ      r5,|L29.60|
000016  b18e              CBZ      r6,|L29.60|
;;;734        {
;;;735          return  HAL_ERROR;
;;;736        }
;;;737    
;;;738        /* Process Locked */
;;;739        __HAL_LOCK(huart);
000018  f8940038          LDRB     r0,[r4,#0x38]
00001c  2801              CMP      r0,#1
00001e  d049              BEQ      |L29.180|
000020  2001              MOVS     r0,#1
000022  f8840038          STRB     r0,[r4,#0x38]
;;;740        
;;;741        huart->ErrorCode = HAL_UART_ERROR_NONE;
000026  2700              MOVS     r7,#0
000028  63e7              STR      r7,[r4,#0x3c]
;;;742        huart->RxState = HAL_UART_STATE_BUSY_RX;
00002a  2022              MOVS     r0,#0x22
00002c  f884003a          STRB     r0,[r4,#0x3a]
;;;743    
;;;744        /* Init tickstart for timeout managment */
;;;745        tickstart = HAL_GetTick();
000030  f7fffffe          BL       HAL_GetTick
;;;746    
;;;747        huart->RxXferSize = Size;
000034  85a6              STRH     r6,[r4,#0x2c]
000036  4680              MOV      r8,r0                 ;745
;;;748        huart->RxXferCount = Size;
000038  85e6              STRH     r6,[r4,#0x2e]
00003a  e031              B        |L29.160|
                  |L29.60|
00003c  2001              MOVS     r0,#1                 ;735
                  |L29.62|
;;;749    
;;;750        /* Check the remain data to be received */
;;;751        while(huart->RxXferCount > 0U)
;;;752        {
;;;753          huart->RxXferCount--;
;;;754          if(huart->Init.WordLength == UART_WORDLENGTH_9B)
;;;755          {
;;;756            if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;757            {
;;;758              return HAL_TIMEOUT;
;;;759            }
;;;760            tmp = (uint16_t*)pData;
;;;761            if(huart->Init.Parity == UART_PARITY_NONE)
;;;762            {
;;;763              *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
;;;764              pData +=2U;
;;;765            }
;;;766            else
;;;767            {
;;;768              *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
;;;769              pData +=1U;
;;;770            }
;;;771    
;;;772          } 
;;;773          else
;;;774          {
;;;775            if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;776            {
;;;777              return HAL_TIMEOUT;
;;;778            }
;;;779            if(huart->Init.Parity == UART_PARITY_NONE)
;;;780            {
;;;781              *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
;;;782            }
;;;783            else
;;;784            {
;;;785              *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
;;;786            }
;;;787    
;;;788          }
;;;789        }
;;;790    
;;;791        /* At end of Rx process, restore huart->RxState to Ready */
;;;792        huart->RxState = HAL_UART_STATE_READY;
;;;793        
;;;794        /* Process Unlocked */
;;;795        __HAL_UNLOCK(huart);
;;;796    
;;;797        return HAL_OK;
;;;798      }
;;;799      else
;;;800      {
;;;801        return HAL_BUSY;
;;;802      }
;;;803    }
00003e  e8bd83f8          POP      {r3-r9,pc}
                  |L29.66|
000042  8de0              LDRH     r0,[r4,#0x2e]         ;753
000044  1e40              SUBS     r0,r0,#1              ;753
000046  85e0              STRH     r0,[r4,#0x2e]         ;753
000048  68a0              LDR      r0,[r4,#8]            ;754
00004a  4643              MOV      r3,r8                 ;775
00004c  f5b05f80          CMP      r0,#0x1000            ;754
000050  f04f0200          MOV      r2,#0                 ;775
000054  f04f0120          MOV      r1,#0x20              ;775
000058  4620              MOV      r0,r4                 ;775
00005a  f8cd9000          STR      r9,[sp,#0]            ;754
00005e  d004              BEQ      |L29.106|
000060  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000064  b198              CBZ      r0,|L29.142|
                  |L29.102|
000066  2003              MOVS     r0,#3                 ;777
000068  e7e9              B        |L29.62|
                  |L29.106|
00006a  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
00006e  2800              CMP      r0,#0                 ;756
000070  d1f9              BNE      |L29.102|
000072  6920              LDR      r0,[r4,#0x10]         ;761
000074  2800              CMP      r0,#0                 ;761
000076  6820              LDR      r0,[r4,#0]            ;768
000078  6840              LDR      r0,[r0,#4]            ;768
00007a  d003              BEQ      |L29.132|
00007c  b2c1              UXTB     r1,r0                 ;768
00007e  f8251b01          STRH     r1,[r5],#1            ;768
000082  e00d              B        |L29.160|
                  |L29.132|
000084  f3c00108          UBFX     r1,r0,#0,#9           ;763
000088  f8251b02          STRH     r1,[r5],#2            ;763
00008c  e008              B        |L29.160|
                  |L29.142|
00008e  6920              LDR      r0,[r4,#0x10]         ;779
000090  2800              CMP      r0,#0                 ;779
000092  6820              LDR      r0,[r4,#0]            ;785
000094  6840              LDR      r0,[r0,#4]            ;785
000096  d001              BEQ      |L29.156|
000098  f000007f          AND      r0,r0,#0x7f           ;785
                  |L29.156|
00009c  f8050b01          STRB     r0,[r5],#1            ;781
                  |L29.160|
0000a0  8de0              LDRH     r0,[r4,#0x2e]         ;751
0000a2  2800              CMP      r0,#0                 ;751
0000a4  d1cd              BNE      |L29.66|
0000a6  2020              MOVS     r0,#0x20              ;792
0000a8  f884003a          STRB     r0,[r4,#0x3a]         ;792
0000ac  f8847038          STRB     r7,[r4,#0x38]         ;795
0000b0  2000              MOVS     r0,#0                 ;797
0000b2  e7c4              B        |L29.62|
                  |L29.180|
0000b4  2002              MOVS     r0,#2                 ;801
0000b6  e7c2              B        |L29.62|
;;;804    
                          ENDP


                          AREA ||i.HAL_UART_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive_DMA PROC
;;;966      */
;;;967    HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;968    {
000002  4604              MOV      r4,r0
;;;969      uint32_t *tmp;
;;;970      
;;;971      /* Check that a Rx process is not already ongoing */
;;;972      if(huart->RxState == HAL_UART_STATE_READY) 
000004  f890003a          LDRB     r0,[r0,#0x3a]
000008  2820              CMP      r0,#0x20
00000a  d13c              BNE      |L30.134|
;;;973      {
;;;974        if((pData == NULL) || (Size == 0U))
00000c  b3c1              CBZ      r1,|L30.128|
00000e  b3ba              CBZ      r2,|L30.128|
;;;975        {
;;;976          return HAL_ERROR;
;;;977        }
;;;978    
;;;979        /* Process Locked */
;;;980        __HAL_LOCK(huart);
000010  f8940038          LDRB     r0,[r4,#0x38]
000014  2801              CMP      r0,#1
000016  d036              BEQ      |L30.134|
000018  2001              MOVS     r0,#1
00001a  f8840038          STRB     r0,[r4,#0x38]
;;;981    
;;;982        huart->pRxBuffPtr = pData;
;;;983        huart->RxXferSize = Size;
00001e  62a1              STR      r1,[r4,#0x28]
000020  85a2              STRH     r2,[r4,#0x2c]
;;;984    
;;;985        huart->ErrorCode = HAL_UART_ERROR_NONE;
000022  2500              MOVS     r5,#0
000024  63e5              STR      r5,[r4,#0x3c]
;;;986        huart->RxState = HAL_UART_STATE_BUSY_RX;
000026  2022              MOVS     r0,#0x22
000028  f884003a          STRB     r0,[r4,#0x3a]
;;;987    
;;;988        /* Set the UART DMA transfer complete callback */
;;;989        huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
00002c  6b63              LDR      r3,[r4,#0x34]
00002e  4817              LDR      r0,|L30.140|
;;;990    
;;;991        /* Set the UART DMA Half transfer complete callback */
;;;992        huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
000030  6298              STR      r0,[r3,#0x28]
000032  6b63              LDR      r3,[r4,#0x34]
000034  4816              LDR      r0,|L30.144|
;;;993    
;;;994        /* Set the DMA error callback */
;;;995        huart->hdmarx->XferErrorCallback = UART_DMAError;
000036  62d8              STR      r0,[r3,#0x2c]
000038  6b63              LDR      r3,[r4,#0x34]
00003a  4816              LDR      r0,|L30.148|
;;;996    
;;;997        /* Set the DMA abort callback */
;;;998        huart->hdmarx->XferAbortCallback = NULL;
00003c  6318              STR      r0,[r3,#0x30]
00003e  6b60              LDR      r0,[r4,#0x34]
;;;999    
;;;1000       /* Enable the DMA channel */
;;;1001       tmp = (uint32_t*)&pData;
;;;1002       HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t*)tmp, Size);
000040  4613              MOV      r3,r2
000042  6345              STR      r5,[r0,#0x34]         ;998
000044  4608              MOV      r0,r1                 ;998
000046  6b66              LDR      r6,[r4,#0x34]
000048  6821              LDR      r1,[r4,#0]
00004a  4602              MOV      r2,r0
00004c  4630              MOV      r0,r6
00004e  1d09              ADDS     r1,r1,#4
000050  f7fffffe          BL       HAL_DMA_Start_IT
;;;1003   
;;;1004       /* Clear the Overrun flag just before enabling the DMA Rx request: can be mandatory for the second transfer */
;;;1005       __HAL_UART_CLEAR_OREFLAG(huart);
000054  6820              LDR      r0,[r4,#0]
000056  6801              LDR      r1,[r0,#0]
000058  6841              LDR      r1,[r0,#4]
;;;1006   
;;;1007       /* Process Unlocked */
;;;1008       __HAL_UNLOCK(huart);
00005a  9100              STR      r1,[sp,#0]
00005c  f8845038          STRB     r5,[r4,#0x38]
;;;1009   
;;;1010       /* Enable the UART Parity Error Interrupt */
;;;1011       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
000060  68c1              LDR      r1,[r0,#0xc]
000062  f4417180          ORR      r1,r1,#0x100
000066  60c1              STR      r1,[r0,#0xc]
;;;1012   
;;;1013       /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1014       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
000068  6820              LDR      r0,[r4,#0]
00006a  6941              LDR      r1,[r0,#0x14]
00006c  f0410101          ORR      r1,r1,#1
000070  6141              STR      r1,[r0,#0x14]
;;;1015   
;;;1016       /* Enable the DMA transfer for the receiver request by setting the DMAR bit 
;;;1017       in the UART CR3 register */
;;;1018       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000072  6820              LDR      r0,[r4,#0]
000074  6941              LDR      r1,[r0,#0x14]
000076  f0410140          ORR      r1,r1,#0x40
00007a  6141              STR      r1,[r0,#0x14]
;;;1019   
;;;1020       return HAL_OK;
00007c  2000              MOVS     r0,#0
                  |L30.126|
;;;1021     }
;;;1022     else
;;;1023     {
;;;1024       return HAL_BUSY;
;;;1025     }
;;;1026   }
00007e  bdf8              POP      {r3-r7,pc}
                  |L30.128|
000080  e7ff              B        |L30.130|
                  |L30.130|
000082  2001              MOVS     r0,#1                 ;976
000084  e7fb              B        |L30.126|
                  |L30.134|
000086  2002              MOVS     r0,#2                 ;1024
000088  e7f9              B        |L30.126|
;;;1027   
                          ENDP

00008a  0000              DCW      0x0000
                  |L30.140|
                          DCD      UART_DMAReceiveCplt
                  |L30.144|
                          DCD      UART_DMARxHalfCplt
                  |L30.148|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Receive_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive_IT PROC
;;;853      */
;;;854    HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  f890303a          LDRB     r3,[r0,#0x3a]
;;;855    {
;;;856      /* Check that a Rx process is not already ongoing */
;;;857      if(huart->RxState == HAL_UART_STATE_READY)
000004  2b20              CMP      r3,#0x20
000006  d122              BNE      |L31.78|
;;;858      {
;;;859        if((pData == NULL) || (Size == 0U))
000008  b1f9              CBZ      r1,|L31.74|
00000a  b1f2              CBZ      r2,|L31.74|
;;;860        {
;;;861          return HAL_ERROR;
;;;862        }
;;;863    
;;;864        /* Process Locked */
;;;865        __HAL_LOCK(huart);
00000c  f8903038          LDRB     r3,[r0,#0x38]
000010  2b01              CMP      r3,#1
000012  d01c              BEQ      |L31.78|
;;;866    
;;;867        huart->pRxBuffPtr = pData;
;;;868        huart->RxXferSize = Size;
000014  6281              STR      r1,[r0,#0x28]
000016  8582              STRH     r2,[r0,#0x2c]
;;;869        huart->RxXferCount = Size;
000018  85c2              STRH     r2,[r0,#0x2e]
;;;870    
;;;871        huart->ErrorCode = HAL_UART_ERROR_NONE;
00001a  2100              MOVS     r1,#0
00001c  63c1              STR      r1,[r0,#0x3c]
;;;872        huart->RxState = HAL_UART_STATE_BUSY_RX;
00001e  2222              MOVS     r2,#0x22
000020  f880203a          STRB     r2,[r0,#0x3a]
;;;873        
;;;874        /* Process Unlocked */
;;;875        __HAL_UNLOCK(huart);
000024  f8801038          STRB     r1,[r0,#0x38]
;;;876    
;;;877        /* Enable the UART Parity Error Interrupt */
;;;878        __HAL_UART_ENABLE_IT(huart, UART_IT_PE);
000028  6801              LDR      r1,[r0,#0]
00002a  68ca              LDR      r2,[r1,#0xc]
00002c  f4427280          ORR      r2,r2,#0x100
000030  60ca              STR      r2,[r1,#0xc]
;;;879    
;;;880        /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;881        __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
000032  6801              LDR      r1,[r0,#0]
000034  694a              LDR      r2,[r1,#0x14]
000036  f0420201          ORR      r2,r2,#1
00003a  614a              STR      r2,[r1,#0x14]
;;;882    
;;;883        /* Enable the UART Data Register not empty Interrupt */
;;;884        __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);
00003c  6800              LDR      r0,[r0,#0]
00003e  68c1              LDR      r1,[r0,#0xc]
000040  f0410120          ORR      r1,r1,#0x20
000044  60c1              STR      r1,[r0,#0xc]
;;;885    
;;;886        return HAL_OK;
000046  2000              MOVS     r0,#0
;;;887      }
;;;888      else
;;;889      {
;;;890        return HAL_BUSY;
;;;891      }
;;;892    }
000048  4770              BX       lr
                  |L31.74|
00004a  2001              MOVS     r0,#1                 ;861
00004c  4770              BX       lr
                  |L31.78|
00004e  2002              MOVS     r0,#2                 ;890
000050  4770              BX       lr
;;;893    
                          ENDP


                          AREA ||i.HAL_UART_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxCpltCallback PROC
;;;1711     */
;;;1712   __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1713   {
;;;1714     /* Prevent unused argument(s) compilation warning */
;;;1715     UNUSED(huart);
;;;1716     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1717              the HAL_UART_RxCpltCallback could be implemented in the user file
;;;1718      */
;;;1719   }
;;;1720   
                          ENDP


                          AREA ||i.HAL_UART_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxHalfCpltCallback PROC
;;;1726     */
;;;1727   __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1728   {
;;;1729     /* Prevent unused argument(s) compilation warning */
;;;1730     UNUSED(huart);
;;;1731     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1732              the HAL_UART_RxHalfCpltCallback could be implemented in the user file
;;;1733      */
;;;1734   }
;;;1735   
                          ENDP


                          AREA ||i.HAL_UART_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit PROC
;;;642      */
;;;643    HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;644    {
000004  4604              MOV      r4,r0
;;;645      uint16_t* tmp;
;;;646      uint32_t tickstart = 0U;
;;;647      
;;;648      /* Check that a Tx process is not already ongoing */
;;;649      if(huart->gState == HAL_UART_STATE_READY)
000006  f8900039          LDRB     r0,[r0,#0x39]
00000a  461f              MOV      r7,r3                 ;644
00000c  4616              MOV      r6,r2                 ;644
00000e  460d              MOV      r5,r1                 ;644
000010  2820              CMP      r0,#0x20
000012  d150              BNE      |L34.182|
;;;650      {
;;;651        if((pData == NULL) || (Size == 0U))
000014  b1a5              CBZ      r5,|L34.64|
000016  b19e              CBZ      r6,|L34.64|
;;;652        {
;;;653          return  HAL_ERROR;
;;;654        }
;;;655    
;;;656        /* Process Locked */
;;;657        __HAL_LOCK(huart);
000018  f8940038          LDRB     r0,[r4,#0x38]
00001c  2801              CMP      r0,#1
00001e  d04a              BEQ      |L34.182|
000020  2001              MOVS     r0,#1
000022  f8840038          STRB     r0,[r4,#0x38]
;;;658    
;;;659        huart->ErrorCode = HAL_UART_ERROR_NONE;
000026  f04f0800          MOV      r8,#0
00002a  f8c4803c          STR      r8,[r4,#0x3c]
;;;660        huart->gState = HAL_UART_STATE_BUSY_TX;
00002e  2021              MOVS     r0,#0x21
000030  f8840039          STRB     r0,[r4,#0x39]
;;;661    
;;;662        /* Init tickstart for timeout managment */
;;;663        tickstart = HAL_GetTick();
000034  f7fffffe          BL       HAL_GetTick
;;;664    
;;;665        huart->TxXferSize = Size;
000038  84a6              STRH     r6,[r4,#0x24]
00003a  4681              MOV      r9,r0                 ;663
;;;666        huart->TxXferCount = Size;
00003c  84e6              STRH     r6,[r4,#0x26]
00003e  e026              B        |L34.142|
                  |L34.64|
000040  2001              MOVS     r0,#1                 ;653
                  |L34.66|
;;;667        while(huart->TxXferCount > 0U)
;;;668        {
;;;669          huart->TxXferCount--;
;;;670          if(huart->Init.WordLength == UART_WORDLENGTH_9B)
;;;671          {
;;;672            if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;673            {
;;;674              return HAL_TIMEOUT;
;;;675            }
;;;676            tmp = (uint16_t*) pData;
;;;677            huart->Instance->DR = (*tmp & (uint16_t)0x01FF);
;;;678            if(huart->Init.Parity == UART_PARITY_NONE)
;;;679            {
;;;680              pData +=2U;
;;;681            }
;;;682            else
;;;683            {
;;;684              pData +=1U;
;;;685            }
;;;686          }
;;;687          else
;;;688          {
;;;689            if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;690            {
;;;691              return HAL_TIMEOUT;
;;;692            }
;;;693            huart->Instance->DR = (*pData++ & (uint8_t)0xFF);
;;;694          }
;;;695        }
;;;696    
;;;697        if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;698        {
;;;699          return HAL_TIMEOUT;
;;;700        }
;;;701    
;;;702        /* At end of Tx process, restore huart->gState to Ready */
;;;703        huart->gState = HAL_UART_STATE_READY;
;;;704    
;;;705        /* Process Unlocked */
;;;706        __HAL_UNLOCK(huart);
;;;707    
;;;708        return HAL_OK;
;;;709      }
;;;710      else
;;;711      {
;;;712        return HAL_BUSY;
;;;713      }
;;;714    }
000042  e8bd83f8          POP      {r3-r9,pc}
                  |L34.70|
000046  8ce0              LDRH     r0,[r4,#0x26]         ;669
000048  1e40              SUBS     r0,r0,#1              ;669
00004a  84e0              STRH     r0,[r4,#0x26]         ;669
00004c  68a0              LDR      r0,[r4,#8]            ;670
00004e  464b              MOV      r3,r9                 ;689
000050  f5b05f80          CMP      r0,#0x1000            ;670
000054  f04f0200          MOV      r2,#0                 ;689
000058  f04f0180          MOV      r1,#0x80              ;689
00005c  4620              MOV      r0,r4                 ;689
00005e  9700              STR      r7,[sp,#0]            ;670
000060  d003              BEQ      |L34.106|
000062  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000066  b9e8              CBNZ     r0,|L34.164|
000068  e00d              B        |L34.134|
                  |L34.106|
00006a  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
00006e  b9c8              CBNZ     r0,|L34.164|
000070  8828              LDRH     r0,[r5,#0]            ;677
000072  6821              LDR      r1,[r4,#0]            ;677
000074  f3c00008          UBFX     r0,r0,#0,#9           ;677
000078  6048              STR      r0,[r1,#4]            ;677
00007a  6920              LDR      r0,[r4,#0x10]         ;678
00007c  b108              CBZ      r0,|L34.130|
00007e  1c6d              ADDS     r5,r5,#1              ;678
000080  e005              B        |L34.142|
                  |L34.130|
000082  1cad              ADDS     r5,r5,#2              ;684
000084  e003              B        |L34.142|
                  |L34.134|
000086  6821              LDR      r1,[r4,#0]            ;693
000088  f8150b01          LDRB     r0,[r5],#1            ;693
00008c  6048              STR      r0,[r1,#4]            ;693
                  |L34.142|
00008e  8ce0              LDRH     r0,[r4,#0x26]         ;667
000090  2800              CMP      r0,#0                 ;667
000092  d1d8              BNE      |L34.70|
000094  464b              MOV      r3,r9                 ;697
000096  2200              MOVS     r2,#0                 ;697
000098  2140              MOVS     r1,#0x40              ;697
00009a  4620              MOV      r0,r4                 ;697
00009c  9700              STR      r7,[sp,#0]            ;697
00009e  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
0000a2  b108              CBZ      r0,|L34.168|
                  |L34.164|
0000a4  2003              MOVS     r0,#3                 ;699
0000a6  e7cc              B        |L34.66|
                  |L34.168|
0000a8  2020              MOVS     r0,#0x20              ;703
0000aa  f8840039          STRB     r0,[r4,#0x39]         ;703
0000ae  f8848038          STRB     r8,[r4,#0x38]         ;706
0000b2  2000              MOVS     r0,#0                 ;708
0000b4  e7c5              B        |L34.66|
                  |L34.182|
0000b6  2002              MOVS     r0,#2                 ;712
0000b8  e7c3              B        |L34.66|
;;;715    
                          ENDP


                          AREA ||i.HAL_UART_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit_DMA PROC
;;;901      */
;;;902    HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;903    {
000002  4604              MOV      r4,r0
;;;904      uint32_t *tmp;
;;;905      
;;;906      /* Check that a Tx process is not already ongoing */
;;;907      if(huart->gState == HAL_UART_STATE_READY)
000004  f8900039          LDRB     r0,[r0,#0x39]
000008  2820              CMP      r0,#0x20
00000a  d130              BNE      |L35.110|
;;;908      {
;;;909        if((pData == NULL) || (Size == 0U))
00000c  b369              CBZ      r1,|L35.106|
00000e  b362              CBZ      r2,|L35.106|
;;;910        {
;;;911          return HAL_ERROR;
;;;912        }
;;;913    
;;;914        /* Process Locked */
;;;915        __HAL_LOCK(huart);
000010  f8940038          LDRB     r0,[r4,#0x38]
000014  2801              CMP      r0,#1
000016  d02a              BEQ      |L35.110|
000018  2001              MOVS     r0,#1
00001a  f8840038          STRB     r0,[r4,#0x38]
;;;916    
;;;917        huart->pTxBuffPtr = pData;
;;;918        huart->TxXferSize = Size;
00001e  6221              STR      r1,[r4,#0x20]
000020  84a2              STRH     r2,[r4,#0x24]
;;;919        huart->TxXferCount = Size;
000022  84e2              STRH     r2,[r4,#0x26]
;;;920    
;;;921        huart->ErrorCode = HAL_UART_ERROR_NONE;
000024  2500              MOVS     r5,#0
000026  63e5              STR      r5,[r4,#0x3c]
;;;922        huart->gState = HAL_UART_STATE_BUSY_TX;
000028  2021              MOVS     r0,#0x21
00002a  f8840039          STRB     r0,[r4,#0x39]
;;;923    
;;;924        /* Set the UART DMA transfer complete callback */
;;;925        huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
00002e  6b23              LDR      r3,[r4,#0x30]
000030  4810              LDR      r0,|L35.116|
;;;926    
;;;927        /* Set the UART DMA Half transfer complete callback */
;;;928        huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
000032  6298              STR      r0,[r3,#0x28]
000034  6b23              LDR      r3,[r4,#0x30]
000036  4810              LDR      r0,|L35.120|
;;;929    
;;;930        /* Set the DMA error callback */
;;;931        huart->hdmatx->XferErrorCallback = UART_DMAError;
000038  62d8              STR      r0,[r3,#0x2c]
00003a  6b23              LDR      r3,[r4,#0x30]
00003c  480f              LDR      r0,|L35.124|
;;;932    
;;;933        /* Set the DMA abort callback */
;;;934        huart->hdmatx->XferAbortCallback = NULL;
00003e  6318              STR      r0,[r3,#0x30]
000040  6b20              LDR      r0,[r4,#0x30]
;;;935    
;;;936        /* Enable the UART transmit DMA channel */
;;;937        tmp = (uint32_t*)&pData;
;;;938        HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t*)tmp, (uint32_t)&huart->Instance->DR, Size);
000042  4613              MOV      r3,r2
000044  6345              STR      r5,[r0,#0x34]
000046  6826              LDR      r6,[r4,#0]
000048  6b20              LDR      r0,[r4,#0x30]
00004a  1d32              ADDS     r2,r6,#4
00004c  f7fffffe          BL       HAL_DMA_Start_IT
;;;939    
;;;940        /* Clear the TC flag in the SR register by writing 0 to it */
;;;941        __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
000050  6821              LDR      r1,[r4,#0]
000052  f06f0040          MVN      r0,#0x40
000056  6008              STR      r0,[r1,#0]
;;;942    
;;;943        /* Process Unlocked */
;;;944        __HAL_UNLOCK(huart);
000058  f8845038          STRB     r5,[r4,#0x38]
;;;945    
;;;946        /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;947           in the UART CR3 register */
;;;948        SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00005c  6820              LDR      r0,[r4,#0]
00005e  6941              LDR      r1,[r0,#0x14]
000060  f0410180          ORR      r1,r1,#0x80
000064  6141              STR      r1,[r0,#0x14]
;;;949    
;;;950        return HAL_OK;
000066  2000              MOVS     r0,#0
;;;951      }
;;;952      else
;;;953      {
;;;954        return HAL_BUSY;
;;;955      }
;;;956    }
000068  bd70              POP      {r4-r6,pc}
                  |L35.106|
00006a  2001              MOVS     r0,#1                 ;911
00006c  bd70              POP      {r4-r6,pc}
                  |L35.110|
00006e  2002              MOVS     r0,#2                 ;954
000070  bd70              POP      {r4-r6,pc}
;;;957    
                          ENDP

000072  0000              DCW      0x0000
                  |L35.116|
                          DCD      UART_DMATransmitCplt
                  |L35.120|
                          DCD      UART_DMATxHalfCplt
                  |L35.124|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit_IT PROC
;;;812      */
;;;813    HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  f8903039          LDRB     r3,[r0,#0x39]
;;;814    {
;;;815      /* Check that a Tx process is not already ongoing */
;;;816      if(huart->gState == HAL_UART_STATE_READY)
000004  2b20              CMP      r3,#0x20
000006  d118              BNE      |L36.58|
;;;817      {
;;;818        if((pData == NULL) || (Size == 0U)) 
000008  b1a9              CBZ      r1,|L36.54|
00000a  b1a2              CBZ      r2,|L36.54|
;;;819        {
;;;820          return HAL_ERROR;
;;;821        }
;;;822        /* Process Locked */
;;;823        __HAL_LOCK(huart);
00000c  f8903038          LDRB     r3,[r0,#0x38]
000010  2b01              CMP      r3,#1
000012  d012              BEQ      |L36.58|
;;;824    
;;;825        huart->pTxBuffPtr = pData;
;;;826        huart->TxXferSize = Size;
000014  6201              STR      r1,[r0,#0x20]
000016  8482              STRH     r2,[r0,#0x24]
;;;827        huart->TxXferCount = Size;
000018  84c2              STRH     r2,[r0,#0x26]
;;;828    
;;;829        huart->ErrorCode = HAL_UART_ERROR_NONE;
00001a  2100              MOVS     r1,#0
00001c  63c1              STR      r1,[r0,#0x3c]
;;;830        huart->gState = HAL_UART_STATE_BUSY_TX;
00001e  2221              MOVS     r2,#0x21
000020  f8802039          STRB     r2,[r0,#0x39]
;;;831    
;;;832        /* Process Unlocked */
;;;833        __HAL_UNLOCK(huart);
000024  f8801038          STRB     r1,[r0,#0x38]
;;;834    
;;;835        /* Enable the UART Transmit data register empty Interrupt */
;;;836        __HAL_UART_ENABLE_IT(huart, UART_IT_TXE);
000028  6800              LDR      r0,[r0,#0]
00002a  68c1              LDR      r1,[r0,#0xc]
00002c  f0410180          ORR      r1,r1,#0x80
000030  60c1              STR      r1,[r0,#0xc]
;;;837    
;;;838        return HAL_OK;
000032  2000              MOVS     r0,#0
;;;839      }
;;;840      else
;;;841      {
;;;842        return HAL_BUSY;
;;;843      }
;;;844    }
000034  4770              BX       lr
                  |L36.54|
000036  2001              MOVS     r0,#1                 ;820
000038  4770              BX       lr
                  |L36.58|
00003a  2002              MOVS     r0,#2                 ;842
00003c  4770              BX       lr
;;;845    
                          ENDP


                          AREA ||i.HAL_UART_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxCpltCallback PROC
;;;1681     */
;;;1682    __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1683   {
;;;1684     /* Prevent unused argument(s) compilation warning */
;;;1685     UNUSED(huart);
;;;1686     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1687              the HAL_UART_TxCpltCallback could be implemented in the user file
;;;1688      */ 
;;;1689   }
;;;1690   
                          ENDP


                          AREA ||i.HAL_UART_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxHalfCpltCallback PROC
;;;1696     */
;;;1697    __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1698   {
;;;1699     /* Prevent unused argument(s) compilation warning */
;;;1700     UNUSED(huart);
;;;1701     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1702              the HAL_UART_TxHalfCpltCallback could be implemented in the user file
;;;1703      */ 
;;;1704   }
;;;1705   
                          ENDP


                          AREA ||i.UART_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  UART_DMAAbortOnError PROC
;;;2203     */
;;;2204   static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2205   {
;;;2206     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2207     huart->RxXferCount = 0x00U;
000004  2100              MOVS     r1,#0
000006  85c1              STRH     r1,[r0,#0x2e]
;;;2208     huart->TxXferCount = 0x00U;
000008  84c1              STRH     r1,[r0,#0x26]
;;;2209   
;;;2210     HAL_UART_ErrorCallback(huart);
00000a  f7fffffe          BL       HAL_UART_ErrorCallback
;;;2211   }
00000e  bd10              POP      {r4,pc}
;;;2212   
                          ENDP


                          AREA ||i.UART_DMAError||, CODE, READONLY, ALIGN=1

                  UART_DMAError PROC
;;;2105     */
;;;2106   static void UART_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2107   {
;;;2108     uint32_t dmarequest = 0x00U;
;;;2109     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
;;;2110   
;;;2111     /* Stop UART DMA Tx request if ongoing */
;;;2112     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
000002  6a44              LDR      r4,[r0,#0x24]
000004  6820              LDR      r0,[r4,#0]
000006  6940              LDR      r0,[r0,#0x14]
;;;2113     if((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
000008  f8941039          LDRB     r1,[r4,#0x39]
00000c  f3c010c0          UBFX     r0,r0,#7,#1           ;2112
000010  2500              MOVS     r5,#0
000012  2921              CMP      r1,#0x21
000014  d104              BNE      |L40.32|
000016  b118              CBZ      r0,|L40.32|
;;;2114     {
;;;2115       huart->TxXferCount = 0U;
000018  84e5              STRH     r5,[r4,#0x26]
;;;2116       UART_EndTxTransfer(huart);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       UART_EndTxTransfer
                  |L40.32|
;;;2117     }
;;;2118   
;;;2119     /* Stop UART DMA Rx request if ongoing */
;;;2120     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR); 
000020  6820              LDR      r0,[r4,#0]
000022  6940              LDR      r0,[r0,#0x14]
;;;2121     if((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
000024  f894103a          LDRB     r1,[r4,#0x3a]
000028  f3c01080          UBFX     r0,r0,#6,#1           ;2120
00002c  2922              CMP      r1,#0x22
00002e  d104              BNE      |L40.58|
000030  b118              CBZ      r0,|L40.58|
;;;2122     {
;;;2123       huart->RxXferCount = 0U;
000032  85e5              STRH     r5,[r4,#0x2e]
;;;2124       UART_EndRxTransfer(huart);
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       UART_EndRxTransfer
                  |L40.58|
;;;2125     }
;;;2126   
;;;2127     huart->ErrorCode |= HAL_UART_ERROR_DMA;
00003a  6be0              LDR      r0,[r4,#0x3c]
00003c  f0400010          ORR      r0,r0,#0x10
000040  63e0              STR      r0,[r4,#0x3c]
;;;2128     HAL_UART_ErrorCallback(huart);
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       HAL_UART_ErrorCallback
;;;2129   }
000048  bd70              POP      {r4-r6,pc}
;;;2130   
                          ENDP


                          AREA ||i.UART_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  UART_DMAReceiveCplt PROC
;;;2066     */
;;;2067   static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2068   {
000002  4601              MOV      r1,r0
;;;2069     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6a40              LDR      r0,[r0,#0x24]
;;;2070     /* DMA Normal mode*/
;;;2071     if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
000006  6809              LDR      r1,[r1,#0]
000008  6809              LDR      r1,[r1,#0]
00000a  0689              LSLS     r1,r1,#26
00000c  d413              BMI      |L41.54|
;;;2072     {
;;;2073       huart->RxXferCount = 0U;
00000e  2100              MOVS     r1,#0
000010  85c1              STRH     r1,[r0,#0x2e]
;;;2074     
;;;2075       /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2076       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
000012  6801              LDR      r1,[r0,#0]
000014  68ca              LDR      r2,[r1,#0xc]
000016  f4227280          BIC      r2,r2,#0x100
00001a  60ca              STR      r2,[r1,#0xc]
;;;2077       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00001c  6801              LDR      r1,[r0,#0]
00001e  694a              LDR      r2,[r1,#0x14]
000020  f0220201          BIC      r2,r2,#1
000024  614a              STR      r2,[r1,#0x14]
;;;2078       
;;;2079       /* Disable the DMA transfer for the receiver request by setting the DMAR bit 
;;;2080          in the UART CR3 register */
;;;2081       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000026  6801              LDR      r1,[r0,#0]
000028  694a              LDR      r2,[r1,#0x14]
00002a  f0220240          BIC      r2,r2,#0x40
00002e  614a              STR      r2,[r1,#0x14]
;;;2082   
;;;2083       /* At end of Rx process, restore huart->RxState to Ready */
;;;2084       huart->RxState = HAL_UART_STATE_READY;
000030  2120              MOVS     r1,#0x20
000032  f880103a          STRB     r1,[r0,#0x3a]
                  |L41.54|
;;;2085     }
;;;2086     HAL_UART_RxCpltCallback(huart);
000036  f7fffffe          BL       HAL_UART_RxCpltCallback
;;;2087   }
00003a  bd10              POP      {r4,pc}
;;;2088   
                          ENDP


                          AREA ||i.UART_DMARxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxAbortCallback PROC
;;;2258     */
;;;2259   static void UART_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2260   {
;;;2261     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2262     
;;;2263     huart->hdmarx->XferAbortCallback = NULL;
000004  2100              MOVS     r1,#0
000006  6b42              LDR      r2,[r0,#0x34]
;;;2264   
;;;2265     /* Check if an Abort process is still ongoing */
;;;2266     if(huart->hdmatx != NULL)
000008  6351              STR      r1,[r2,#0x34]
00000a  6b02              LDR      r2,[r0,#0x30]         ;2260
00000c  b112              CBZ      r2,|L42.20|
;;;2267     {
;;;2268       if(huart->hdmatx->XferAbortCallback != NULL)
00000e  6b52              LDR      r2,[r2,#0x34]
000010  2a00              CMP      r2,#0
000012  d109              BNE      |L42.40|
                  |L42.20|
;;;2269       {
;;;2270         return;
;;;2271       }
;;;2272     }
;;;2273     
;;;2274     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;2275     huart->TxXferCount = 0x00U;
000014  84c1              STRH     r1,[r0,#0x26]
;;;2276     huart->RxXferCount = 0x00U;
000016  85c1              STRH     r1,[r0,#0x2e]
;;;2277   
;;;2278     /* Reset ErrorCode */
;;;2279     huart->ErrorCode = HAL_UART_ERROR_NONE;
000018  63c1              STR      r1,[r0,#0x3c]
;;;2280   
;;;2281     /* Restore huart->gState and huart->RxState to Ready */
;;;2282     huart->gState  = HAL_UART_STATE_READY;
00001a  2120              MOVS     r1,#0x20
00001c  f8801039          STRB     r1,[r0,#0x39]
;;;2283     huart->RxState = HAL_UART_STATE_READY;
000020  f880103a          STRB     r1,[r0,#0x3a]
;;;2284   
;;;2285     /* Call user Abort complete callback */
;;;2286     HAL_UART_AbortCpltCallback(huart);
000024  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L42.40|
;;;2287   }
000028  bd10              POP      {r4,pc}
;;;2288   
                          ENDP


                          AREA ||i.UART_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMARxHalfCplt PROC
;;;2094     */
;;;2095   static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2096   {
;;;2097     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2098     HAL_UART_RxHalfCpltCallback(huart); 
000004  f7fffffe          BL       HAL_UART_RxHalfCpltCallback
;;;2099   }
000008  bd10              POP      {r4,pc}
;;;2100   
                          ENDP


                          AREA ||i.UART_DMARxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxOnlyAbortCallback PROC
;;;2317     */
;;;2318   static void UART_DMARxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2319   {
;;;2320     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2321   
;;;2322     huart->RxXferCount = 0x00U;
000004  2100              MOVS     r1,#0
000006  85c1              STRH     r1,[r0,#0x2e]
;;;2323   
;;;2324     /* Restore huart->RxState to Ready */
;;;2325     huart->RxState = HAL_UART_STATE_READY;
000008  2120              MOVS     r1,#0x20
00000a  f880103a          STRB     r1,[r0,#0x3a]
;;;2326   
;;;2327     /* Call user Abort complete callback */
;;;2328     HAL_UART_AbortReceiveCpltCallback(huart);
00000e  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
;;;2329   }
000012  bd10              POP      {r4,pc}
;;;2330   
                          ENDP


                          AREA ||i.UART_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATransmitCplt PROC
;;;2025     */
;;;2026   static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2027   {
000002  4601              MOV      r1,r0
;;;2028     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6a40              LDR      r0,[r0,#0x24]
;;;2029     /* DMA Normal mode*/
;;;2030     if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
000006  6809              LDR      r1,[r1,#0]
000008  6809              LDR      r1,[r1,#0]
00000a  0689              LSLS     r1,r1,#26
00000c  d40c              BMI      |L45.40|
;;;2031     {
;;;2032       huart->TxXferCount = 0U;
00000e  2100              MOVS     r1,#0
000010  84c1              STRH     r1,[r0,#0x26]
;;;2033   
;;;2034       /* Disable the DMA transfer for transmit request by setting the DMAT bit
;;;2035          in the UART CR3 register */
;;;2036       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000012  6801              LDR      r1,[r0,#0]
000014  694a              LDR      r2,[r1,#0x14]
000016  f0220280          BIC      r2,r2,#0x80
00001a  614a              STR      r2,[r1,#0x14]
;;;2037   
;;;2038       /* Enable the UART Transmit Complete Interrupt */
;;;2039       SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
00001c  6800              LDR      r0,[r0,#0]
00001e  68c1              LDR      r1,[r0,#0xc]
000020  f0410140          ORR      r1,r1,#0x40
000024  60c1              STR      r1,[r0,#0xc]
;;;2040   
;;;2041     }
;;;2042     /* DMA Circular mode */
;;;2043     else
;;;2044     {
;;;2045       HAL_UART_TxCpltCallback(huart);
;;;2046     }
;;;2047   }
000026  bd10              POP      {r4,pc}
                  |L45.40|
000028  f7fffffe          BL       HAL_UART_TxCpltCallback
00002c  bd10              POP      {r4,pc}
;;;2048   
                          ENDP


                          AREA ||i.UART_DMATxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxAbortCallback PROC
;;;2220     */
;;;2221   static void UART_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2222   {
;;;2223     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2224     
;;;2225     huart->hdmatx->XferAbortCallback = NULL;
000004  2100              MOVS     r1,#0
000006  6b02              LDR      r2,[r0,#0x30]
;;;2226   
;;;2227     /* Check if an Abort process is still ongoing */
;;;2228     if(huart->hdmarx != NULL)
000008  6351              STR      r1,[r2,#0x34]
00000a  6b42              LDR      r2,[r0,#0x34]         ;2222
00000c  b112              CBZ      r2,|L46.20|
;;;2229     {
;;;2230       if(huart->hdmarx->XferAbortCallback != NULL)
00000e  6b52              LDR      r2,[r2,#0x34]
000010  2a00              CMP      r2,#0
000012  d109              BNE      |L46.40|
                  |L46.20|
;;;2231       {
;;;2232         return;
;;;2233       }
;;;2234     }
;;;2235   
;;;2236     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;2237     huart->TxXferCount = 0x00U;
000014  84c1              STRH     r1,[r0,#0x26]
;;;2238     huart->RxXferCount = 0x00U;
000016  85c1              STRH     r1,[r0,#0x2e]
;;;2239   
;;;2240     /* Reset ErrorCode */
;;;2241     huart->ErrorCode = HAL_UART_ERROR_NONE;
000018  63c1              STR      r1,[r0,#0x3c]
;;;2242   
;;;2243     /* Restore huart->gState and huart->RxState to Ready */
;;;2244     huart->gState  = HAL_UART_STATE_READY;
00001a  2120              MOVS     r1,#0x20
00001c  f8801039          STRB     r1,[r0,#0x39]
;;;2245     huart->RxState = HAL_UART_STATE_READY;
000020  f880103a          STRB     r1,[r0,#0x3a]
;;;2246   
;;;2247     /* Call user Abort complete callback */
;;;2248     HAL_UART_AbortCpltCallback(huart);
000024  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L46.40|
;;;2249   }
000028  bd10              POP      {r4,pc}
;;;2250   
                          ENDP


                          AREA ||i.UART_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATxHalfCplt PROC
;;;2054     */
;;;2055   static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2056   {
;;;2057     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2058   
;;;2059     HAL_UART_TxHalfCpltCallback(huart);
000004  f7fffffe          BL       HAL_UART_TxHalfCpltCallback
;;;2060   }
000008  bd10              POP      {r4,pc}
;;;2061   
                          ENDP


                          AREA ||i.UART_DMATxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxOnlyAbortCallback PROC
;;;2296     */
;;;2297   static void UART_DMATxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2298   {
;;;2299     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2300   
;;;2301     huart->TxXferCount = 0x00U;
000004  2100              MOVS     r1,#0
000006  84c1              STRH     r1,[r0,#0x26]
;;;2302   
;;;2303     /* Restore huart->gState to Ready */
;;;2304     huart->gState = HAL_UART_STATE_READY;
000008  2120              MOVS     r1,#0x20
00000a  f8801039          STRB     r1,[r0,#0x39]
;;;2305   
;;;2306     /* Call user Abort complete callback */
;;;2307     HAL_UART_AbortTransmitCpltCallback(huart);
00000e  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
;;;2308   }
000012  bd10              POP      {r4,pc}
;;;2309   
                          ENDP


                          AREA ||i.UART_EndRxTransfer||, CODE, READONLY, ALIGN=1

                  UART_EndRxTransfer PROC
;;;2187     */
;;;2188   static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
000000  6801              LDR      r1,[r0,#0]
;;;2189   {
;;;2190     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2191     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000002  68ca              LDR      r2,[r1,#0xc]
000004  f4227290          BIC      r2,r2,#0x120
000008  60ca              STR      r2,[r1,#0xc]
;;;2192     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000a  6801              LDR      r1,[r0,#0]
00000c  694a              LDR      r2,[r1,#0x14]
00000e  f0220201          BIC      r2,r2,#1
000012  614a              STR      r2,[r1,#0x14]
;;;2193   
;;;2194     /* At end of Rx process, restore huart->RxState to Ready */
;;;2195     huart->RxState = HAL_UART_STATE_READY;
000014  2120              MOVS     r1,#0x20
000016  f880103a          STRB     r1,[r0,#0x3a]
;;;2196   }
00001a  4770              BX       lr
;;;2197   
                          ENDP


                          AREA ||i.UART_EndTxTransfer||, CODE, READONLY, ALIGN=1

                  UART_EndTxTransfer PROC
;;;2173     */
;;;2174   static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
000000  6801              LDR      r1,[r0,#0]
;;;2175   {
;;;2176     /* Disable TXEIE and TCIE interrupts */
;;;2177     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000002  68ca              LDR      r2,[r1,#0xc]
000004  f02202c0          BIC      r2,r2,#0xc0
000008  60ca              STR      r2,[r1,#0xc]
;;;2178   
;;;2179     /* At end of Tx process, restore huart->gState to Ready */
;;;2180     huart->gState = HAL_UART_STATE_READY;
00000a  2120              MOVS     r1,#0x20
00000c  f8801039          STRB     r1,[r0,#0x39]
;;;2181   }
000010  4770              BX       lr
;;;2182   
                          ENDP


                          AREA ||i.UART_Receive_IT||, CODE, READONLY, ALIGN=1

                  UART_Receive_IT PROC
;;;2401     */
;;;2402   static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;2403   {
;;;2404     uint16_t* tmp;
;;;2405     
;;;2406     /* Check that a Rx process is ongoing */
;;;2407     if(huart->RxState == HAL_UART_STATE_BUSY_RX) 
000002  f890103a          LDRB     r1,[r0,#0x3a]
000006  2922              CMP      r1,#0x22
000008  d001              BEQ      |L51.14|
;;;2408     {
;;;2409       if(huart->Init.WordLength == UART_WORDLENGTH_9B)
;;;2410       {
;;;2411         tmp = (uint16_t*) huart->pRxBuffPtr;
;;;2412         if(huart->Init.Parity == UART_PARITY_NONE)
;;;2413         {
;;;2414           *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
;;;2415           huart->pRxBuffPtr += 2U;
;;;2416         }
;;;2417         else
;;;2418         {
;;;2419           *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
;;;2420           huart->pRxBuffPtr += 1U;
;;;2421         }
;;;2422       }
;;;2423       else
;;;2424       {
;;;2425         if(huart->Init.Parity == UART_PARITY_NONE)
;;;2426         {
;;;2427           *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
;;;2428         }
;;;2429         else
;;;2430         {
;;;2431           *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
;;;2432         }
;;;2433       }
;;;2434   
;;;2435       if(--huart->RxXferCount == 0U)
;;;2436       {
;;;2437         /* Disable the IRDA Data Register not empty Interrupt */
;;;2438         __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
;;;2439   
;;;2440         /* Disable the UART Parity Error Interrupt */
;;;2441         __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
;;;2442           /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;2443           __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
;;;2444   
;;;2445         /* Rx process is completed, restore huart->RxState to Ready */
;;;2446         huart->RxState = HAL_UART_STATE_READY;
;;;2447   
;;;2448         HAL_UART_RxCpltCallback(huart);
;;;2449   
;;;2450         return HAL_OK;
;;;2451       }
;;;2452       return HAL_OK;
;;;2453     }
;;;2454     else
;;;2455     {
;;;2456       return HAL_BUSY;
00000a  2002              MOVS     r0,#2
;;;2457     }
;;;2458   }
00000c  bd10              POP      {r4,pc}
                  |L51.14|
00000e  6881              LDR      r1,[r0,#8]            ;2409
000010  f5b15f80          CMP      r1,#0x1000            ;2409
000014  d011              BEQ      |L51.58|
000016  6901              LDR      r1,[r0,#0x10]         ;2425
000018  2900              CMP      r1,#0                 ;2425
00001a  6801              LDR      r1,[r0,#0]            ;2425
00001c  d01f              BEQ      |L51.94|
00001e  6849              LDR      r1,[r1,#4]            ;2431
000020  f001037f          AND      r3,r1,#0x7f           ;2431
000024  6a81              LDR      r1,[r0,#0x28]         ;2431
000026  1c4a              ADDS     r2,r1,#1              ;2431
000028  6282              STR      r2,[r0,#0x28]         ;2431
00002a  700b              STRB     r3,[r1,#0]            ;2431
                  |L51.44|
00002c  8dc1              LDRH     r1,[r0,#0x2e]         ;2435
00002e  1e49              SUBS     r1,r1,#1              ;2435
000030  0409              LSLS     r1,r1,#16             ;2435
000032  0c09              LSRS     r1,r1,#16             ;2435
000034  85c1              STRH     r1,[r0,#0x2e]         ;2435
000036  d018              BEQ      |L51.106|
000038  e02b              B        |L51.146|
                  |L51.58|
00003a  6902              LDR      r2,[r0,#0x10]         ;2412
00003c  6a81              LDR      r1,[r0,#0x28]         ;2412
00003e  2a00              CMP      r2,#0                 ;2412
000040  6802              LDR      r2,[r0,#0]            ;2419
000042  6852              LDR      r2,[r2,#4]            ;2419
000044  d005              BEQ      |L51.82|
000046  b2d2              UXTB     r2,r2                 ;2419
000048  800a              STRH     r2,[r1,#0]            ;2419
00004a  6a81              LDR      r1,[r0,#0x28]         ;2420
00004c  1c49              ADDS     r1,r1,#1              ;2420
                  |L51.78|
00004e  6281              STR      r1,[r0,#0x28]         ;2415
000050  e7ec              B        |L51.44|
                  |L51.82|
000052  f3c20208          UBFX     r2,r2,#0,#9           ;2414
000056  800a              STRH     r2,[r1,#0]            ;2414
000058  6a81              LDR      r1,[r0,#0x28]         ;2415
00005a  1c89              ADDS     r1,r1,#2              ;2415
00005c  e7f7              B        |L51.78|
                  |L51.94|
00005e  684a              LDR      r2,[r1,#4]            ;2427
000060  6a81              LDR      r1,[r0,#0x28]         ;2427
000062  1c4b              ADDS     r3,r1,#1              ;2427
000064  6283              STR      r3,[r0,#0x28]         ;2427
000066  700a              STRB     r2,[r1,#0]            ;2427
000068  e7e0              B        |L51.44|
                  |L51.106|
00006a  6801              LDR      r1,[r0,#0]            ;2438
00006c  68ca              LDR      r2,[r1,#0xc]          ;2438
00006e  f0220220          BIC      r2,r2,#0x20           ;2438
000072  60ca              STR      r2,[r1,#0xc]          ;2438
000074  6801              LDR      r1,[r0,#0]            ;2441
000076  68ca              LDR      r2,[r1,#0xc]          ;2441
000078  f4227280          BIC      r2,r2,#0x100          ;2441
00007c  60ca              STR      r2,[r1,#0xc]          ;2441
00007e  6801              LDR      r1,[r0,#0]            ;2443
000080  694a              LDR      r2,[r1,#0x14]         ;2443
000082  f0220201          BIC      r2,r2,#1              ;2443
000086  614a              STR      r2,[r1,#0x14]         ;2443
000088  2120              MOVS     r1,#0x20              ;2446
00008a  f880103a          STRB     r1,[r0,#0x3a]         ;2446
00008e  f7fffffe          BL       HAL_UART_RxCpltCallback
                  |L51.146|
000092  2000              MOVS     r0,#0                 ;2452
000094  bd10              POP      {r4,pc}
;;;2459   
                          ENDP


                          AREA ||i.UART_SetConfig||, CODE, READONLY, ALIGN=2

                  UART_SetConfig PROC
;;;2465     */
;;;2466   static void UART_SetConfig(UART_HandleTypeDef *huart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2467   {
000004  4604              MOV      r4,r0
;;;2468     uint32_t tmpreg = 0x00U;
;;;2469   
;;;2470     /* Check the parameters */
;;;2471     assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
;;;2472     assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
;;;2473     assert_param(IS_UART_PARITY(huart->Init.Parity));
;;;2474     assert_param(IS_UART_MODE(huart->Init.Mode));
;;;2475   
;;;2476     /*------- UART-associated USART registers setting : CR2 Configuration ------*/
;;;2477     /* Configure the UART Stop Bits: Set STOP[13:12] bits according 
;;;2478      * to huart->Init.StopBits value */
;;;2479     MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
000006  6800              LDR      r0,[r0,#0]
000008  6901              LDR      r1,[r0,#0x10]
00000a  68e2              LDR      r2,[r4,#0xc]
00000c  f4215140          BIC      r1,r1,#0x3000
000010  4311              ORRS     r1,r1,r2
000012  6101              STR      r1,[r0,#0x10]
;;;2480   
;;;2481     /*------- UART-associated USART registers setting : CR1 Configuration ------*/
;;;2482     /* Configure the UART Word Length, Parity and mode: 
;;;2483        Set the M bits according to huart->Init.WordLength value 
;;;2484        Set PCE and PS bits according to huart->Init.Parity value
;;;2485        Set TE and RE bits according to huart->Init.Mode value
;;;2486        Set OVER8 bit according to huart->Init.OverSampling value */
;;;2487   
;;;2488   #if defined(USART_CR1_OVER8)
;;;2489     tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
;;;2490     MODIFY_REG(huart->Instance->CR1, 
;;;2491                (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8), 
;;;2492                tmpreg);
;;;2493   #else
;;;2494     tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode;
000014  6921              LDR      r1,[r4,#0x10]
000016  68a0              LDR      r0,[r4,#8]
000018  4308              ORRS     r0,r0,r1
00001a  6961              LDR      r1,[r4,#0x14]
00001c  4308              ORRS     r0,r0,r1
;;;2495     MODIFY_REG(huart->Instance->CR1, 
00001e  6821              LDR      r1,[r4,#0]
000020  68ca              LDR      r2,[r1,#0xc]
000022  f241630c          MOV      r3,#0x160c
000026  439a              BICS     r2,r2,r3
000028  4302              ORRS     r2,r2,r0
00002a  60ca              STR      r2,[r1,#0xc]
;;;2496                (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE), 
;;;2497                tmpreg);
;;;2498   #endif /* USART_CR1_OVER8 */
;;;2499   
;;;2500     /*------- UART-associated USART registers setting : CR3 Configuration ------*/
;;;2501     /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
;;;2502     MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
00002c  6820              LDR      r0,[r4,#0]
00002e  6941              LDR      r1,[r0,#0x14]
000030  69a2              LDR      r2,[r4,#0x18]
000032  f4217140          BIC      r1,r1,#0x300
000036  4311              ORRS     r1,r1,r2
000038  6141              STR      r1,[r0,#0x14]
;;;2503   
;;;2504   #if defined(USART_CR1_OVER8)
;;;2505     /* Check the Over Sampling */
;;;2506     if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
;;;2507     {
;;;2508       /*-------------------------- USART BRR Configuration ---------------------*/
;;;2509       if(huart->Instance == USART1)
;;;2510       {
;;;2511         huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
;;;2512       }
;;;2513       else
;;;2514       {
;;;2515         huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
;;;2516       }
;;;2517     }
;;;2518     else
;;;2519     {
;;;2520       /*-------------------------- USART BRR Configuration ---------------------*/
;;;2521       if(huart->Instance == USART1)
;;;2522       {
;;;2523         huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
;;;2524       }
;;;2525       else
;;;2526       {
;;;2527         huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
;;;2528       }
;;;2529     }
;;;2530   #else
;;;2531     /*-------------------------- USART BRR Configuration ---------------------*/
;;;2532     if(huart->Instance == USART1)
00003a  494c              LDR      r1,|L52.364|
00003c  6820              LDR      r0,[r4,#0]
;;;2533     {
;;;2534       huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
00003e  2564              MOVS     r5,#0x64
000040  2632              MOVS     r6,#0x32
000042  4288              CMP      r0,r1                 ;2532
000044  d13c              BNE      |L52.192|
000046  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00004a  eb0001c0          ADD      r1,r0,r0,LSL #3
00004e  eb011000          ADD      r0,r1,r0,LSL #4
000052  6861              LDR      r1,[r4,#4]
000054  0089              LSLS     r1,r1,#2
000056  fbb0f7f1          UDIV     r7,r0,r1
00005a  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00005e  eb0001c0          ADD      r1,r0,r0,LSL #3
000062  eb011000          ADD      r0,r1,r0,LSL #4
000066  6861              LDR      r1,[r4,#4]
000068  46b0              MOV      r8,r6
00006a  0089              LSLS     r1,r1,#2
00006c  fbb0f0f1          UDIV     r0,r0,r1
000070  fbb0f0f5          UDIV     r0,r0,r5
000074  f06f0118          MVN      r1,#0x18
000078  4348              MULS     r0,r1,r0
00007a  eb070180          ADD      r1,r7,r0,LSL #2
00007e  eb061001          ADD      r0,r6,r1,LSL #4
000082  fbb0f0f5          UDIV     r0,r0,r5
000086  f00006f0          AND      r6,r0,#0xf0
00008a  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00008e  eb0001c0          ADD      r1,r0,r0,LSL #3
000092  eb011000          ADD      r0,r1,r0,LSL #4
000096  6861              LDR      r1,[r4,#4]
000098  0089              LSLS     r1,r1,#2
00009a  fbb0f0f1          UDIV     r0,r0,r1
00009e  fbb0f0f5          UDIV     r0,r0,r5
0000a2  eb061600          ADD      r6,r6,r0,LSL #4
0000a6  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
0000aa  eb0001c0          ADD      r1,r0,r0,LSL #3
0000ae  eb011000          ADD      r0,r1,r0,LSL #4
0000b2  6861              LDR      r1,[r4,#4]
0000b4  0089              LSLS     r1,r1,#2
0000b6  fbb0f7f1          UDIV     r7,r0,r1
0000ba  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
0000be  e03b              B        |L52.312|
                  |L52.192|
;;;2535     }
;;;2536     else
;;;2537     {
;;;2538       huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
0000c0  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0000c4  eb0001c0          ADD      r1,r0,r0,LSL #3
0000c8  eb011000          ADD      r0,r1,r0,LSL #4
0000cc  6861              LDR      r1,[r4,#4]
0000ce  0089              LSLS     r1,r1,#2
0000d0  fbb0f7f1          UDIV     r7,r0,r1
0000d4  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0000d8  eb0001c0          ADD      r1,r0,r0,LSL #3
0000dc  eb011000          ADD      r0,r1,r0,LSL #4
0000e0  6861              LDR      r1,[r4,#4]
0000e2  46b0              MOV      r8,r6
0000e4  0089              LSLS     r1,r1,#2
0000e6  fbb0f0f1          UDIV     r0,r0,r1
0000ea  fbb0f0f5          UDIV     r0,r0,r5
0000ee  f06f0118          MVN      r1,#0x18
0000f2  4348              MULS     r0,r1,r0
0000f4  eb070180          ADD      r1,r7,r0,LSL #2
0000f8  eb061001          ADD      r0,r6,r1,LSL #4
0000fc  fbb0f0f5          UDIV     r0,r0,r5
000100  f00006f0          AND      r6,r0,#0xf0
000104  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000108  eb0001c0          ADD      r1,r0,r0,LSL #3
00010c  eb011000          ADD      r0,r1,r0,LSL #4
000110  6861              LDR      r1,[r4,#4]
000112  0089              LSLS     r1,r1,#2
000114  fbb0f0f1          UDIV     r0,r0,r1
000118  fbb0f0f5          UDIV     r0,r0,r5
00011c  eb061600          ADD      r6,r6,r0,LSL #4
000120  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000124  eb0001c0          ADD      r1,r0,r0,LSL #3
000128  eb011000          ADD      r0,r1,r0,LSL #4
00012c  6861              LDR      r1,[r4,#4]
00012e  0089              LSLS     r1,r1,#2
000130  fbb0f7f1          UDIV     r7,r0,r1
000134  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
                  |L52.312|
000138  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2534
00013c  eb011000          ADD      r0,r1,r0,LSL #4       ;2534
000140  6861              LDR      r1,[r4,#4]            ;2534
000142  0089              LSLS     r1,r1,#2              ;2534
000144  fbb0f0f1          UDIV     r0,r0,r1              ;2534
000148  fbb0f0f5          UDIV     r0,r0,r5              ;2534
00014c  f06f0118          MVN      r1,#0x18              ;2534
000150  4348              MULS     r0,r1,r0              ;2534
000152  eb070180          ADD      r1,r7,r0,LSL #2       ;2534
000156  eb081001          ADD      r0,r8,r1,LSL #4       ;2534
00015a  fbb0f0f5          UDIV     r0,r0,r5              ;2534
00015e  6821              LDR      r1,[r4,#0]            ;2534
000160  f000000f          AND      r0,r0,#0xf            ;2534
000164  4430              ADD      r0,r0,r6              ;2534
000166  6088              STR      r0,[r1,#8]            ;2534
;;;2539     }
;;;2540   #endif /* USART_CR1_OVER8 */
;;;2541   }
000168  e8bd81f0          POP      {r4-r8,pc}
;;;2542   
                          ENDP

                  |L52.364|
                          DCD      0x40013800

                          AREA ||i.UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  UART_Transmit_IT PROC
;;;2336     */
;;;2337   static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
000000  f8901039          LDRB     r1,[r0,#0x39]
;;;2338   {
;;;2339     uint16_t* tmp;
;;;2340     
;;;2341     /* Check that a Tx process is ongoing */
;;;2342     if(huart->gState == HAL_UART_STATE_BUSY_TX)
000004  2921              CMP      r1,#0x21
000006  d001              BEQ      |L53.12|
;;;2343     {
;;;2344       if(huart->Init.WordLength == UART_WORDLENGTH_9B)
;;;2345       {
;;;2346         tmp = (uint16_t*) huart->pTxBuffPtr;
;;;2347         huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
;;;2348         if(huart->Init.Parity == UART_PARITY_NONE)
;;;2349         {
;;;2350           huart->pTxBuffPtr += 2U;
;;;2351         }
;;;2352         else
;;;2353         {
;;;2354           huart->pTxBuffPtr += 1U;
;;;2355         }
;;;2356       } 
;;;2357       else
;;;2358       {
;;;2359         huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
;;;2360       }
;;;2361   
;;;2362       if(--huart->TxXferCount == 0U)
;;;2363       {
;;;2364         /* Disable the UART Transmit Complete Interrupt */
;;;2365         __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
;;;2366   
;;;2367         /* Enable the UART Transmit Complete Interrupt */    
;;;2368         __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
;;;2369       }
;;;2370       return HAL_OK;
;;;2371     }
;;;2372     else
;;;2373     {
;;;2374       return HAL_BUSY;
000008  2002              MOVS     r0,#2
;;;2375     }
;;;2376   }
00000a  4770              BX       lr
                  |L53.12|
00000c  6881              LDR      r1,[r0,#8]            ;2344
00000e  f5b15f80          CMP      r1,#0x1000            ;2344
000012  6a01              LDR      r1,[r0,#0x20]         ;2344
000014  d00b              BEQ      |L53.46|
000016  1c4a              ADDS     r2,r1,#1              ;2359
000018  6202              STR      r2,[r0,#0x20]         ;2359
00001a  6802              LDR      r2,[r0,#0]            ;2359
00001c  7809              LDRB     r1,[r1,#0]            ;2359
00001e  6051              STR      r1,[r2,#4]            ;2359
                  |L53.32|
000020  8cc1              LDRH     r1,[r0,#0x26]         ;2362
000022  1e49              SUBS     r1,r1,#1              ;2362
000024  0409              LSLS     r1,r1,#16             ;2362
000026  0c09              LSRS     r1,r1,#16             ;2362
000028  84c1              STRH     r1,[r0,#0x26]         ;2362
00002a  d00e              BEQ      |L53.74|
00002c  e017              B        |L53.94|
                  |L53.46|
00002e  8809              LDRH     r1,[r1,#0]            ;2347
000030  6802              LDR      r2,[r0,#0]            ;2347
000032  f3c10108          UBFX     r1,r1,#0,#9           ;2347
000036  6051              STR      r1,[r2,#4]            ;2347
000038  6901              LDR      r1,[r0,#0x10]         ;2348
00003a  2900              CMP      r1,#0                 ;2348
00003c  6a01              LDR      r1,[r0,#0x20]         ;2348
00003e  d002              BEQ      |L53.70|
000040  1c49              ADDS     r1,r1,#1              ;2348
                  |L53.66|
000042  6201              STR      r1,[r0,#0x20]         ;2354
000044  e7ec              B        |L53.32|
                  |L53.70|
000046  1c89              ADDS     r1,r1,#2              ;2354
000048  e7fb              B        |L53.66|
                  |L53.74|
00004a  6801              LDR      r1,[r0,#0]            ;2365
00004c  68ca              LDR      r2,[r1,#0xc]          ;2365
00004e  f0220280          BIC      r2,r2,#0x80           ;2365
000052  60ca              STR      r2,[r1,#0xc]          ;2365
000054  6800              LDR      r0,[r0,#0]            ;2368
000056  68c1              LDR      r1,[r0,#0xc]          ;2368
000058  f0410140          ORR      r1,r1,#0x40           ;2368
00005c  60c1              STR      r1,[r0,#0xc]          ;2368
                  |L53.94|
00005e  2000              MOVS     r0,#0                 ;2370
000060  4770              BX       lr
;;;2377   
                          ENDP


                          AREA ||i.UART_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  UART_WaitOnFlagUntilTimeout PROC
;;;2140     */
;;;2141   static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2142   {
000004  4698              MOV      r8,r3
000006  4617              MOV      r7,r2
000008  460e              MOV      r6,r1
00000a  4604              MOV      r4,r0
;;;2143     /* Wait until flag is set */
;;;2144     while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status) 
;;;2145     {
;;;2146       /* Check for the Timeout */
;;;2147       if(Timeout != HAL_MAX_DELAY)
;;;2148       {
;;;2149         if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
;;;2150         {
;;;2151           /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;2152           CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
;;;2153           CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;2154           
;;;2155           huart->gState  = HAL_UART_STATE_READY;
;;;2156           huart->RxState = HAL_UART_STATE_READY;
;;;2157           
;;;2158           /* Process Unlocked */
;;;2159           __HAL_UNLOCK(huart);
;;;2160           
;;;2161           return HAL_TIMEOUT;
00000c  9d06              LDR      r5,[sp,#0x18]
00000e  e01d              B        |L54.76|
                  |L54.16|
000010  1c68              ADDS     r0,r5,#1              ;2147
000012  d01b              BEQ      |L54.76|
000014  b12d              CBZ      r5,|L54.34|
000016  f7fffffe          BL       HAL_GetTick
00001a  eba00008          SUB      r0,r0,r8              ;2149
00001e  42a8              CMP      r0,r5                 ;2149
000020  d914              BLS      |L54.76|
                  |L54.34|
000022  6820              LDR      r0,[r4,#0]            ;2152
000024  68c1              LDR      r1,[r0,#0xc]          ;2152
000026  f42171d0          BIC      r1,r1,#0x1a0          ;2152
00002a  60c1              STR      r1,[r0,#0xc]          ;2152
00002c  6820              LDR      r0,[r4,#0]            ;2153
00002e  6941              LDR      r1,[r0,#0x14]         ;2153
000030  f0210101          BIC      r1,r1,#1              ;2153
000034  6141              STR      r1,[r0,#0x14]         ;2153
000036  2020              MOVS     r0,#0x20              ;2155
000038  f8840039          STRB     r0,[r4,#0x39]         ;2155
00003c  f884003a          STRB     r0,[r4,#0x3a]         ;2156
000040  2000              MOVS     r0,#0                 ;2159
000042  f8840038          STRB     r0,[r4,#0x38]         ;2159
000046  2003              MOVS     r0,#3
                  |L54.72|
;;;2162         }
;;;2163       }
;;;2164     }
;;;2165     
;;;2166     return HAL_OK;
;;;2167   }
000048  e8bd81f0          POP      {r4-r8,pc}
                  |L54.76|
00004c  6820              LDR      r0,[r4,#0]            ;2144
00004e  6800              LDR      r0,[r0,#0]            ;2144
000050  ea360000          BICS     r0,r6,r0              ;2144
000054  d004              BEQ      |L54.96|
000056  2000              MOVS     r0,#0                 ;2144
                  |L54.88|
000058  42b8              CMP      r0,r7                 ;2144
00005a  d0d9              BEQ      |L54.16|
00005c  2000              MOVS     r0,#0                 ;2166
00005e  e7f3              B        |L54.72|
                  |L54.96|
000060  2001              MOVS     r0,#1                 ;2144
000062  e7f9              B        |L54.88|
;;;2168   
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_uart_c_d497114f____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___20_stm32f1xx_hal_uart_c_d497114f____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_uart_c_d497114f____REVSH|
#line 402
|__asm___20_stm32f1xx_hal_uart_c_d497114f____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_uart_c_d497114f____RRX|
#line 587
|__asm___20_stm32f1xx_hal_uart_c_d497114f____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
