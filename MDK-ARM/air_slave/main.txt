; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\main.o --asm_dir=.\air_slave\ --list_dir=.\air_slave\ --depend=.\main.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I.\RTE\_air_slave -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=525 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=.\main.crf ../Src/main.c]
                          THUMB

                          AREA ||i.CheckDevideID||, CODE, READONLY, ALIGN=2

                  CheckDevideID PROC
;;;546      */
;;;547    void CheckDevideID(uint8_t *pDevideID)
000000  b570              PUSH     {r4-r6,lr}
;;;548    {
;;;549    	*pDevideID = HAL_GPIO_ReadPin(ADD1_GPIO_Port,ADD1_Pin)|\
000002  4e0f              LDR      r6,|L1.64|
000004  4604              MOV      r4,r0                 ;548
000006  f44f5180          MOV      r1,#0x1000
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       HAL_GPIO_ReadPin
000010  4605              MOV      r5,r0
000012  1471              ASRS     r1,r6,#17
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       HAL_GPIO_ReadPin
00001a  ea450540          ORR      r5,r5,r0,LSL #1
00001e  f44f4180          MOV      r1,#0x4000
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       HAL_GPIO_ReadPin
000028  ea450580          ORR      r5,r5,r0,LSL #2
00002c  f44f4100          MOV      r1,#0x8000
000030  4630              MOV      r0,r6
000032  f7fffffe          BL       HAL_GPIO_ReadPin
000036  ea4500c0          ORR      r0,r5,r0,LSL #3
00003a  7020              STRB     r0,[r4,#0]
;;;550    			HAL_GPIO_ReadPin(ADD2_GPIO_Port,ADD2_Pin) << 1|\
;;;551    			HAL_GPIO_ReadPin(ADD3_GPIO_Port,ADD3_Pin) << 2|\
;;;552    			HAL_GPIO_ReadPin(ADD4_GPIO_Port,ADD4_Pin) << 3;
;;;553    }
00003c  bd70              POP      {r4-r6,pc}
;;;554    /**
                          ENDP

00003e  0000              DCW      0x0000
                  |L1.64|
                          DCD      0x40010c00

                          AREA ||i.EXE_READ_MUL||, CODE, READONLY, ALIGN=1

                  EXE_READ_MUL PROC
;;;455    }
;;;456    void EXE_READ_MUL(uint8_t *p,uint32_t len)
000000  7801              LDRB     r1,[r0,#0]
;;;457    {
;;;458    	uint8_t addr = p[0];  //开始读的地址
;;;459    	uint8_t length = p[1];//读寄存器的长度
000002  7840              LDRB     r0,[r0,#1]
000004  e000              B        |L2.8|
                  |L2.6|
000006  1c49              ADDS     r1,r1,#1              ;457
                  |L2.8|
;;;460    	for(int i = addr;i < length; i++)
000008  4281              CMP      r1,r0
00000a  dbfc              BLT      |L2.6|
;;;461    	{
;;;462    		
;;;463    	}
;;;464    }
00000c  4770              BX       lr
;;;465    /**
                          ENDP


                          AREA ||i.EXE_READ_SINGLE||, CODE, READONLY, ALIGN=2

                  EXE_READ_SINGLE PROC
;;;439      */
;;;440    uint8_t EXE_READ_SINGLE(uint8_t *p,uint32_t len)
000000  7801              LDRB     r1,[r0,#0]
;;;441    {
;;;442    	switch(p[0])
;;;443    	{
;;;444    		case 0:
;;;445    			return dev_reg.STATE_LOW;
000002  4809              LDR      r0,|L3.40|
000004  b139              CBZ      r1,|L3.22|
000006  2901              CMP      r1,#1                 ;442
000008  d007              BEQ      |L3.26|
00000a  2902              CMP      r1,#2                 ;442
00000c  d007              BEQ      |L3.30|
00000e  2903              CMP      r1,#3                 ;442
000010  d007              BEQ      |L3.34|
;;;446    		case 1:
;;;447    			return dev_reg.STATE_MID;
;;;448    		case 2:
;;;449    			return dev_reg.STATE_HIGH;
;;;450    		case 3:
;;;451    			return dev_reg.STATE_VALVE;
;;;452    		default:
;;;453    			return 0xff;
000012  20ff              MOVS     r0,#0xff
;;;454    	}
;;;455    }
000014  4770              BX       lr
                  |L3.22|
000016  7800              LDRB     r0,[r0,#0]            ;445  ; dev_reg
000018  4770              BX       lr
                  |L3.26|
00001a  7840              LDRB     r0,[r0,#1]            ;447  ; dev_reg
00001c  4770              BX       lr
                  |L3.30|
00001e  7880              LDRB     r0,[r0,#2]            ;449  ; dev_reg
000020  4770              BX       lr
                  |L3.34|
000022  78c0              LDRB     r0,[r0,#3]            ;451  ; dev_reg
000024  4770              BX       lr
;;;456    void EXE_READ_MUL(uint8_t *p,uint32_t len)
                          ENDP

000026  0000              DCW      0x0000
                  |L3.40|
                          DCD      ||.bss||+0x400

                          AREA ||i.EXE_UPDATE_DATE||, CODE, READONLY, ALIGN=1

                  EXE_UPDATE_DATE PROC
;;;534    }
;;;535    void EXE_UPDATE_DATE(uint8_t *p,uint32_t len)
000000  4770              BX       lr
;;;536    {
;;;537    	
;;;538    }							
;;;539    /**
                          ENDP


                          AREA ||i.EXE_WRITE_MUL||, CODE, READONLY, ALIGN=1

                  EXE_WRITE_MUL PROC
;;;530    }
;;;531    void EXE_WRITE_MUL(uint8_t *p,uint32_t len)
000000  4770              BX       lr
;;;532    {
;;;533    	
;;;534    }
;;;535    void EXE_UPDATE_DATE(uint8_t *p,uint32_t len)
                          ENDP


                          AREA ||i.EXE_WRITE_SINGLE||, CODE, READONLY, ALIGN=2

                  EXE_WRITE_SINGLE PROC
;;;473      */
;;;474    void EXE_WRITE_SINGLE(uint8_t *p,uint32_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;475    {
;;;476    	switch(p[0])
000002  7801              LDRB     r1,[r0,#0]
000004  2500              MOVS     r5,#0
;;;477    	{
;;;478    		case 0:
;;;479    			if(p[1] == 0)
;;;480    			{
;;;481    				RelaySwitch(RELAY_LOW,RELAY_ON);
;;;482    				dev_reg.STATE_LOW = 0;
000006  4c21              LDR      r4,|L6.140|
000008  2601              MOVS     r6,#1                 ;476
00000a  b169              CBZ      r1,|L6.40|
00000c  2901              CMP      r1,#1                 ;476
00000e  d019              BEQ      |L6.68|
000010  2902              CMP      r1,#2                 ;476
000012  d026              BEQ      |L6.98|
000014  2903              CMP      r1,#3                 ;476
000016  d106              BNE      |L6.38|
;;;483    			}
;;;484    			else
;;;485    			{
;;;486    				RelaySwitch(RELAY_LOW,RELAY_OFF);
;;;487    				dev_reg.STATE_LOW = 1;
;;;488    			}
;;;489    			break;
;;;490    		case 1:
;;;491    			if(p[1] == 0)
;;;492    			{
;;;493    				dev_reg.STATE_MID = 0;
;;;494    				RelaySwitch(RELAY_MID,RELAY_ON);
;;;495    			}
;;;496    			else
;;;497    			{
;;;498    				RelaySwitch(RELAY_MID,RELAY_OFF);
;;;499    				dev_reg.STATE_MID = 1;
;;;500    			}
;;;501    			break;
;;;502    		case 2:
;;;503    			if(p[1] == 0)
;;;504    			{
;;;505    				RelaySwitch(RELAY_HIGH,RELAY_ON);
;;;506    				dev_reg.STATE_HIGH = 0;
;;;507    			}
;;;508    			else
;;;509    			{
;;;510    				RelaySwitch(RELAY_HIGH,RELAY_OFF);
;;;511    				dev_reg.STATE_HIGH = 1;
;;;512    			}
;;;513    			break;
;;;514    		case 3:
;;;515    			if(p[1] == 0)
000018  7840              LDRB     r0,[r0,#1]
00001a  b380              CBZ      r0,|L6.126|
;;;516    			{
;;;517    				RelaySwitch(RELAY_VALVE,RELAY_ON);
;;;518    				dev_reg.STATE_VALVE = 0;
;;;519    			}
;;;520    			else
;;;521    			{
;;;522    				RelaySwitch(RELAY_VALVE,RELAY_OFF);
00001c  2101              MOVS     r1,#1
00001e  2003              MOVS     r0,#3
000020  f7fffffe          BL       RelaySwitch
;;;523    				dev_reg.STATE_VALVE = 1;
000024  70e6              STRB     r6,[r4,#3]
                  |L6.38|
;;;524    			}
;;;525    				
;;;526    			break;
;;;527    		default:
;;;528    			break;
;;;529    	}
;;;530    }
000026  bd70              POP      {r4-r6,pc}
                  |L6.40|
000028  7840              LDRB     r0,[r0,#1]            ;479
00002a  b128              CBZ      r0,|L6.56|
00002c  2101              MOVS     r1,#1                 ;486
00002e  2002              MOVS     r0,#2                 ;486
000030  f7fffffe          BL       RelaySwitch
000034  7026              STRB     r6,[r4,#0]            ;487
000036  bd70              POP      {r4-r6,pc}
                  |L6.56|
000038  2100              MOVS     r1,#0                 ;481
00003a  2002              MOVS     r0,#2                 ;481
00003c  f7fffffe          BL       RelaySwitch
000040  7025              STRB     r5,[r4,#0]            ;482
000042  bd70              POP      {r4-r6,pc}
                  |L6.68|
000044  7840              LDRB     r0,[r0,#1]            ;491
000046  b128              CBZ      r0,|L6.84|
000048  2101              MOVS     r1,#1                 ;498
00004a  4608              MOV      r0,r1                 ;498
00004c  f7fffffe          BL       RelaySwitch
000050  7066              STRB     r6,[r4,#1]            ;499
000052  bd70              POP      {r4-r6,pc}
                  |L6.84|
000054  7065              STRB     r5,[r4,#1]            ;493
000056  e8bd4070          POP      {r4-r6,lr}            ;494
00005a  2100              MOVS     r1,#0                 ;494
00005c  2001              MOVS     r0,#1                 ;494
00005e  f7ffbffe          B.W      RelaySwitch
                  |L6.98|
000062  7840              LDRB     r0,[r0,#1]            ;503
000064  b128              CBZ      r0,|L6.114|
000066  2101              MOVS     r1,#1                 ;510
000068  2000              MOVS     r0,#0                 ;510
00006a  f7fffffe          BL       RelaySwitch
00006e  70a6              STRB     r6,[r4,#2]            ;511
000070  bd70              POP      {r4-r6,pc}
                  |L6.114|
000072  2100              MOVS     r1,#0                 ;505
000074  4608              MOV      r0,r1                 ;505
000076  f7fffffe          BL       RelaySwitch
00007a  70a5              STRB     r5,[r4,#2]            ;506
                  |L6.124|
00007c  bd70              POP      {r4-r6,pc}
                  |L6.126|
00007e  e7ff              B        |L6.128|
                  |L6.128|
000080  2100              MOVS     r1,#0                 ;517
000082  2003              MOVS     r0,#3                 ;517
000084  f7fffffe          BL       RelaySwitch
000088  70e5              STRB     r5,[r4,#3]            ;518
00008a  e7f7              B        |L6.124|
;;;531    void EXE_WRITE_MUL(uint8_t *p,uint32_t len)
                          ENDP

                  |L6.140|
                          DCD      ||.bss||+0x400

                          AREA ||i.Exe_action||, CODE, READONLY, ALIGN=1

                  Exe_action PROC
;;;684      */
;;;685    void Exe_action(FAN_SPEED f_speed)
000000  b510              PUSH     {r4,lr}
;;;686    {
000002  4604              MOV      r4,r0
;;;687    	RelaySwitch(RELAY_ALL ,RELAY_ON);   //继电器打开
000004  2100              MOVS     r1,#0
000006  2004              MOVS     r0,#4
000008  f7fffffe          BL       RelaySwitch
;;;688    	switch(f_speed)
00000c  b164              CBZ      r4,|L7.40|
00000e  2c01              CMP      r4,#1
000010  d010              BEQ      |L7.52|
000012  2c02              CMP      r4,#2
000014  d114              BNE      |L7.64|
;;;689    	{
;;;690    		case FAN_SPEED_LOW:
;;;691    			RelaySwitch(RELAY_LOW ,RELAY_OFF);
;;;692    			VoltageOutput(VOLATAGE_3);
;;;693    			break;
;;;694    		case FAN_SPEED_MID:
;;;695    			RelaySwitch(RELAY_MID ,RELAY_OFF);
;;;696    			VoltageOutput(VOLATAGE_5);
;;;697    			break;
;;;698    		case FAN_SPEED_HIG:
;;;699    			RelaySwitch(RELAY_HIGH ,RELAY_OFF);
000016  2101              MOVS     r1,#1
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       RelaySwitch
;;;700    			VoltageOutput(VOLATAGE_8);
00001e  2002              MOVS     r0,#2
                  |L7.32|
000020  e8bd4010          POP      {r4,lr}
000024  f7ffbffe          B.W      VoltageOutput
                  |L7.40|
000028  2101              MOVS     r1,#1                 ;691
00002a  2002              MOVS     r0,#2                 ;691
00002c  f7fffffe          BL       RelaySwitch
000030  2000              MOVS     r0,#0                 ;692
000032  e7f5              B        |L7.32|
                  |L7.52|
000034  2101              MOVS     r1,#1                 ;695
000036  4608              MOV      r0,r1                 ;695
000038  f7fffffe          BL       RelaySwitch
00003c  2001              MOVS     r0,#1                 ;696
00003e  e7ef              B        |L7.32|
                  |L7.64|
;;;701    			break;
;;;702    		case FAN_SPEED_OFF:
;;;703    		default:
;;;704    			break;
;;;705    	}
;;;706    }
000040  bd10              POP      {r4,pc}
;;;707    /**
                          ENDP


                          AREA ||i.Init_Insbuf||, CODE, READONLY, ALIGN=1

                  Init_Insbuf PROC
;;;740      */
;;;741    void Init_Insbuf(INS_STRUCT *ins)
000000  f100010c          ADD      r1,r0,#0xc
;;;742    {
;;;743    	ins->insp_current = ins->ins_Buf;
;;;744    	ins->insp_end = ins->ins_Buf;
000004  6041              STR      r1,[r0,#4]
;;;745    	ins->ins_length = 0;
000006  6081              STR      r1,[r0,#8]
000008  2100              MOVS     r1,#0
00000a  6001              STR      r1,[r0,#0]
;;;746    }
00000c  4770              BX       lr
;;;747    /* USER CODE END 4 */
                          ENDP


                          AREA ||i.Init_dev_reg||, CODE, READONLY, ALIGN=2

                  Init_dev_reg PROC
;;;715      */
;;;716    void Init_dev_reg(void)
000000  4807              LDR      r0,|L9.32|
;;;717    {
;;;718    	dev_reg.CDM_LOW 		= 0;
000002  2100              MOVS     r1,#0
000004  7101              STRB     r1,[r0,#4]
;;;719    	dev_reg.CMD_MIN 		= 0;
000006  7141              STRB     r1,[r0,#5]
;;;720    	dev_reg.CMD_HIGH 		= 0;
000008  7181              STRB     r1,[r0,#6]
;;;721    	dev_reg.CMD_VALVE 	= 0;
00000a  71c1              STRB     r1,[r0,#7]
;;;722    	dev_reg.STATE_LOW 	= 0;
00000c  7001              STRB     r1,[r0,#0]
;;;723    	dev_reg.STATE_MID 	= 0;
00000e  7041              STRB     r1,[r0,#1]
;;;724    	dev_reg.STATE_HIGH 	= 0;
000010  7081              STRB     r1,[r0,#2]
;;;725    	dev_reg.STATE_VALVE = 0;
000012  70c1              STRB     r1,[r0,#3]
;;;726    	dev_reg.LEN_LOW 		= 1;
000014  2101              MOVS     r1,#1
000016  7201              STRB     r1,[r0,#8]
;;;727    	dev_reg.LEN_MIN 		= 1;
000018  7241              STRB     r1,[r0,#9]
;;;728    	dev_reg.LEN_HIGH 		= 1;
00001a  7281              STRB     r1,[r0,#0xa]
;;;729    	dev_reg.LEN_VALVE 	= 1;
00001c  72c1              STRB     r1,[r0,#0xb]
;;;730    	
;;;731    }
00001e  4770              BX       lr
;;;732    /**
                          ENDP

                  |L9.32|
                          DCD      ||.bss||+0x400

                          AREA ||i.Protocol_Resolution||, CODE, READONLY, ALIGN=2

                  Protocol_Resolution PROC
;;;339      */
;;;340    void Protocol_Resolution(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;341    {
;;;342    	if(ins_struct.ins_length >= 8)   //指令队列中存在未处理的指令
000004  4843              LDR      r0,|L10.276|
000006  6802              LDR      r2,[r0,#0]  ; ins_struct
000008  2a08              CMP      r2,#8
00000a  d377              BCC      |L10.252|
;;;343    	{
;;;344    		//1、寻找SOH
;;;345    		if(CDMP_SOH == *ins_struct.insp_current )//非SOH || 地址错误
00000c  6841              LDR      r1,[r0,#4]  ; ins_struct
00000e  780b              LDRB     r3,[r1,#0]
000010  2b7e              CMP      r3,#0x7e
000012  d10b              BNE      |L10.44|
;;;346    		{
;;;347    			uint32_t Frame_Length;
;;;348    			uint32_t L_end;
;;;349    			L_end = &ins_struct.ins_Buf[INS_MAX - 1] - ins_struct.insp_current + 1;
000014  1a45              SUBS     r5,r0,r1
000016  352a              ADDS     r5,r5,#0x2a
;;;350    			if(L_end > 2)
000018  2d02              CMP      r5,#2
00001a  d901              BLS      |L10.32|
;;;351    			{
;;;352    				Frame_Length = ins_struct.insp_current[2];
00001c  788c              LDRB     r4,[r1,#2]
00001e  e003              B        |L10.40|
                  |L10.32|
;;;353    			}
;;;354    			else
;;;355    			{
;;;356    				Frame_Length = ins_struct.ins_Buf[2 - L_end];
000020  f1c50302          RSB      r3,r5,#2
000024  4418              ADD      r0,r0,r3
000026  7b04              LDRB     r4,[r0,#0xc]
                  |L10.40|
;;;357    			}
;;;358    			if(Frame_Length > ins_struct.ins_length)
000028  42a2              CMP      r2,r4
00002a  d201              BCS      |L10.48|
                  |L10.44|
;;;359    			{
;;;360    				right_shift_current(1);
00002c  2001              MOVS     r0,#1
00002e  e06a              B        |L10.262|
                  |L10.48|
;;;361    			}
;;;362    			else    //将数据移动出来做进一步的检查
;;;363    			{
;;;364    				uint16_t crc16;
;;;365    			
;;;366    				if(Frame_Length <= L_end)
;;;367    				{
;;;368    					memcpy(P_frame,ins_struct.insp_current,Frame_Length);
000030  4e39              LDR      r6,|L10.280|
000032  42ac              CMP      r4,r5                 ;366
000034  d802              BHI      |L10.60|
000036  4622              MOV      r2,r4
000038  4630              MOV      r0,r6
00003a  e007              B        |L10.76|
                  |L10.60|
;;;369    				}
;;;370    				else
;;;371    				{
;;;372    					memcpy(P_frame,ins_struct.insp_current,L_end);
00003c  462a              MOV      r2,r5
00003e  4836              LDR      r0,|L10.280|
000040  f7fffffe          BL       __aeabi_memcpy
;;;373    					memcpy(P_frame + L_end,ins_struct.ins_Buf,Frame_Length - L_end);
000044  4933              LDR      r1,|L10.276|
000046  1b62              SUBS     r2,r4,r5
000048  1970              ADDS     r0,r6,r5
00004a  310c              ADDS     r1,r1,#0xc
                  |L10.76|
00004c  f7fffffe          BL       __aeabi_memcpy
;;;374    				}
;;;375    				crc16 = CRC16_MODBUS(P_frame,Frame_Length - 2);
000050  1ea1              SUBS     r1,r4,#2
000052  4831              LDR      r0,|L10.280|
000054  f7fffffe          BL       CRC16_MODBUS
;;;376    				if((P_frame[3] == Device_ID) && (crc16 == ((P_frame[Frame_Length - 2] << 8)|(P_frame[Frame_Length - 1]))))
000058  4b30              LDR      r3,|L10.284|
00005a  78f2              LDRB     r2,[r6,#3]  ; P_frame
00005c  4601              MOV      r1,r0                 ;375
00005e  781b              LDRB     r3,[r3,#0]  ; Device_ID
000060  4630              MOV      r0,r6
000062  429a              CMP      r2,r3
000064  d1e2              BNE      |L10.44|
000066  1905              ADDS     r5,r0,r4
000068  f8352c02          LDRH     r2,[r5,#-2]
00006c  ba52              REV16    r2,r2
00006e  428a              CMP      r2,r1
000070  d1dc              BNE      |L10.44|
;;;377    				{
;;;378    					switch((CMD_TYPE)P_frame[5])
000072  7941              LDRB     r1,[r0,#5]  ; P_frame
000074  3981              SUBS     r1,r1,#0x81
000076  2906              CMP      r1,#6
000078  d241              BCS      |L10.254|
00007a  e8dff001          TBB      [pc,r1]
00007e  0314              DCB      0x03,0x14
000080  1a434330          DCB      0x1a,0x43,0x43,0x30
;;;379    					{
;;;380    						case 	READ_SINGLE:
;;;381    							P_frame[2] = Frame_Length + 1;
000084  1c66              ADDS     r6,r4,#1
000086  4605              MOV      r5,r0
000088  7086              STRB     r6,[r0,#2]
;;;382    							P_frame[7] = EXE_READ_SINGLE(&P_frame[6],Frame_Length - 8);
00008a  f1a40108          SUB      r1,r4,#8
00008e  1d80              ADDS     r0,r0,#6
000090  f7fffffe          BL       EXE_READ_SINGLE
000094  71e8              STRB     r0,[r5,#7]
;;;383    							crc16 = CRC16_MODBUS(P_frame,Frame_Length - 2 + 1);
000096  1e61              SUBS     r1,r4,#1
000098  481f              LDR      r0,|L10.280|
00009a  f7fffffe          BL       CRC16_MODBUS
;;;384    							P_frame[9] = (uint8_t)crc16;
00009e  7268              STRB     r0,[r5,#9]
;;;385    							P_frame[8] = (uint8_t)(crc16 >> 8);
0000a0  0a00              LSRS     r0,r0,#8
0000a2  7228              STRB     r0,[r5,#8]
;;;386    							SendDataUSART1_DMA(P_frame, Frame_Length + 1);
;;;387    							break;
0000a4  e028              B        |L10.248|
;;;388    						case READ_MUL:
;;;389    							EXE_READ_MUL(&P_frame[6],Frame_Length - 8);
0000a6  f1a40108          SUB      r1,r4,#8
0000aa  1db0              ADDS     r0,r6,#6
0000ac  f7fffffe          BL       EXE_READ_MUL
;;;390    							break;
0000b0  e028              B        |L10.260|
;;;391    						case WRITE_SINGLE:
;;;392    							EXE_WRITE_SINGLE(&P_frame[6],Frame_Length - 8);
0000b2  f1a40108          SUB      r1,r4,#8
0000b6  4637              MOV      r7,r6
0000b8  1db0              ADDS     r0,r6,#6
0000ba  f7fffffe          BL       EXE_WRITE_SINGLE
;;;393    							P_frame[2] = Frame_Length - 1;
0000be  1e66              SUBS     r6,r4,#1
0000c0  70be              STRB     r6,[r7,#2]
;;;394    							crc16 = CRC16_MODBUS(P_frame,Frame_Length - 2 - 1);
0000c2  1ee1              SUBS     r1,r4,#3
0000c4  4814              LDR      r0,|L10.280|
0000c6  f7fffffe          BL       CRC16_MODBUS
;;;395    							P_frame[Frame_Length - 2] = (uint8_t)crc16;
0000ca  f8050c02          STRB     r0,[r5,#-2]
;;;396    							P_frame[Frame_Length - 2 - 1] = (uint8_t)(crc16 >> 8);
0000ce  0a00              LSRS     r0,r0,#8
0000d0  f8050c03          STRB     r0,[r5,#-3]
;;;397    							SendDataUSART1_DMA(P_frame, Frame_Length - 1);
0000d4  b2b1              UXTH     r1,r6
                  |L10.214|
0000d6  4810              LDR      r0,|L10.280|
0000d8  f7fffffe          BL       SendDataUSART1_DMA
0000dc  e012              B        |L10.260|
;;;398    							break;
;;;399    						case 	WRITE_MUL:
;;;400    							EXE_WRITE_MUL(&P_frame[6],Frame_Length - 8);
;;;401    							break;
;;;402    						case UPDATE_DATE:
;;;403    							EXE_UPDATE_DATE(&P_frame[6],Frame_Length - 8);
;;;404    							break;
;;;405    						case INVENTORY://盘点设备
;;;406    							P_frame[2] = Frame_Length + 1;
0000de  1c66              ADDS     r6,r4,#1
0000e0  4607              MOV      r7,r0
0000e2  7086              STRB     r6,[r0,#2]
;;;407    							P_frame[6] = (uint8_t)DEVICE_TYPE;
0000e4  2001              MOVS     r0,#1
0000e6  71b8              STRB     r0,[r7,#6]
;;;408    							crc16 = CRC16_MODBUS(P_frame,Frame_Length - 2 + 1);
0000e8  1e61              SUBS     r1,r4,#1
0000ea  480b              LDR      r0,|L10.280|
0000ec  f7fffffe          BL       CRC16_MODBUS
;;;409    							P_frame[Frame_Length - 1 + 1] = (uint8_t)crc16;
0000f0  5538              STRB     r0,[r7,r4]
;;;410    							P_frame[Frame_Length - 2 + 1] = (uint8_t)(crc16 >> 8);
0000f2  0a00              LSRS     r0,r0,#8
0000f4  f8050c01          STRB     r0,[r5,#-1]
                  |L10.248|
0000f8  4631              MOV      r1,r6
0000fa  e7ec              B        |L10.214|
                  |L10.252|
0000fc  e007              B        |L10.270|
                  |L10.254|
;;;411    							SendDataUSART1_DMA(P_frame, Frame_Length + 1);
;;;412    							break;
;;;413    						default:
;;;414    							_dbg_printf("invalid cmd\n");
0000fe  a008              ADR      r0,|L10.288|
000100  f7fffffe          BL       _dbg_printf
                  |L10.260|
;;;415    							break;
;;;416    					}
;;;417    					right_shift_current(Frame_Length);
000104  4620              MOV      r0,r4
                  |L10.262|
;;;418    				}
;;;419    				else
;;;420    				{
;;;421    					right_shift_current(1);
;;;422    				}
;;;423    			}
;;;424    		}
;;;425    		else //向后移动
;;;426    		{
;;;427    			right_shift_current(1);
000106  e8bd41f0          POP      {r4-r8,lr}
00010a  f7ffbffe          B.W      right_shift_current
                  |L10.270|
;;;428    		}	
;;;429    	}
;;;430    }
00010e  e8bd81f0          POP      {r4-r8,pc}
;;;431    /**
                          ENDP

000112  0000              DCW      0x0000
                  |L10.276|
                          DCD      ins_struct
                  |L10.280|
                          DCD      ||.bss||
                  |L10.284|
                          DCD      ||.data||
                  |L10.288|
000120  696e7661          DCB      "invalid cmd\n",0
000124  6c696420
000128  636d640a
00012c  00      
00012d  00                DCB      0
00012e  00                DCB      0
00012f  00                DCB      0

                          AREA ||i.RelaySwitch||, CODE, READONLY, ALIGN=2

                  RelaySwitch PROC
;;;580      */
;;;581    void RelaySwitch(Relay_num r_num,Relay_state r_state)
000000  4602              MOV      r2,r0
;;;582    {
;;;583    	//assert_param(IS_RELAY_NUM(r_num));
;;;584    	//assert_param(IS_RELAY_STATE(r_state));
;;;585    	switch(r_num)
;;;586    	{
;;;587    		case RELAY_HIGH:
;;;588    			if(r_state == RELAY_OFF)
;;;589    			{
;;;590    				HAL_GPIO_WritePin(R_HIGH_GPIO_Port,R_HIGH_Pin,GPIO_PIN_SET);
000002  4816              LDR      r0,|L11.92|
000004  2a05              CMP      r2,#5                 ;585
000006  d228              BCS      |L11.90|
000008  e8dff002          TBB      [pc,r2]               ;585
00000c  030a1118          DCB      0x03,0x0a,0x11,0x18
000010  1f00              DCB      0x1f,0x00
000012  2901              CMP      r1,#1                 ;588
000014  d002              BEQ      |L11.28|
;;;591    			}
;;;592    				
;;;593    			else
;;;594    			{
;;;595    				HAL_GPIO_WritePin(R_HIGH_GPIO_Port,R_HIGH_Pin,GPIO_PIN_RESET);
000016  2200              MOVS     r2,#0
                  |L11.24|
000018  2110              MOVS     r1,#0x10              ;590
00001a  e01a              B        |L11.82|
                  |L11.28|
00001c  2201              MOVS     r2,#1                 ;590
00001e  e7fb              B        |L11.24|
;;;596    			}
;;;597    			break;
;;;598    		case RELAY_MID:
;;;599    			if(r_state == RELAY_OFF)
000020  2901              CMP      r1,#1
000022  d002              BEQ      |L11.42|
;;;600    			{
;;;601    				HAL_GPIO_WritePin(R_MID_GPIO_Port,R_MID_Pin,GPIO_PIN_SET);
;;;602    			}
;;;603    			else
;;;604    			{
;;;605    				HAL_GPIO_WritePin(R_MID_GPIO_Port,R_MID_Pin,GPIO_PIN_RESET);
000024  2200              MOVS     r2,#0
                  |L11.38|
000026  2120              MOVS     r1,#0x20              ;601
000028  e013              B        |L11.82|
                  |L11.42|
00002a  2201              MOVS     r2,#1                 ;601
00002c  e7fb              B        |L11.38|
;;;606    			}
;;;607    			break;
;;;608    		case RELAY_LOW:
;;;609    			if(r_state == RELAY_OFF)
00002e  2901              CMP      r1,#1
000030  d002              BEQ      |L11.56|
;;;610    			{
;;;611    				HAL_GPIO_WritePin(R_LOW_GPIO_Port,R_LOW_Pin,GPIO_PIN_SET);
;;;612    			}
;;;613    			else
;;;614    			{
;;;615    				HAL_GPIO_WritePin(R_LOW_GPIO_Port,R_LOW_Pin,GPIO_PIN_RESET);
000032  2200              MOVS     r2,#0
                  |L11.52|
000034  2140              MOVS     r1,#0x40              ;611
000036  e00c              B        |L11.82|
                  |L11.56|
000038  2201              MOVS     r2,#1                 ;611
00003a  e7fb              B        |L11.52|
;;;616    			}
;;;617    			break;
;;;618    		case RELAY_VALVE:
;;;619    			if(r_state == RELAY_OFF)
00003c  2901              CMP      r1,#1
00003e  d002              BEQ      |L11.70|
;;;620    			{
;;;621    				HAL_GPIO_WritePin(R_VALVE_GPIO_Port,R_VALVE_Pin,GPIO_PIN_SET);
;;;622    			}
;;;623    			else
;;;624    			{
;;;625    				HAL_GPIO_WritePin(R_VALVE_GPIO_Port,R_VALVE_Pin,GPIO_PIN_RESET);
000040  2200              MOVS     r2,#0
                  |L11.66|
000042  2180              MOVS     r1,#0x80              ;621
000044  e005              B        |L11.82|
                  |L11.70|
000046  2201              MOVS     r2,#1                 ;621
000048  e7fb              B        |L11.66|
;;;626    			}
;;;627    			break;
;;;628    		case RELAY_ALL:
;;;629    			if(r_state == RELAY_OFF)
00004a  2901              CMP      r1,#1
00004c  d003              BEQ      |L11.86|
;;;630    			{
;;;631    				HAL_GPIO_WritePin(GPIOA,R_HIGH_Pin | R_MID_Pin | R_LOW_Pin | R_VALVE_Pin,GPIO_PIN_SET);
;;;632    			}
;;;633    			else
;;;634    			{
;;;635    				HAL_GPIO_WritePin(GPIOA,R_HIGH_Pin | R_MID_Pin | R_LOW_Pin | R_VALVE_Pin,GPIO_PIN_RESET);
00004e  2200              MOVS     r2,#0
                  |L11.80|
000050  21f0              MOVS     r1,#0xf0
                  |L11.82|
000052  f7ffbffe          B.W      HAL_GPIO_WritePin
                  |L11.86|
000056  2201              MOVS     r2,#1                 ;631
000058  e7fa              B        |L11.80|
                  |L11.90|
;;;636    			}
;;;637    			break;
;;;638    		default:
;;;639    			break;
;;;640    	}
;;;641    }
00005a  4770              BX       lr
;;;642    /**
                          ENDP

                  |L11.92|
                          DCD      0x40010800

                          AREA ||i.SystemClock_Config||, CODE, READONLY, ALIGN=1

                  SystemClock_Config PROC
;;;260      */
;;;261    void SystemClock_Config(void)
000000  b530              PUSH     {r4,r5,lr}
;;;262    {
000002  b08f              SUB      sp,sp,#0x3c
;;;263    
;;;264      RCC_OscInitTypeDef RCC_OscInitStruct;
;;;265      RCC_ClkInitTypeDef RCC_ClkInitStruct;
;;;266    
;;;267        /**Initializes the CPU, AHB and APB busses clocks 
;;;268        */
;;;269      RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_LSI;
000004  200a              MOVS     r0,#0xa
;;;270      RCC_OscInitStruct.HSIState = RCC_HSI_ON;
000006  9000              STR      r0,[sp,#0]
000008  2001              MOVS     r0,#1
;;;271      RCC_OscInitStruct.HSICalibrationValue = 16;
;;;272      RCC_OscInitStruct.LSIState = RCC_LSI_ON;
;;;273      RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
00000a  2502              MOVS     r5,#2
;;;274      RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI_DIV2;
00000c  e9cd0506          STRD     r0,r5,[sp,#0x18]
000010  2110              MOVS     r1,#0x10              ;271
000012  e9cd0104          STRD     r0,r1,[sp,#0x10]      ;271
000016  2400              MOVS     r4,#0
;;;275      RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL16;
000018  f44f1060          MOV      r0,#0x380000
00001c  e9cd4008          STRD     r4,r0,[sp,#0x20]
;;;276      if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       HAL_RCC_OscConfig
000026  b100              CBZ      r0,|L12.42|
                  |L12.40|
000028  e7fe              B        |L12.40|
                  |L12.42|
;;;277      {
;;;278        _Error_Handler(__FILE__, __LINE__);
;;;279      }
;;;280    
;;;281        /**Initializes the CPU, AHB and APB busses clocks 
;;;282        */
;;;283      RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
00002a  200f              MOVS     r0,#0xf
00002c  e9cd050a          STRD     r0,r5,[sp,#0x28]
;;;284                                  |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
;;;285      RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
;;;286      RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
;;;287      RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
000030  f44f6080          MOV      r0,#0x400
000034  e9cd400c          STRD     r4,r0,[sp,#0x30]
;;;288      RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
;;;289    
;;;290      if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
000038  2102              MOVS     r1,#2
00003a  a80a              ADD      r0,sp,#0x28
00003c  940e              STR      r4,[sp,#0x38]
00003e  f7fffffe          BL       HAL_RCC_ClockConfig
000042  b100              CBZ      r0,|L12.70|
                  |L12.68|
000044  e7fe              B        |L12.68|
                  |L12.70|
;;;291      {
;;;292        _Error_Handler(__FILE__, __LINE__);
;;;293      }
;;;294    
;;;295        /**Configure the Systick interrupt time 
;;;296        */
;;;297      HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
000046  f7fffffe          BL       HAL_RCC_GetHCLKFreq
00004a  f44f717a          MOV      r1,#0x3e8
00004e  fbb0f0f1          UDIV     r0,r0,r1
000052  f7fffffe          BL       HAL_SYSTICK_Config
;;;298    
;;;299        /**Configure the Systick 
;;;300        */
;;;301      HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
000056  2004              MOVS     r0,#4
000058  f7fffffe          BL       HAL_SYSTICK_CLKSourceConfig
;;;302    
;;;303      /* SysTick_IRQn interrupt configuration */
;;;304      HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
00005c  2200              MOVS     r2,#0
00005e  4611              MOV      r1,r2
000060  1e50              SUBS     r0,r2,#1
000062  f7fffffe          BL       HAL_NVIC_SetPriority
;;;305    }
000066  b00f              ADD      sp,sp,#0x3c
000068  bd30              POP      {r4,r5,pc}
;;;306    
                          ENDP


                          AREA ||i.VoltageOutput||, CODE, READONLY, ALIGN=2

                  VoltageOutput PROC
;;;654      */
;;;655    void VoltageOutput(VOLATAGE_OUT v_out)
000000  4909              LDR      r1,|L13.40|
;;;656    {
;;;657    	switch(v_out)
;;;658    	{
;;;659    		case VOLATAGE_3:
;;;660    			htim2.Instance->CCR1 = 306;
000002  6809              LDR      r1,[r1,#0]
000004  b128              CBZ      r0,|L13.18|
000006  2801              CMP      r0,#1                 ;657
000008  d006              BEQ      |L13.24|
00000a  2802              CMP      r0,#2                 ;657
00000c  d007              BEQ      |L13.30|
;;;661    			break;
;;;662    		case VOLATAGE_5:
;;;663    			htim2.Instance->CCR1 = 510;
;;;664    			break;
;;;665    		case VOLATAGE_8:
;;;666    			htim2.Instance->CCR1 = 817;
;;;667    			break;
;;;668    		default:
;;;669    			htim2.Instance->CCR1 = 0;
00000e  2000              MOVS     r0,#0
;;;670    			break;
000010  e007              B        |L13.34|
                  |L13.18|
000012  f44f7099          MOV      r0,#0x132             ;660
000016  e004              B        |L13.34|
                  |L13.24|
000018  f44f70ff          MOV      r0,#0x1fe             ;663
00001c  e001              B        |L13.34|
                  |L13.30|
00001e  f2403031          MOV      r0,#0x331             ;666
                  |L13.34|
000022  6348              STR      r0,[r1,#0x34]         ;669
;;;671    	}
;;;672    }
000024  4770              BX       lr
;;;673    /**
                          ENDP

000026  0000              DCW      0x0000
                  |L13.40|
                          DCD      htim2

                          AREA ||i._Error_Handler||, CODE, READONLY, ALIGN=1

                  _Error_Handler PROC
                  |L14.0|
;;;754      */
;;;755    void _Error_Handler(char *file, int line)
000000  e7fe              B        |L14.0|
;;;756    {
;;;757      /* USER CODE BEGIN Error_Handler_Debug */
;;;758      /* User can add his own implementation to report the HAL error return state */
;;;759      while(1)
;;;760      {
;;;761      }
;;;762      /* USER CODE END Error_Handler_Debug */
;;;763    }
;;;764    
                          ENDP


                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;179      */
;;;180    int main(void)
000000  f7fffffe          BL       HAL_Init
;;;181    {
;;;182      /* USER CODE BEGIN 1 */
;;;183    
;;;184    
;;;185      /* USER CODE END 1 */
;;;186    
;;;187      /* MCU Configuration----------------------------------------------------------*/
;;;188    
;;;189      /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
;;;190      HAL_Init();
;;;191    
;;;192      /* USER CODE BEGIN Init */
;;;193    
;;;194      /* USER CODE END Init */
;;;195    
;;;196      /* Configure the system clock */
;;;197      SystemClock_Config();
000004  f7fffffe          BL       SystemClock_Config
;;;198    
;;;199      /* USER CODE BEGIN SysInit */
;;;200    
;;;201      /* USER CODE END SysInit */
;;;202    
;;;203      /* Initialize all configured peripherals */
;;;204      MX_GPIO_Init();
000008  f7fffffe          BL       MX_GPIO_Init
;;;205      MX_DMA_Init();
00000c  f7fffffe          BL       MX_DMA_Init
;;;206      MX_IWDG_Init();
000010  f7fffffe          BL       MX_IWDG_Init
;;;207      MX_TIM1_Init();
000014  f7fffffe          BL       MX_TIM1_Init
;;;208      MX_USART1_UART_Init();
000018  f7fffffe          BL       MX_USART1_UART_Init
;;;209      MX_TIM2_Init();
00001c  f7fffffe          BL       MX_TIM2_Init
;;;210      MX_USART3_UART_Init();
000020  f7fffffe          BL       MX_USART3_UART_Init
;;;211      /* USER CODE BEGIN 2 */
;;;212    	//DMA 接收地址设置
;;;213    	HAL_UART_Receive_DMA(&huart1,UsartType1.usartDMA_rxBuf,0x400);
000024  4c1f              LDR      r4,|L15.164|
000026  f44f6580          MOV      r5,#0x400
00002a  462a              MOV      r2,r5
00002c  1d21              ADDS     r1,r4,#4
00002e  481e              LDR      r0,|L15.168|
000030  f7fffffe          BL       HAL_UART_Receive_DMA
;;;214    	HAL_UART_Receive_DMA(&huart3,UsartType3.usartDMA_rxBuf,0x400);
000034  462a              MOV      r2,r5
000036  4d1d              LDR      r5,|L15.172|
000038  481d              LDR      r0,|L15.176|
00003a  1d29              ADDS     r1,r5,#4
00003c  f7fffffe          BL       HAL_UART_Receive_DMA
;;;215    	__HAL_UART_ENABLE_IT(&huart1,UART_IT_IDLE);   //开启空闲中断
000040  4819              LDR      r0,|L15.168|
000042  6800              LDR      r0,[r0,#0]  ; huart1
000044  68c1              LDR      r1,[r0,#0xc]
000046  f0410110          ORR      r1,r1,#0x10
00004a  60c1              STR      r1,[r0,#0xc]
;;;216    	__HAL_UART_ENABLE_IT(&huart3,UART_IT_IDLE);   //开启空闲中断
00004c  4818              LDR      r0,|L15.176|
00004e  6800              LDR      r0,[r0,#0]  ; huart3
000050  68c1              LDR      r1,[r0,#0xc]
000052  f0410110          ORR      r1,r1,#0x10
000056  60c1              STR      r1,[r0,#0xc]
;;;217    	HAL_TIM_Base_Start_IT(&htim1);
000058  4816              LDR      r0,|L15.180|
00005a  f7fffffe          BL       HAL_TIM_Base_Start_IT
;;;218    	HAL_TIM_PWM_Start(&htim2,TIM_CHANNEL_1);
00005e  2100              MOVS     r1,#0
000060  4815              LDR      r0,|L15.184|
000062  f7fffffe          BL       HAL_TIM_PWM_Start
;;;219    	HAL_GPIO_WritePin(UART_DIR_GPIO_Port,UART_DIR_Pin,GPIO_PIN_RESET);  //上电的时候设置接收状态
000066  2200              MOVS     r2,#0
000068  f44f7180          MOV      r1,#0x100
00006c  4813              LDR      r0,|L15.188|
00006e  f7fffffe          BL       HAL_GPIO_WritePin
;;;220    	HAL_GPIO_WritePin(USART3_DIR_GPIO_Port,USART3_DIR_Pin,GPIO_PIN_RESET);  //上电的时候设置接收状态
000072  2200              MOVS     r2,#0
000074  2104              MOVS     r1,#4
000076  4812              LDR      r0,|L15.192|
000078  f7fffffe          BL       HAL_GPIO_WritePin
;;;221    	UsartType1.dmaSend_flag = USART_DMA_SENDOVER;
00007c  7820              LDRB     r0,[r4,#0]  ; UsartType1
00007e  f0200002          BIC      r0,r0,#2
000082  7020              STRB     r0,[r4,#0]
;;;222    	UsartType3.dmaSend_flag = USART_DMA_SENDOVER;
000084  7828              LDRB     r0,[r5,#0]  ; UsartType3
000086  f0200002          BIC      r0,r0,#2
00008a  7028              STRB     r0,[r5,#0]
;;;223    	//1、查看设备地址
;;;224    	CheckDevideID(&Device_ID);    //每次上电的时候查询地址 
00008c  480d              LDR      r0,|L15.196|
00008e  f7fffffe          BL       CheckDevideID
;;;225    	//2、初始化指令缓存
;;;226    	Init_Insbuf(&ins_struct);
000092  480d              LDR      r0,|L15.200|
000094  f7fffffe          BL       Init_Insbuf
;;;227    	Init_dev_reg();
000098  f7fffffe          BL       Init_dev_reg
                  |L15.156|
;;;228    
;;;229      /* USER CODE END 2 */
;;;230    
;;;231      /* Infinite loop */
;;;232      /* USER CODE BEGIN WHILE */
;;;233      while (1)
;;;234      {
;;;235    
;;;236      /* USER CODE END WHILE */
;;;237    
;;;238      /* USER CODE BEGIN 3 */
;;;239    	/*1< 处理指令buf中未处理的指令，解析完一帧指令后设置处理指令flag*/
;;;240    		
;;;241    	/*2< 处理准备好的指令*/
;;;242    //		if(UsartType1.receive_flag == 1)   //产生了空闲中断
;;;243    //		{
;;;244    //			UsartType1.receive_flag = 0; //清除标记
;;;245    //			if(UsartType1.rx_len != 0)
;;;246    //			{
;;;247    //				//SendDataUSART1_DMA(UsartType1.usartDMA_rxBuf,UsartType1.rx_len);//串口打印收到的数据
;;;248    //				_dbg_printf("%s",UsartType1.usartDMA_rxBuf);
;;;249    //			}	
;;;250    //		}
;;;251    		Protocol_Resolution();
00009c  f7fffffe          BL       Protocol_Resolution
0000a0  e7fc              B        |L15.156|
;;;252      }
;;;253      /* USER CODE END 3 */
;;;254    
;;;255    }
;;;256    
                          ENDP

0000a2  0000              DCW      0x0000
                  |L15.164|
                          DCD      UsartType1
                  |L15.168|
                          DCD      huart1
                  |L15.172|
                          DCD      UsartType3
                  |L15.176|
                          DCD      huart3
                  |L15.180|
                          DCD      htim1
                  |L15.184|
                          DCD      htim2
                  |L15.188|
                          DCD      0x40010800
                  |L15.192|
                          DCD      0x40010c00
                  |L15.196|
                          DCD      ||.data||
                  |L15.200|
                          DCD      ins_struct

                          AREA ||i.right_shift_current||, CODE, READONLY, ALIGN=2

                  right_shift_current PROC
;;;315      */
;;;316    void right_shift_current(uint32_t step)
000000  4907              LDR      r1,|L16.32|
;;;317    {
;;;318    	uint32_t L_end;
;;;319    	L_end = &ins_struct.ins_Buf[INS_MAX - 1] - ins_struct.insp_current;
000002  684b              LDR      r3,[r1,#4]  ; ins_struct
000004  1aca              SUBS     r2,r1,r3
000006  3229              ADDS     r2,r2,#0x29
;;;320    	if(L_end >= step)
000008  4282              CMP      r2,r0
00000a  d301              BCC      |L16.16|
;;;321    	{
;;;322    		ins_struct.insp_current += step;
00000c  181a              ADDS     r2,r3,r0
00000e  e002              B        |L16.22|
                  |L16.16|
;;;323    	}
;;;324    	else
;;;325    	{
;;;326    		uint32_t L_start;
;;;327    		L_start = step - L_end;
000010  1a82              SUBS     r2,r0,r2
;;;328    		ins_struct.insp_current = &ins_struct.ins_Buf[L_start - 1];
000012  440a              ADD      r2,r2,r1
000014  320b              ADDS     r2,r2,#0xb
                  |L16.22|
;;;329    	}
;;;330    	ins_struct.ins_length -= step;
000016  604a              STR      r2,[r1,#4]  ; ins_struct
000018  680a              LDR      r2,[r1,#0]  ; ins_struct
00001a  1a10              SUBS     r0,r2,r0
00001c  6008              STR      r0,[r1,#0]  ; ins_struct
;;;331    }
00001e  4770              BX       lr
;;;332    /**
                          ENDP

                  |L16.32|
                          DCD      ins_struct

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  P_frame
                          %        1024
                  dev_reg
                          %        12

                          AREA ||.data||, DATA, ALIGN=0

                  Device_ID
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "../Src/main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_P_frame____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___6_main_c_P_frame____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_P_frame____REVSH|
#line 402
|__asm___6_main_c_P_frame____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_P_frame____RRX|
#line 587
|__asm___6_main_c_P_frame____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
