; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\stm32f1xx_hal_tim_ex.o --asm_dir=.\air_slave\ --list_dir=.\air_slave\ --depend=.\stm32f1xx_hal_tim_ex.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I.\RTE\_air_slave -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=525 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=.\stm32f1xx_hal_tim_ex.crf ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_tim_ex.c]
                          THUMB

                          AREA ||i.HAL_TIMEx_BreakCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_BreakCallback PROC
;;;1655     */
;;;1656   __weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1657   {
;;;1658     /* Prevent unused argument(s) compilation warning */
;;;1659     UNUSED(htim);
;;;1660     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1661               the HAL_TIMEx_BreakCallback could be implemented in the user file
;;;1662      */
;;;1663   }
;;;1664   
                          ENDP


                          AREA ||i.HAL_TIMEx_CommutationCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_CommutationCallback PROC
;;;1641     */
;;;1642   __weak void HAL_TIMEx_CommutationCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1643   {
;;;1644     /* Prevent unused argument(s) compilation warning */
;;;1645     UNUSED(htim);
;;;1646     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1647               the HAL_TIMEx_CommutationCallback could be implemented in the user file
;;;1648      */
;;;1649   }
;;;1650   
                          ENDP


                          AREA ||i.HAL_TIMEx_ConfigBreakDeadTime||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_ConfigBreakDeadTime PROC
;;;1537     */
;;;1538   HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim,
000000  b510              PUSH     {r4,lr}
;;;1539                                                   TIM_BreakDeadTimeConfigTypeDef *sBreakDeadTimeConfig)
;;;1540   {
;;;1541     uint32_t tmpbdtr = 0U;
;;;1542   
;;;1543     /* Check the parameters */
;;;1544     assert_param(IS_TIM_BREAK_INSTANCE(htim->Instance));
;;;1545     assert_param(IS_TIM_OSSR_STATE(sBreakDeadTimeConfig->OffStateRunMode));
;;;1546     assert_param(IS_TIM_OSSI_STATE(sBreakDeadTimeConfig->OffStateIDLEMode));
;;;1547     assert_param(IS_TIM_LOCK_LEVEL(sBreakDeadTimeConfig->LockLevel));
;;;1548     assert_param(IS_TIM_DEADTIME(sBreakDeadTimeConfig->DeadTime));
;;;1549     assert_param(IS_TIM_BREAK_STATE(sBreakDeadTimeConfig->BreakState));
;;;1550     assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
;;;1551     assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));
;;;1552   
;;;1553     /* Process Locked */
;;;1554     __HAL_LOCK(htim);
000002  f890203c          LDRB     r2,[r0,#0x3c]
000006  2a01              CMP      r2,#1
000008  d025              BEQ      |L3.86|
00000a  2201              MOVS     r2,#1
00000c  f880203c          STRB     r2,[r0,#0x3c]
;;;1555   
;;;1556     /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
;;;1557        the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;1558   
;;;1559     /* Set the BDTR bits */
;;;1560     MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);
;;;1561     MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
000010  68ca              LDR      r2,[r1,#0xc]
000012  688c              LDR      r4,[r1,#8]
000014  f4227240          BIC      r2,r2,#0x300
000018  4322              ORRS     r2,r2,r4
;;;1562     MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
00001a  684c              LDR      r4,[r1,#4]
00001c  f4226280          BIC      r2,r2,#0x400
000020  4322              ORRS     r2,r2,r4
;;;1563     MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
000022  680c              LDR      r4,[r1,#0]
000024  f4226200          BIC      r2,r2,#0x800
000028  4322              ORRS     r2,r2,r4
;;;1564     MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
00002a  690c              LDR      r4,[r1,#0x10]
00002c  f4225280          BIC      r2,r2,#0x1000
000030  4322              ORRS     r2,r2,r4
;;;1565     MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
000032  694c              LDR      r4,[r1,#0x14]
000034  f4225200          BIC      r2,r2,#0x2000
000038  4322              ORRS     r2,r2,r4
;;;1566     MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
00003a  698c              LDR      r4,[r1,#0x18]
00003c  f4224280          BIC      r2,r2,#0x4000
000040  4322              ORRS     r2,r2,r4
;;;1567     MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, sBreakDeadTimeConfig->AutomaticOutput);
000042  f4224100          BIC      r1,r2,#0x8000
;;;1568   
;;;1569     /* Set TIMx_BDTR */
;;;1570     htim->Instance->BDTR = tmpbdtr;
000046  6802              LDR      r2,[r0,#0]
000048  2300              MOVS     r3,#0                 ;1560
00004a  4321              ORRS     r1,r1,r4              ;1567
00004c  6451              STR      r1,[r2,#0x44]
;;;1571   
;;;1572     __HAL_UNLOCK(htim);
00004e  f880303c          STRB     r3,[r0,#0x3c]
;;;1573   
;;;1574     return HAL_OK;
000052  2000              MOVS     r0,#0
;;;1575   }
000054  bd10              POP      {r4,pc}
                  |L3.86|
000056  2002              MOVS     r0,#2                 ;1554
000058  bd10              POP      {r4,pc}
;;;1576   
                          ENDP


                          AREA ||i.HAL_TIMEx_ConfigCommutationEvent||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_ConfigCommutationEvent PROC
;;;1391     */
;;;1392   HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
000000  b510              PUSH     {r4,lr}
;;;1393   {
;;;1394     /* Check the parameters */
;;;1395     assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
;;;1396     assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
;;;1397   
;;;1398     __HAL_LOCK(htim);
000002  f890303c          LDRB     r3,[r0,#0x3c]
000006  2b01              CMP      r3,#1
000008  d00a              BEQ      |L4.32|
00000a  2301              MOVS     r3,#1
00000c  f880303c          STRB     r3,[r0,#0x3c]
000010  b141              CBZ      r1,|L4.36|
;;;1399   
;;;1400     if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
000012  2910              CMP      r1,#0x10
000014  d006              BEQ      |L4.36|
;;;1401         (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
000016  2920              CMP      r1,#0x20
000018  d004              BEQ      |L4.36|
00001a  2930              CMP      r1,#0x30
00001c  d002              BEQ      |L4.36|
00001e  e00a              B        |L4.54|
                  |L4.32|
000020  2002              MOVS     r0,#2                 ;1398
;;;1402     {
;;;1403       /* Select the Input trigger */
;;;1404       htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;1405       htim->Instance->SMCR |= InputTrigger;
;;;1406     }
;;;1407   
;;;1408     /* Select the Capture Compare preload feature */
;;;1409     htim->Instance->CR2 |= TIM_CR2_CCPC;
;;;1410     /* Select the Commutation event source */
;;;1411     htim->Instance->CR2 &= ~TIM_CR2_CCUS;
;;;1412     htim->Instance->CR2 |= CommutationSource;
;;;1413   
;;;1414     __HAL_UNLOCK(htim);
;;;1415   
;;;1416     return HAL_OK;
;;;1417   }
000022  bd10              POP      {r4,pc}
                  |L4.36|
000024  6803              LDR      r3,[r0,#0]            ;1404
000026  689c              LDR      r4,[r3,#8]            ;1404
000028  f0240470          BIC      r4,r4,#0x70           ;1404
00002c  609c              STR      r4,[r3,#8]            ;1404
00002e  6803              LDR      r3,[r0,#0]            ;1405
000030  689c              LDR      r4,[r3,#8]            ;1405
000032  430c              ORRS     r4,r4,r1              ;1405
000034  609c              STR      r4,[r3,#8]            ;1405
                  |L4.54|
000036  6801              LDR      r1,[r0,#0]            ;1409
000038  684b              LDR      r3,[r1,#4]            ;1409
00003a  f0430301          ORR      r3,r3,#1              ;1409
00003e  604b              STR      r3,[r1,#4]            ;1409
000040  6801              LDR      r1,[r0,#0]            ;1411
000042  684b              LDR      r3,[r1,#4]            ;1411
000044  f0230304          BIC      r3,r3,#4              ;1411
000048  604b              STR      r3,[r1,#4]            ;1411
00004a  6801              LDR      r1,[r0,#0]            ;1412
00004c  684b              LDR      r3,[r1,#4]            ;1412
00004e  4313              ORRS     r3,r3,r2              ;1412
000050  604b              STR      r3,[r1,#4]            ;1412
000052  2100              MOVS     r1,#0                 ;1414
000054  f880103c          STRB     r1,[r0,#0x3c]         ;1414
000058  4608              MOV      r0,r1                 ;1416
00005a  bd10              POP      {r4,pc}
;;;1418   
                          ENDP


                          AREA ||i.HAL_TIMEx_ConfigCommutationEvent_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_ConfigCommutationEvent_DMA PROC
;;;1493     */
;;;1494   HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent_DMA(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
000000  b510              PUSH     {r4,lr}
;;;1495   {
;;;1496     /* Check the parameters */
;;;1497     assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
;;;1498     assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
;;;1499   
;;;1500     __HAL_LOCK(htim);
000002  f890303c          LDRB     r3,[r0,#0x3c]
000006  2b01              CMP      r3,#1
000008  d00a              BEQ      |L5.32|
00000a  2301              MOVS     r3,#1
00000c  f880303c          STRB     r3,[r0,#0x3c]
000010  b141              CBZ      r1,|L5.36|
;;;1501   
;;;1502     if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
000012  2910              CMP      r1,#0x10
000014  d006              BEQ      |L5.36|
;;;1503         (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
000016  2920              CMP      r1,#0x20
000018  d004              BEQ      |L5.36|
00001a  2930              CMP      r1,#0x30
00001c  d002              BEQ      |L5.36|
00001e  e00a              B        |L5.54|
                  |L5.32|
000020  2002              MOVS     r0,#2                 ;1500
;;;1504     {
;;;1505       /* Select the Input trigger */
;;;1506       htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;1507       htim->Instance->SMCR |= InputTrigger;
;;;1508     }
;;;1509   
;;;1510     /* Select the Capture Compare preload feature */
;;;1511     htim->Instance->CR2 |= TIM_CR2_CCPC;
;;;1512     /* Select the Commutation event source */
;;;1513     htim->Instance->CR2 &= ~TIM_CR2_CCUS;
;;;1514     htim->Instance->CR2 |= CommutationSource;
;;;1515   
;;;1516     /* Enable the Commutation DMA Request */
;;;1517     /* Set the DMA Commutation Callback */
;;;1518     htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = TIMEx_DMACommutationCplt;
;;;1519     /* Set the DMA error callback */
;;;1520     htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError;
;;;1521   
;;;1522     /* Enable the Commutation DMA Request */
;;;1523     __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_COM);
;;;1524   
;;;1525     __HAL_UNLOCK(htim);
;;;1526   
;;;1527     return HAL_OK;
;;;1528   }
000022  bd10              POP      {r4,pc}
                  |L5.36|
000024  6803              LDR      r3,[r0,#0]            ;1506
000026  689c              LDR      r4,[r3,#8]            ;1506
000028  f0240470          BIC      r4,r4,#0x70           ;1506
00002c  609c              STR      r4,[r3,#8]            ;1506
00002e  6803              LDR      r3,[r0,#0]            ;1507
000030  689c              LDR      r4,[r3,#8]            ;1507
000032  430c              ORRS     r4,r4,r1              ;1507
000034  609c              STR      r4,[r3,#8]            ;1507
                  |L5.54|
000036  6801              LDR      r1,[r0,#0]            ;1511
000038  684b              LDR      r3,[r1,#4]            ;1511
00003a  f0430301          ORR      r3,r3,#1              ;1511
00003e  604b              STR      r3,[r1,#4]            ;1511
000040  6801              LDR      r1,[r0,#0]            ;1513
000042  684b              LDR      r3,[r1,#4]            ;1513
000044  f0230304          BIC      r3,r3,#4              ;1513
000048  604b              STR      r3,[r1,#4]            ;1513
00004a  6801              LDR      r1,[r0,#0]            ;1514
00004c  684b              LDR      r3,[r1,#4]            ;1514
00004e  4313              ORRS     r3,r3,r2              ;1514
000050  604b              STR      r3,[r1,#4]            ;1514
000052  6b42              LDR      r2,[r0,#0x34]         ;1518
000054  4907              LDR      r1,|L5.116|
000056  6291              STR      r1,[r2,#0x28]         ;1520
000058  6b42              LDR      r2,[r0,#0x34]         ;1520
00005a  4907              LDR      r1,|L5.120|
00005c  6311              STR      r1,[r2,#0x30]         ;1523
00005e  6801              LDR      r1,[r0,#0]            ;1523
000060  68ca              LDR      r2,[r1,#0xc]          ;1523
000062  f4425200          ORR      r2,r2,#0x2000         ;1523
000066  60ca              STR      r2,[r1,#0xc]          ;1523
000068  2100              MOVS     r1,#0                 ;1525
00006a  f880103c          STRB     r1,[r0,#0x3c]         ;1525
00006e  4608              MOV      r0,r1                 ;1527
000070  bd10              POP      {r4,pc}
;;;1529   
                          ENDP

000072  0000              DCW      0x0000
                  |L5.116|
                          DCD      TIMEx_DMACommutationCplt
                  |L5.120|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIMEx_ConfigCommutationEvent_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_ConfigCommutationEvent_IT PROC
;;;1440     */
;;;1441   HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent_IT(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
000000  b510              PUSH     {r4,lr}
;;;1442   {
;;;1443     /* Check the parameters */
;;;1444     assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
;;;1445     assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
;;;1446   
;;;1447     __HAL_LOCK(htim);
000002  f890303c          LDRB     r3,[r0,#0x3c]
000006  2b01              CMP      r3,#1
000008  d00a              BEQ      |L6.32|
00000a  2301              MOVS     r3,#1
00000c  f880303c          STRB     r3,[r0,#0x3c]
000010  b141              CBZ      r1,|L6.36|
;;;1448   
;;;1449     if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
000012  2910              CMP      r1,#0x10
000014  d006              BEQ      |L6.36|
;;;1450         (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
000016  2920              CMP      r1,#0x20
000018  d004              BEQ      |L6.36|
00001a  2930              CMP      r1,#0x30
00001c  d002              BEQ      |L6.36|
00001e  e00a              B        |L6.54|
                  |L6.32|
000020  2002              MOVS     r0,#2                 ;1447
;;;1451     {
;;;1452       /* Select the Input trigger */
;;;1453       htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;1454       htim->Instance->SMCR |= InputTrigger;
;;;1455     }
;;;1456   
;;;1457     /* Select the Capture Compare preload feature */
;;;1458     htim->Instance->CR2 |= TIM_CR2_CCPC;
;;;1459     /* Select the Commutation event source */
;;;1460     htim->Instance->CR2 &= ~TIM_CR2_CCUS;
;;;1461     htim->Instance->CR2 |= CommutationSource;
;;;1462   
;;;1463     /* Enable the Commutation Interrupt Request */
;;;1464     __HAL_TIM_ENABLE_IT(htim, TIM_IT_COM);
;;;1465   
;;;1466     __HAL_UNLOCK(htim);
;;;1467   
;;;1468     return HAL_OK;
;;;1469   }
000022  bd10              POP      {r4,pc}
                  |L6.36|
000024  6803              LDR      r3,[r0,#0]            ;1453
000026  689c              LDR      r4,[r3,#8]            ;1453
000028  f0240470          BIC      r4,r4,#0x70           ;1453
00002c  609c              STR      r4,[r3,#8]            ;1453
00002e  6803              LDR      r3,[r0,#0]            ;1454
000030  689c              LDR      r4,[r3,#8]            ;1454
000032  430c              ORRS     r4,r4,r1              ;1454
000034  609c              STR      r4,[r3,#8]            ;1454
                  |L6.54|
000036  6801              LDR      r1,[r0,#0]            ;1458
000038  684b              LDR      r3,[r1,#4]            ;1458
00003a  f0430301          ORR      r3,r3,#1              ;1458
00003e  604b              STR      r3,[r1,#4]            ;1458
000040  6801              LDR      r1,[r0,#0]            ;1460
000042  684b              LDR      r3,[r1,#4]            ;1460
000044  f0230304          BIC      r3,r3,#4              ;1460
000048  604b              STR      r3,[r1,#4]            ;1460
00004a  6801              LDR      r1,[r0,#0]            ;1461
00004c  684b              LDR      r3,[r1,#4]            ;1461
00004e  4313              ORRS     r3,r3,r2              ;1461
000050  604b              STR      r3,[r1,#4]            ;1461
000052  6801              LDR      r1,[r0,#0]            ;1464
000054  68ca              LDR      r2,[r1,#0xc]          ;1464
000056  f0420220          ORR      r2,r2,#0x20           ;1464
00005a  60ca              STR      r2,[r1,#0xc]          ;1464
00005c  2100              MOVS     r1,#0                 ;1466
00005e  f880103c          STRB     r1,[r0,#0x3c]         ;1466
000062  4608              MOV      r0,r1                 ;1468
000064  bd10              POP      {r4,pc}
;;;1470   
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_DeInit PROC
;;;243      */
;;;244    HAL_StatusTypeDef HAL_TIMEx_HallSensor_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;245    {
000002  4604              MOV      r4,r0
;;;246      /* Check the parameters */
;;;247      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;248    
;;;249      htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f884003d          STRB     r0,[r4,#0x3d]
;;;250    
;;;251      /* Disable the TIM Peripheral Clock */
;;;252      __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L7.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L7.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L7.38|
;;;253    
;;;254      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;255      HAL_TIMEx_HallSensor_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIMEx_HallSensor_MspDeInit
;;;256    
;;;257      /* Change TIM state */
;;;258      htim->State = HAL_TIM_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  f884003d          STRB     r0,[r4,#0x3d]
;;;259    
;;;260      /* Release Lock */
;;;261      __HAL_UNLOCK(htim);
000032  f884003c          STRB     r0,[r4,#0x3c]
;;;262    
;;;263      return HAL_OK;
;;;264    }
000036  bd10              POP      {r4,pc}
;;;265    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_GetState PROC
;;;1706     */
;;;1707   HAL_TIM_StateTypeDef HAL_TIMEx_HallSensor_GetState(TIM_HandleTypeDef *htim)
000000  f890003d          LDRB     r0,[r0,#0x3d]
;;;1708   {
;;;1709     return htim->State;
;;;1710   }
000004  4770              BX       lr
;;;1711   
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Init PROC
;;;164      */
;;;165    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Init(TIM_HandleTypeDef *htim, TIM_HallSensor_InitTypeDef* sConfig)
000000  b570              PUSH     {r4-r6,lr}
;;;166    {
000002  b088              SUB      sp,sp,#0x20
000004  460e              MOV      r6,r1
000006  0004              MOVS     r4,r0
000008  d004              BEQ      |L9.20|
;;;167      TIM_OC_InitTypeDef OC_Config;
;;;168    
;;;169      /* Check the TIM handle allocation */
;;;170      if(htim == NULL)
;;;171      {
;;;172        return HAL_ERROR;
;;;173      }
;;;174    
;;;175      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;176      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;177      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;178      assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;179      assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
;;;180      assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
;;;181      assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
;;;182    
;;;183      if(htim->State == HAL_TIM_STATE_RESET)
00000a  f894003d          LDRB     r0,[r4,#0x3d]
00000e  2500              MOVS     r5,#0
000010  b118              CBZ      r0,|L9.26|
000012  e007              B        |L9.36|
                  |L9.20|
000014  2001              MOVS     r0,#1                 ;172
                  |L9.22|
;;;184      {
;;;185        /* Allocate lock resource and initialize it */
;;;186        htim->Lock = HAL_UNLOCKED;
;;;187        
;;;188        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;189        HAL_TIMEx_HallSensor_MspInit(htim);
;;;190      }
;;;191    
;;;192      /* Set the TIM state */
;;;193      htim->State= HAL_TIM_STATE_BUSY;
;;;194    
;;;195      /* Configure the Time base in the Encoder Mode */
;;;196      TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;197    
;;;198      /* Configure the Channel 1 as Input Channel to interface with the three Outputs of the  Hall sensor */
;;;199      TIM_TI1_SetConfig(htim->Instance, sConfig->IC1Polarity, TIM_ICSELECTION_TRC, sConfig->IC1Filter);
;;;200    
;;;201      /* Reset the IC1PSC Bits */
;;;202      htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;203      /* Set the IC1PSC value */
;;;204      htim->Instance->CCMR1 |= sConfig->IC1Prescaler;
;;;205    
;;;206      /* Enable the Hall sensor interface (XOR function of the three inputs) */
;;;207      htim->Instance->CR2 |= TIM_CR2_TI1S;
;;;208    
;;;209      /* Select the TIM_TS_TI1F_ED signal as Input trigger for the TIM */
;;;210      htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;211      htim->Instance->SMCR |= TIM_TS_TI1F_ED;
;;;212    
;;;213      /* Use the TIM_TS_TI1F_ED signal to reset the TIM counter each edge detection */
;;;214      htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;215      htim->Instance->SMCR |= TIM_SLAVEMODE_RESET;
;;;216    
;;;217      /* Program channel 2 in PWM 2 mode with the desired Commutation_Delay*/
;;;218      OC_Config.OCFastMode = TIM_OCFAST_DISABLE;
;;;219      OC_Config.OCIdleState = TIM_OCIDLESTATE_RESET;
;;;220      OC_Config.OCMode = TIM_OCMODE_PWM2;
;;;221      OC_Config.OCNIdleState = TIM_OCNIDLESTATE_RESET;
;;;222      OC_Config.OCNPolarity = TIM_OCNPOLARITY_HIGH;
;;;223      OC_Config.OCPolarity = TIM_OCPOLARITY_HIGH;
;;;224      OC_Config.Pulse = sConfig->Commutation_Delay;
;;;225    
;;;226      TIM_OC2_SetConfig(htim->Instance, &OC_Config);
;;;227    
;;;228      /* Select OC2REF as trigger output on TRGO: write the MMS bits in the TIMx_CR2
;;;229        register to 101 */
;;;230      htim->Instance->CR2 &= ~TIM_CR2_MMS;
;;;231      htim->Instance->CR2 |= TIM_TRGO_OC2REF;
;;;232    
;;;233      /* Initialize the TIM state*/
;;;234      htim->State= HAL_TIM_STATE_READY;
;;;235    
;;;236      return HAL_OK;
;;;237    }
000016  b008              ADD      sp,sp,#0x20
000018  bd70              POP      {r4-r6,pc}
                  |L9.26|
00001a  f884503c          STRB     r5,[r4,#0x3c]         ;186
00001e  4620              MOV      r0,r4                 ;189
000020  f7fffffe          BL       HAL_TIMEx_HallSensor_MspInit
                  |L9.36|
000024  2002              MOVS     r0,#2                 ;193
000026  f884003d          STRB     r0,[r4,#0x3d]         ;193
00002a  1d21              ADDS     r1,r4,#4              ;196
00002c  6820              LDR      r0,[r4,#0]            ;196
00002e  f7fffffe          BL       TIM_Base_SetConfig
000032  68b3              LDR      r3,[r6,#8]            ;199
000034  6831              LDR      r1,[r6,#0]            ;199
000036  2203              MOVS     r2,#3                 ;199
000038  6820              LDR      r0,[r4,#0]            ;199
00003a  f7fffffe          BL       TIM_TI1_SetConfig
00003e  6820              LDR      r0,[r4,#0]            ;202
000040  6981              LDR      r1,[r0,#0x18]         ;202
000042  f021010c          BIC      r1,r1,#0xc            ;202
000046  6181              STR      r1,[r0,#0x18]         ;202
000048  6820              LDR      r0,[r4,#0]            ;204
00004a  6981              LDR      r1,[r0,#0x18]         ;204
00004c  6872              LDR      r2,[r6,#4]            ;204
00004e  4311              ORRS     r1,r1,r2              ;204
000050  6181              STR      r1,[r0,#0x18]         ;204
000052  6820              LDR      r0,[r4,#0]            ;207
000054  6841              LDR      r1,[r0,#4]            ;207
000056  f0410180          ORR      r1,r1,#0x80           ;207
00005a  6041              STR      r1,[r0,#4]            ;207
00005c  6820              LDR      r0,[r4,#0]            ;210
00005e  6881              LDR      r1,[r0,#8]            ;210
000060  f0210170          BIC      r1,r1,#0x70           ;210
000064  6081              STR      r1,[r0,#8]            ;210
000066  6820              LDR      r0,[r4,#0]            ;211
000068  6881              LDR      r1,[r0,#8]            ;211
00006a  f0410140          ORR      r1,r1,#0x40           ;211
00006e  6081              STR      r1,[r0,#8]            ;211
000070  6820              LDR      r0,[r4,#0]            ;214
000072  6881              LDR      r1,[r0,#8]            ;214
000074  f0210107          BIC      r1,r1,#7              ;214
000078  6081              STR      r1,[r0,#8]            ;214
00007a  6820              LDR      r0,[r4,#0]            ;215
00007c  6881              LDR      r1,[r0,#8]            ;215
00007e  f0410104          ORR      r1,r1,#4              ;215
000082  6081              STR      r1,[r0,#8]            ;215
000084  2070              MOVS     r0,#0x70              ;220
000086  9505              STR      r5,[sp,#0x14]         ;221
000088  9504              STR      r5,[sp,#0x10]         ;219
00008a  9506              STR      r5,[sp,#0x18]         ;222
00008c  9503              STR      r5,[sp,#0xc]          ;223
00008e  9502              STR      r5,[sp,#8]            ;224
000090  9000              STR      r0,[sp,#0]            ;224
000092  68f0              LDR      r0,[r6,#0xc]          ;224
000094  9001              STR      r0,[sp,#4]            ;226
000096  4669              MOV      r1,sp                 ;226
000098  6820              LDR      r0,[r4,#0]            ;226
00009a  f7fffffe          BL       TIM_OC2_SetConfig
00009e  6820              LDR      r0,[r4,#0]            ;230
0000a0  6841              LDR      r1,[r0,#4]            ;230
0000a2  f0210170          BIC      r1,r1,#0x70           ;230
0000a6  6041              STR      r1,[r0,#4]            ;230
0000a8  6820              LDR      r0,[r4,#0]            ;231
0000aa  6841              LDR      r1,[r0,#4]            ;231
0000ac  f0410150          ORR      r1,r1,#0x50           ;231
0000b0  6041              STR      r1,[r0,#4]            ;231
0000b2  2001              MOVS     r0,#1                 ;234
0000b4  f884003d          STRB     r0,[r4,#0x3d]         ;234
0000b8  2000              MOVS     r0,#0                 ;236
0000ba  e7ac              B        |L9.22|
;;;238    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_MspDeInit PROC
;;;284      */
;;;285    __weak void HAL_TIMEx_HallSensor_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;286    {
;;;287      /* Prevent unused argument(s) compilation warning */
;;;288      UNUSED(htim);
;;;289      /* NOTE : This function Should not be modified, when the callback is needed,
;;;290                the HAL_TIMEx_HallSensor_MspDeInit could be implemented in the user file
;;;291       */
;;;292    }
;;;293    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_MspInit PROC
;;;270      */
;;;271    __weak void HAL_TIMEx_HallSensor_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;272    {
;;;273      /* Prevent unused argument(s) compilation warning */
;;;274      UNUSED(htim);
;;;275      /* NOTE : This function Should not be modified, when the callback is needed,
;;;276                the HAL_TIMEx_HallSensor_MspInit could be implemented in the user file
;;;277       */
;;;278    }
;;;279    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Start PROC
;;;298      */
;;;299    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;300    {
000002  4604              MOV      r4,r0
;;;301      /* Check the parameters */
;;;302      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;303    
;;;304      /* Enable the Input Capture channel 1
;;;305        (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
;;;306      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2201              MOVS     r2,#1
000008  2100              MOVS     r1,#0
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;307    
;;;308      /* Enable the Peripheral */
;;;309      __HAL_TIM_ENABLE(htim);
00000e  6820              LDR      r0,[r4,#0]
000010  6801              LDR      r1,[r0,#0]
000012  f0410101          ORR      r1,r1,#1
000016  6001              STR      r1,[r0,#0]
;;;310    
;;;311      /* Return function status */
;;;312      return HAL_OK;
000018  2000              MOVS     r0,#0
;;;313    }
00001a  bd10              POP      {r4,pc}
;;;314    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_HallSensor_Start_DMA PROC
;;;390      */
;;;391    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;392    {
000002  4604              MOV      r4,r0
;;;393      /* Check the parameters */
;;;394      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;395    
;;;396       if((htim->State == HAL_TIM_STATE_BUSY))
000004  f890003d          LDRB     r0,[r0,#0x3d]
000008  4615              MOV      r5,r2                 ;392
00000a  460e              MOV      r6,r1                 ;392
00000c  2802              CMP      r0,#2
00000e  d005              BEQ      |L13.28|
;;;397      {
;;;398         return HAL_BUSY;
;;;399      }
;;;400      else if((htim->State == HAL_TIM_STATE_READY))
000010  f894003d          LDRB     r0,[r4,#0x3d]
000014  2801              CMP      r0,#1
000016  d105              BNE      |L13.36|
;;;401      {
;;;402        if(((uint32_t)pData == 0U) && (Length > 0U))
000018  b90e              CBNZ     r6,|L13.30|
00001a  b105              CBZ      r5,|L13.30|
                  |L13.28|
;;;403        {
;;;404          return HAL_ERROR;
;;;405        }
;;;406        else
;;;407        {
;;;408          htim->State = HAL_TIM_STATE_BUSY;
;;;409        }
;;;410      }
;;;411      /* Enable the Input Capture channel 1
;;;412        (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
;;;413      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;414    
;;;415      /* Set the DMA Input Capture 1 Callback */
;;;416      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;417      /* Set the DMA error callback */
;;;418      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;419    
;;;420      /* Enable the DMA channel for Capture 1*/
;;;421      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length);
;;;422    
;;;423      /* Enable the capture compare 1 Interrupt */
;;;424      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;425    
;;;426      /* Enable the Peripheral */
;;;427      __HAL_TIM_ENABLE(htim);
;;;428    
;;;429      /* Return function status */
;;;430      return HAL_OK;
;;;431    }
00001c  bd70              POP      {r4-r6,pc}
                  |L13.30|
00001e  2002              MOVS     r0,#2                 ;408
000020  f884003d          STRB     r0,[r4,#0x3d]         ;408
                  |L13.36|
000024  2201              MOVS     r2,#1                 ;413
000026  2100              MOVS     r1,#0                 ;413
000028  6820              LDR      r0,[r4,#0]            ;413
00002a  f7fffffe          BL       TIM_CCxChannelCmd
00002e  6a61              LDR      r1,[r4,#0x24]         ;416
000030  480b              LDR      r0,|L13.96|
000032  462b              MOV      r3,r5                 ;421
000034  6288              STR      r0,[r1,#0x28]         ;418
000036  6a61              LDR      r1,[r4,#0x24]         ;418
000038  480a              LDR      r0,|L13.100|
00003a  4632              MOV      r2,r6                 ;421
00003c  6308              STR      r0,[r1,#0x30]         ;421
00003e  6821              LDR      r1,[r4,#0]            ;421
000040  6a60              LDR      r0,[r4,#0x24]         ;421
000042  3134              ADDS     r1,r1,#0x34           ;421
000044  f7fffffe          BL       HAL_DMA_Start_IT
000048  6820              LDR      r0,[r4,#0]            ;424
00004a  68c1              LDR      r1,[r0,#0xc]          ;424
00004c  f4417100          ORR      r1,r1,#0x200          ;424
000050  60c1              STR      r1,[r0,#0xc]          ;424
000052  6820              LDR      r0,[r4,#0]            ;427
000054  6801              LDR      r1,[r0,#0]            ;427
000056  f0410101          ORR      r1,r1,#1              ;427
00005a  6001              STR      r1,[r0,#0]            ;427
00005c  2000              MOVS     r0,#0                 ;430
00005e  bd70              POP      {r4-r6,pc}
;;;432    
                          ENDP

                  |L13.96|
                          DCD      TIM_DMACaptureCplt
                  |L13.100|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIMEx_HallSensor_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Start_IT PROC
;;;340      */
;;;341    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_IT(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;342    {
000002  4604              MOV      r4,r0
;;;343      /* Check the parameters */
;;;344      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;345    
;;;346      /* Enable the capture compare Interrupts 1 event */
;;;347      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000004  6800              LDR      r0,[r0,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f0410102          ORR      r1,r1,#2
00000c  60c1              STR      r1,[r0,#0xc]
;;;348    
;;;349      /* Enable the Input Capture channel 1
;;;350        (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
;;;351      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
00000e  2201              MOVS     r2,#1
000010  2100              MOVS     r1,#0
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       TIM_CCxChannelCmd
;;;352    
;;;353      /* Enable the Peripheral */
;;;354      __HAL_TIM_ENABLE(htim);
000018  6820              LDR      r0,[r4,#0]
00001a  6801              LDR      r1,[r0,#0]
00001c  f0410101          ORR      r1,r1,#1
000020  6001              STR      r1,[r0,#0]
;;;355    
;;;356      /* Return function status */
;;;357      return HAL_OK;
000022  2000              MOVS     r0,#0
;;;358    }
000024  bd10              POP      {r4,pc}
;;;359    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Stop PROC
;;;319      */
;;;320    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;321    {
000002  4604              MOV      r4,r0
;;;322      /* Check the parameters */
;;;323      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;324    
;;;325      /* Disable the Input Capture channel 1
;;;326        (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
;;;327      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000004  2200              MOVS     r2,#0
000006  6800              LDR      r0,[r0,#0]
000008  4611              MOV      r1,r2
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;328    
;;;329      /* Disable the Peripheral */
;;;330      __HAL_TIM_DISABLE(htim);
00000e  6820              LDR      r0,[r4,#0]
000010  6a01              LDR      r1,[r0,#0x20]
000012  f2411211          MOV      r2,#0x1111
000016  4211              TST      r1,r2
000018  d107              BNE      |L15.42|
00001a  6a01              LDR      r1,[r0,#0x20]
00001c  1092              ASRS     r2,r2,#2
00001e  4211              TST      r1,r2
000020  d103              BNE      |L15.42|
000022  6801              LDR      r1,[r0,#0]
000024  f0210101          BIC      r1,r1,#1
000028  6001              STR      r1,[r0,#0]
                  |L15.42|
;;;331    
;;;332      /* Return function status */
;;;333      return HAL_OK;
00002a  2000              MOVS     r0,#0
;;;334    }
00002c  bd10              POP      {r4,pc}
;;;335    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Stop_DMA PROC
;;;437      */
;;;438    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_DMA(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;439    {
000002  4604              MOV      r4,r0
;;;440      /* Check the parameters */
;;;441      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;442    
;;;443      /* Disable the Input Capture channel 1
;;;444        (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
;;;445      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000004  2200              MOVS     r2,#0
000006  6800              LDR      r0,[r0,#0]
000008  4611              MOV      r1,r2
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;446    
;;;447    
;;;448      /* Disable the capture compare Interrupts 1 event */
;;;449      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
00000e  6820              LDR      r0,[r4,#0]
000010  68c1              LDR      r1,[r0,#0xc]
000012  f4217100          BIC      r1,r1,#0x200
000016  60c1              STR      r1,[r0,#0xc]
;;;450    
;;;451      /* Disable the Peripheral */
;;;452      __HAL_TIM_DISABLE(htim);
000018  6820              LDR      r0,[r4,#0]
00001a  6a01              LDR      r1,[r0,#0x20]
00001c  f2411211          MOV      r2,#0x1111
000020  4211              TST      r1,r2
000022  d107              BNE      |L16.52|
000024  6a01              LDR      r1,[r0,#0x20]
000026  1092              ASRS     r2,r2,#2
000028  4211              TST      r1,r2
00002a  d103              BNE      |L16.52|
00002c  6801              LDR      r1,[r0,#0]
00002e  f0210101          BIC      r1,r1,#1
000032  6001              STR      r1,[r0,#0]
                  |L16.52|
;;;453    
;;;454      /* Return function status */
;;;455      return HAL_OK;
000034  2000              MOVS     r0,#0
;;;456    }
000036  bd10              POP      {r4,pc}
;;;457    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Stop_IT PROC
;;;364      */
;;;365    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_IT(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;366    {
000002  4604              MOV      r4,r0
;;;367      /* Check the parameters */
;;;368      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;369    
;;;370      /* Disable the Input Capture channel 1
;;;371        (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
;;;372      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000004  2200              MOVS     r2,#0
000006  6800              LDR      r0,[r0,#0]
000008  4611              MOV      r1,r2
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;373    
;;;374      /* Disable the capture compare Interrupts event */
;;;375      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
00000e  6820              LDR      r0,[r4,#0]
000010  68c1              LDR      r1,[r0,#0xc]
000012  f0210102          BIC      r1,r1,#2
000016  60c1              STR      r1,[r0,#0xc]
;;;376    
;;;377      /* Disable the Peripheral */
;;;378      __HAL_TIM_DISABLE(htim);
000018  6820              LDR      r0,[r4,#0]
00001a  6a01              LDR      r1,[r0,#0x20]
00001c  f2411211          MOV      r2,#0x1111
000020  4211              TST      r1,r2
000022  d107              BNE      |L17.52|
000024  6a01              LDR      r1,[r0,#0x20]
000026  1092              ASRS     r2,r2,#2
000028  4211              TST      r1,r2
00002a  d103              BNE      |L17.52|
00002c  6801              LDR      r1,[r0,#0]
00002e  f0210101          BIC      r1,r1,#1
000032  6001              STR      r1,[r0,#0]
                  |L17.52|
;;;379    
;;;380      /* Return function status */
;;;381      return HAL_OK;
000034  2000              MOVS     r0,#0
;;;382    }
000036  bd10              POP      {r4,pc}
;;;383    
                          ENDP


                          AREA ||i.HAL_TIMEx_MasterConfigSynchronization||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_MasterConfigSynchronization PROC
;;;1588     */
;;;1589   HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim, TIM_MasterConfigTypeDef * sMasterConfig)
000000  b530              PUSH     {r4,r5,lr}
;;;1590   {
;;;1591     /* Check the parameters */
;;;1592     assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
;;;1593     assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
;;;1594     assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
;;;1595   
;;;1596     __HAL_LOCK(htim);
000002  f890203c          LDRB     r2,[r0,#0x3c]
000006  2a01              CMP      r2,#1
000008  d020              BEQ      |L18.76|
00000a  2201              MOVS     r2,#1
00000c  f880203c          STRB     r2,[r0,#0x3c]
;;;1597   
;;;1598     htim->State = HAL_TIM_STATE_BUSY;
000010  2302              MOVS     r3,#2
000012  f880303d          STRB     r3,[r0,#0x3d]
;;;1599   
;;;1600     /* Reset the MMS Bits */
;;;1601     htim->Instance->CR2 &= ~TIM_CR2_MMS;
000016  6803              LDR      r3,[r0,#0]
000018  685c              LDR      r4,[r3,#4]
00001a  f0240470          BIC      r4,r4,#0x70
00001e  605c              STR      r4,[r3,#4]
;;;1602     /* Select the TRGO source */
;;;1603     htim->Instance->CR2 |=  sMasterConfig->MasterOutputTrigger;
000020  6803              LDR      r3,[r0,#0]
000022  685c              LDR      r4,[r3,#4]
000024  680d              LDR      r5,[r1,#0]
000026  432c              ORRS     r4,r4,r5
000028  605c              STR      r4,[r3,#4]
;;;1604   
;;;1605     /* Reset the MSM Bit */
;;;1606     htim->Instance->SMCR &= ~TIM_SMCR_MSM;
00002a  6803              LDR      r3,[r0,#0]
00002c  689c              LDR      r4,[r3,#8]
00002e  f0240480          BIC      r4,r4,#0x80
000032  609c              STR      r4,[r3,#8]
;;;1607     /* Set or Reset the MSM Bit */
;;;1608     htim->Instance->SMCR |= sMasterConfig->MasterSlaveMode;
000034  6803              LDR      r3,[r0,#0]
000036  689c              LDR      r4,[r3,#8]
000038  6849              LDR      r1,[r1,#4]
00003a  430c              ORRS     r4,r4,r1
00003c  609c              STR      r4,[r3,#8]
;;;1609   
;;;1610     htim->State = HAL_TIM_STATE_READY;
00003e  f880203d          STRB     r2,[r0,#0x3d]
;;;1611   
;;;1612     __HAL_UNLOCK(htim);
000042  2100              MOVS     r1,#0
000044  f880103c          STRB     r1,[r0,#0x3c]
;;;1613   
;;;1614     return HAL_OK;
000048  4608              MOV      r0,r1
;;;1615   }
00004a  bd30              POP      {r4,r5,pc}
                  |L18.76|
00004c  2002              MOVS     r0,#2                 ;1596
00004e  bd30              POP      {r4,r5,pc}
;;;1616   
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Start PROC
;;;496      */
;;;497    HAL_StatusTypeDef HAL_TIMEx_OCN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;498    {
000002  4604              MOV      r4,r0
;;;499      /* Check the parameters */
;;;500      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;501    
;;;502      /* Enable the Capture compare channel N */
;;;503      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2204              MOVS     r2,#4
000008  f7fffffe          BL       TIM_CCxNChannelCmd
;;;504    
;;;505      /* Enable the Main Ouput */
;;;506      __HAL_TIM_MOE_ENABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  6c41              LDR      r1,[r0,#0x44]
000010  f4414100          ORR      r1,r1,#0x8000
000014  6441              STR      r1,[r0,#0x44]
;;;507    
;;;508      /* Enable the Peripheral */
;;;509      __HAL_TIM_ENABLE(htim);
000016  6820              LDR      r0,[r4,#0]
000018  6801              LDR      r1,[r0,#0]
00001a  f0410101          ORR      r1,r1,#1
00001e  6001              STR      r1,[r0,#0]
;;;510    
;;;511      /* Return function status */
;;;512      return HAL_OK;
000020  2000              MOVS     r0,#0
;;;513    }
000022  bd10              POP      {r4,pc}
;;;514    
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_OCN_Start_DMA PROC
;;;680      */
;;;681    HAL_StatusTypeDef HAL_TIMEx_OCN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;682    {
000002  4604              MOV      r4,r0
;;;683      /* Check the parameters */
;;;684      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;685    
;;;686      if((htim->State == HAL_TIM_STATE_BUSY))
000004  f890003d          LDRB     r0,[r0,#0x3d]
000008  4615              MOV      r5,r2                 ;682
00000a  460e              MOV      r6,r1                 ;682
00000c  2802              CMP      r0,#2
00000e  d005              BEQ      |L20.28|
;;;687      {
;;;688         return HAL_BUSY;
;;;689      }
;;;690      else if((htim->State == HAL_TIM_STATE_READY))
000010  f894003d          LDRB     r0,[r4,#0x3d]
000014  2801              CMP      r0,#1
000016  d105              BNE      |L20.36|
;;;691      {
;;;692        if(((uint32_t)pData == 0U) && (Length > 0U))
000018  b90d              CBNZ     r5,|L20.30|
00001a  b103              CBZ      r3,|L20.30|
                  |L20.28|
;;;693        {
;;;694          return HAL_ERROR;
;;;695        }
;;;696        else
;;;697        {
;;;698          htim->State = HAL_TIM_STATE_BUSY;
;;;699        }
;;;700      }
;;;701      switch (Channel)
;;;702      {
;;;703        case TIM_CHANNEL_1:
;;;704        {
;;;705          /* Set the DMA Period elapsed callback */
;;;706          htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;707    
;;;708          /* Set the DMA error callback */
;;;709          htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;710    
;;;711          /* Enable the DMA channel */
;;;712          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;713    
;;;714          /* Enable the TIM Output Compare DMA request */
;;;715          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;716        }
;;;717        break;
;;;718    
;;;719        case TIM_CHANNEL_2:
;;;720        {
;;;721          /* Set the DMA Period elapsed callback */
;;;722          htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;723    
;;;724          /* Set the DMA error callback */
;;;725          htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;726    
;;;727          /* Enable the DMA channel */
;;;728          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;729    
;;;730          /* Enable the TIM Output Compare DMA request */
;;;731          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;732        }
;;;733        break;
;;;734    
;;;735        case TIM_CHANNEL_3:
;;;736        {
;;;737          /* Set the DMA Period elapsed callback */
;;;738          htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;739    
;;;740          /* Set the DMA error callback */
;;;741          htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;742    
;;;743          /* Enable the DMA channel */
;;;744          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;745    
;;;746          /* Enable the TIM Output Compare DMA request */
;;;747          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;748        }
;;;749        break;
;;;750    
;;;751        default:
;;;752        break;
;;;753      }
;;;754    
;;;755      /* Enable the Capture compare channel N */
;;;756      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
;;;757    
;;;758      /* Enable the Main Ouput */
;;;759      __HAL_TIM_MOE_ENABLE(htim);
;;;760    
;;;761      /* Enable the Peripheral */
;;;762      __HAL_TIM_ENABLE(htim);
;;;763    
;;;764      /* Return function status */
;;;765      return HAL_OK;
;;;766    }
00001c  bd70              POP      {r4-r6,pc}
                  |L20.30|
00001e  2002              MOVS     r0,#2                 ;698
000020  f884003d          STRB     r0,[r4,#0x3d]         ;698
                  |L20.36|
000024  4822              LDR      r0,|L20.176|
000026  4923              LDR      r1,|L20.180|
000028  b126              CBZ      r6,|L20.52|
00002a  2e04              CMP      r6,#4                 ;701
00002c  d011              BEQ      |L20.82|
00002e  2e08              CMP      r6,#8                 ;701
000030  d11e              BNE      |L20.112|
000032  e02e              B        |L20.146|
                  |L20.52|
000034  6a62              LDR      r2,[r4,#0x24]         ;706
000036  6290              STR      r0,[r2,#0x28]         ;709
000038  6a60              LDR      r0,[r4,#0x24]         ;709
00003a  6301              STR      r1,[r0,#0x30]         ;712
00003c  6822              LDR      r2,[r4,#0]            ;712
00003e  4629              MOV      r1,r5                 ;712
000040  3234              ADDS     r2,r2,#0x34           ;712
000042  6a60              LDR      r0,[r4,#0x24]         ;712
000044  f7fffffe          BL       HAL_DMA_Start_IT
000048  6820              LDR      r0,[r4,#0]            ;715
00004a  68c1              LDR      r1,[r0,#0xc]          ;715
00004c  f4417100          ORR      r1,r1,#0x200          ;715
000050  e00d              B        |L20.110|
                  |L20.82|
000052  6aa2              LDR      r2,[r4,#0x28]         ;722
000054  6290              STR      r0,[r2,#0x28]         ;725
000056  6aa0              LDR      r0,[r4,#0x28]         ;725
000058  6301              STR      r1,[r0,#0x30]         ;728
00005a  6822              LDR      r2,[r4,#0]            ;728
00005c  4629              MOV      r1,r5                 ;728
00005e  3238              ADDS     r2,r2,#0x38           ;728
000060  6aa0              LDR      r0,[r4,#0x28]         ;728
000062  f7fffffe          BL       HAL_DMA_Start_IT
000066  6820              LDR      r0,[r4,#0]            ;731
000068  68c1              LDR      r1,[r0,#0xc]          ;731
00006a  f4416180          ORR      r1,r1,#0x400          ;731
                  |L20.110|
00006e  60c1              STR      r1,[r0,#0xc]          ;715
                  |L20.112|
000070  2204              MOVS     r2,#4                 ;756
000072  4631              MOV      r1,r6                 ;756
000074  6820              LDR      r0,[r4,#0]            ;756
000076  f7fffffe          BL       TIM_CCxNChannelCmd
00007a  6820              LDR      r0,[r4,#0]            ;759
00007c  6c41              LDR      r1,[r0,#0x44]         ;759
00007e  f4414100          ORR      r1,r1,#0x8000         ;759
000082  6441              STR      r1,[r0,#0x44]         ;759
000084  6820              LDR      r0,[r4,#0]            ;762
000086  6801              LDR      r1,[r0,#0]            ;762
000088  f0410101          ORR      r1,r1,#1              ;762
00008c  6001              STR      r1,[r0,#0]            ;762
00008e  2000              MOVS     r0,#0                 ;765
000090  bd70              POP      {r4-r6,pc}
                  |L20.146|
000092  6ae2              LDR      r2,[r4,#0x2c]         ;738
000094  6290              STR      r0,[r2,#0x28]         ;741
000096  6ae0              LDR      r0,[r4,#0x2c]         ;741
000098  6301              STR      r1,[r0,#0x30]         ;744
00009a  6822              LDR      r2,[r4,#0]            ;744
00009c  4629              MOV      r1,r5                 ;744
00009e  323c              ADDS     r2,r2,#0x3c           ;744
0000a0  6ae0              LDR      r0,[r4,#0x2c]         ;744
0000a2  f7fffffe          BL       HAL_DMA_Start_IT
0000a6  6820              LDR      r0,[r4,#0]            ;747
0000a8  68c1              LDR      r1,[r0,#0xc]          ;747
0000aa  f4416100          ORR      r1,r1,#0x800          ;747
0000ae  e7de              B        |L20.110|
;;;767    
                          ENDP

                  |L20.176|
                          DCD      TIM_DMADelayPulseCplt
                  |L20.180|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIMEx_OCN_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Start_IT PROC
;;;554      */
;;;555    HAL_StatusTypeDef HAL_TIMEx_OCN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;556    {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b121              CBZ      r1,|L21.18|
;;;557      /* Check the parameters */
;;;558      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;559    
;;;560      switch (Channel)
000008  2904              CMP      r1,#4
00000a  d006              BEQ      |L21.26|
00000c  2908              CMP      r1,#8
00000e  d108              BNE      |L21.34|
000010  e01c              B        |L21.76|
                  |L21.18|
;;;561      {
;;;562        case TIM_CHANNEL_1:
;;;563        {
;;;564          /* Enable the TIM Output Compare interrupt */
;;;565          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000012  68d0              LDR      r0,[r2,#0xc]
000014  f0400002          ORR      r0,r0,#2
;;;566        }
;;;567        break;
000018  e002              B        |L21.32|
                  |L21.26|
;;;568    
;;;569        case TIM_CHANNEL_2:
;;;570        {
;;;571          /* Enable the TIM Output Compare interrupt */
;;;572          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00001a  68d0              LDR      r0,[r2,#0xc]
00001c  f0400004          ORR      r0,r0,#4
                  |L21.32|
000020  60d0              STR      r0,[r2,#0xc]          ;565
                  |L21.34|
;;;573        }
;;;574        break;
;;;575    
;;;576        case TIM_CHANNEL_3:
;;;577        {
;;;578          /* Enable the TIM Output Compare interrupt */
;;;579          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
;;;580        }
;;;581        break;
;;;582    
;;;583        default:
;;;584        break;
;;;585      }
;;;586    
;;;587      /* Enable the TIM Break interrupt */
;;;588      __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
000022  6820              LDR      r0,[r4,#0]
000024  68c2              LDR      r2,[r0,#0xc]
000026  f0420280          ORR      r2,r2,#0x80
00002a  60c2              STR      r2,[r0,#0xc]
;;;589    
;;;590      /* Enable the Capture compare channel N */
;;;591      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
00002c  2204              MOVS     r2,#4
00002e  6820              LDR      r0,[r4,#0]
000030  f7fffffe          BL       TIM_CCxNChannelCmd
;;;592    
;;;593      /* Enable the Main Ouput */
;;;594      __HAL_TIM_MOE_ENABLE(htim);
000034  6820              LDR      r0,[r4,#0]
000036  6c41              LDR      r1,[r0,#0x44]
000038  f4414100          ORR      r1,r1,#0x8000
00003c  6441              STR      r1,[r0,#0x44]
;;;595    
;;;596      /* Enable the Peripheral */
;;;597      __HAL_TIM_ENABLE(htim);
00003e  6820              LDR      r0,[r4,#0]
000040  6801              LDR      r1,[r0,#0]
000042  f0410101          ORR      r1,r1,#1
000046  6001              STR      r1,[r0,#0]
;;;598    
;;;599      /* Return function status */
;;;600      return HAL_OK;
000048  2000              MOVS     r0,#0
;;;601    }
00004a  bd10              POP      {r4,pc}
                  |L21.76|
00004c  68d0              LDR      r0,[r2,#0xc]          ;579
00004e  f0400008          ORR      r0,r0,#8              ;579
000052  e7e5              B        |L21.32|
;;;602    
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Stop PROC
;;;525      */
;;;526    HAL_StatusTypeDef HAL_TIMEx_OCN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;527    {
000002  4604              MOV      r4,r0
;;;528      /* Check the parameters */
;;;529      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;530    
;;;531      /* Disable the Capture compare channel N */
;;;532      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2200              MOVS     r2,#0
000008  f7fffffe          BL       TIM_CCxNChannelCmd
;;;533    
;;;534      /* Disable the Main Ouput */
;;;535      __HAL_TIM_MOE_DISABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  6a03              LDR      r3,[r0,#0x20]
000010  f2411111          MOV      r1,#0x1111
000014  420b              TST      r3,r1
000016  f2404244          MOV      r2,#0x444
00001a  d106              BNE      |L22.42|
00001c  6a03              LDR      r3,[r0,#0x20]
00001e  4213              TST      r3,r2
000020  d103              BNE      |L22.42|
000022  6c43              LDR      r3,[r0,#0x44]
000024  f4234300          BIC      r3,r3,#0x8000
000028  6443              STR      r3,[r0,#0x44]
                  |L22.42|
;;;536    
;;;537      /* Disable the Peripheral */
;;;538      __HAL_TIM_DISABLE(htim);
00002a  6820              LDR      r0,[r4,#0]
00002c  6a03              LDR      r3,[r0,#0x20]
00002e  420b              TST      r3,r1
000030  d106              BNE      |L22.64|
000032  6a01              LDR      r1,[r0,#0x20]
000034  4211              TST      r1,r2
000036  d103              BNE      |L22.64|
000038  6801              LDR      r1,[r0,#0]
00003a  f0210101          BIC      r1,r1,#1
00003e  6001              STR      r1,[r0,#0]
                  |L22.64|
;;;539    
;;;540      /* Return function status */
;;;541      return HAL_OK;
000040  2000              MOVS     r0,#0
;;;542    }
000042  bd10              POP      {r4,pc}
;;;543    
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Stop_DMA PROC
;;;778      */
;;;779    HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;780    {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b121              CBZ      r1,|L23.18|
;;;781      /* Check the parameters */
;;;782      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;783    
;;;784      switch (Channel)
000008  2904              CMP      r1,#4
00000a  d006              BEQ      |L23.26|
00000c  2908              CMP      r1,#8
00000e  d108              BNE      |L23.34|
000010  e02a              B        |L23.104|
                  |L23.18|
;;;785      {
;;;786        case TIM_CHANNEL_1:
;;;787        {
;;;788          /* Disable the TIM Output Compare DMA request */
;;;789          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000012  68d0              LDR      r0,[r2,#0xc]
000014  f4207000          BIC      r0,r0,#0x200
;;;790        }
;;;791        break;
000018  e002              B        |L23.32|
                  |L23.26|
;;;792    
;;;793        case TIM_CHANNEL_2:
;;;794        {
;;;795          /* Disable the TIM Output Compare DMA request */
;;;796          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00001a  68d0              LDR      r0,[r2,#0xc]
00001c  f4206080          BIC      r0,r0,#0x400
                  |L23.32|
000020  60d0              STR      r0,[r2,#0xc]          ;789
                  |L23.34|
;;;797        }
;;;798        break;
;;;799    
;;;800        case TIM_CHANNEL_3:
;;;801        {
;;;802          /* Disable the TIM Output Compare DMA request */
;;;803          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
;;;804        }
;;;805        break;
;;;806    
;;;807        default:
;;;808        break;
;;;809      }
;;;810    
;;;811      /* Disable the Capture compare channel N */
;;;812      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000022  2200              MOVS     r2,#0
000024  6820              LDR      r0,[r4,#0]
000026  f7fffffe          BL       TIM_CCxNChannelCmd
;;;813    
;;;814      /* Disable the Main Ouput */
;;;815      __HAL_TIM_MOE_DISABLE(htim);
00002a  6820              LDR      r0,[r4,#0]
00002c  6a03              LDR      r3,[r0,#0x20]
00002e  f2411111          MOV      r1,#0x1111
000032  420b              TST      r3,r1
000034  f2404244          MOV      r2,#0x444
000038  d106              BNE      |L23.72|
00003a  6a03              LDR      r3,[r0,#0x20]
00003c  4213              TST      r3,r2
00003e  d103              BNE      |L23.72|
000040  6c43              LDR      r3,[r0,#0x44]
000042  f4234300          BIC      r3,r3,#0x8000
000046  6443              STR      r3,[r0,#0x44]
                  |L23.72|
;;;816    
;;;817      /* Disable the Peripheral */
;;;818      __HAL_TIM_DISABLE(htim);
000048  6820              LDR      r0,[r4,#0]
00004a  6a03              LDR      r3,[r0,#0x20]
00004c  420b              TST      r3,r1
00004e  d106              BNE      |L23.94|
000050  6a01              LDR      r1,[r0,#0x20]
000052  4211              TST      r1,r2
000054  d103              BNE      |L23.94|
000056  6801              LDR      r1,[r0,#0]
000058  f0210101          BIC      r1,r1,#1
00005c  6001              STR      r1,[r0,#0]
                  |L23.94|
;;;819    
;;;820      /* Change the htim state */
;;;821      htim->State = HAL_TIM_STATE_READY;
00005e  2001              MOVS     r0,#1
000060  f884003d          STRB     r0,[r4,#0x3d]
;;;822    
;;;823      /* Return function status */
;;;824      return HAL_OK;
000064  2000              MOVS     r0,#0
;;;825    }
000066  bd10              POP      {r4,pc}
                  |L23.104|
000068  68d0              LDR      r0,[r2,#0xc]          ;803
00006a  f4206000          BIC      r0,r0,#0x800          ;803
00006e  e7d7              B        |L23.32|
;;;826    
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Stop_IT PROC
;;;613      */
;;;614    HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;615    {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b121              CBZ      r1,|L24.18|
;;;616      uint32_t tmpccer = 0U;
;;;617    
;;;618      /* Check the parameters */
;;;619      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;620    
;;;621      switch (Channel)
000008  2904              CMP      r1,#4
00000a  d006              BEQ      |L24.26|
00000c  2908              CMP      r1,#8
00000e  d108              BNE      |L24.34|
000010  e02f              B        |L24.114|
                  |L24.18|
;;;622      {
;;;623        case TIM_CHANNEL_1:
;;;624        {
;;;625          /* Disable the TIM Output Compare interrupt */
;;;626          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000012  68d0              LDR      r0,[r2,#0xc]
000014  f0200002          BIC      r0,r0,#2
;;;627        }
;;;628        break;
000018  e002              B        |L24.32|
                  |L24.26|
;;;629    
;;;630        case TIM_CHANNEL_2:
;;;631        {
;;;632          /* Disable the TIM Output Compare interrupt */
;;;633          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00001a  68d0              LDR      r0,[r2,#0xc]
00001c  f0200004          BIC      r0,r0,#4
                  |L24.32|
000020  60d0              STR      r0,[r2,#0xc]          ;626
                  |L24.34|
;;;634        }
;;;635        break;
;;;636    
;;;637        case TIM_CHANNEL_3:
;;;638        {
;;;639          /* Disable the TIM Output Compare interrupt */
;;;640          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
;;;641        }
;;;642        break;
;;;643    
;;;644        default:
;;;645        break;
;;;646      }
;;;647    
;;;648      /* Disable the Capture compare channel N */
;;;649      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000022  2200              MOVS     r2,#0
000024  6820              LDR      r0,[r4,#0]
000026  f7fffffe          BL       TIM_CCxNChannelCmd
;;;650    
;;;651      /* Disable the TIM Break interrupt (only if no more channel is active) */
;;;652      tmpccer = htim->Instance->CCER;
00002a  6820              LDR      r0,[r4,#0]
00002c  6a02              LDR      r2,[r0,#0x20]
;;;653      if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == RESET)
00002e  f2404144          MOV      r1,#0x444
000032  420a              TST      r2,r1
000034  d103              BNE      |L24.62|
;;;654      {
;;;655        __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
000036  68c2              LDR      r2,[r0,#0xc]
000038  f0220280          BIC      r2,r2,#0x80
00003c  60c2              STR      r2,[r0,#0xc]
                  |L24.62|
;;;656      }
;;;657    
;;;658      /* Disable the Main Ouput */
;;;659      __HAL_TIM_MOE_DISABLE(htim);
00003e  6820              LDR      r0,[r4,#0]
000040  6a03              LDR      r3,[r0,#0x20]
000042  f2411211          MOV      r2,#0x1111
000046  4213              TST      r3,r2
000048  d106              BNE      |L24.88|
00004a  6a03              LDR      r3,[r0,#0x20]
00004c  420b              TST      r3,r1
00004e  d103              BNE      |L24.88|
000050  6c43              LDR      r3,[r0,#0x44]
000052  f4234300          BIC      r3,r3,#0x8000
000056  6443              STR      r3,[r0,#0x44]
                  |L24.88|
;;;660    
;;;661      /* Disable the Peripheral */
;;;662      __HAL_TIM_DISABLE(htim);
000058  6820              LDR      r0,[r4,#0]
00005a  6a03              LDR      r3,[r0,#0x20]
00005c  4213              TST      r3,r2
00005e  d106              BNE      |L24.110|
000060  6a02              LDR      r2,[r0,#0x20]
000062  420a              TST      r2,r1
000064  d103              BNE      |L24.110|
000066  6801              LDR      r1,[r0,#0]
000068  f0210101          BIC      r1,r1,#1
00006c  6001              STR      r1,[r0,#0]
                  |L24.110|
;;;663    
;;;664      /* Return function status */
;;;665      return HAL_OK;
00006e  2000              MOVS     r0,#0
;;;666    }
000070  bd10              POP      {r4,pc}
                  |L24.114|
000072  68d0              LDR      r0,[r2,#0xc]          ;640
000074  f0200008          BIC      r0,r0,#8              ;640
000078  e7d2              B        |L24.32|
;;;667    
                          ENDP


                          AREA ||i.HAL_TIMEx_OnePulseN_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OnePulseN_Start PROC
;;;1231     */
;;;1232   HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;1233   {
000002  4604              MOV      r4,r0
;;;1234     /* Check the parameters */
;;;1235     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
;;;1236   
;;;1237     /* Enable the complementary One Pulse output */
;;;1238     TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2204              MOVS     r2,#4
000008  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1239   
;;;1240     /* Enable the Main Ouput */
;;;1241     __HAL_TIM_MOE_ENABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  6c41              LDR      r1,[r0,#0x44]
000010  f4414100          ORR      r1,r1,#0x8000
000014  6441              STR      r1,[r0,#0x44]
;;;1242   
;;;1243     /* Return function status */
;;;1244     return HAL_OK;
000016  2000              MOVS     r0,#0
;;;1245   }
000018  bd10              POP      {r4,pc}
;;;1246   
                          ENDP


                          AREA ||i.HAL_TIMEx_OnePulseN_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OnePulseN_Start_IT PROC
;;;1285     */
;;;1286   HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;1287   {
000002  4604              MOV      r4,r0
;;;1288     /* Check the parameters */
;;;1289     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
;;;1290   
;;;1291     /* Enable the TIM Capture/Compare 1 interrupt */
;;;1292     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000004  6800              LDR      r0,[r0,#0]
000006  68c2              LDR      r2,[r0,#0xc]
000008  f0420202          ORR      r2,r2,#2
00000c  60c2              STR      r2,[r0,#0xc]
;;;1293   
;;;1294     /* Enable the TIM Capture/Compare 2 interrupt */
;;;1295     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00000e  6820              LDR      r0,[r4,#0]
000010  68c2              LDR      r2,[r0,#0xc]
000012  f0420204          ORR      r2,r2,#4
000016  60c2              STR      r2,[r0,#0xc]
;;;1296   
;;;1297     /* Enable the complementary One Pulse output */
;;;1298     TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);
000018  2204              MOVS     r2,#4
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1299   
;;;1300     /* Enable the Main Ouput */
;;;1301     __HAL_TIM_MOE_ENABLE(htim);
000020  6820              LDR      r0,[r4,#0]
000022  6c41              LDR      r1,[r0,#0x44]
000024  f4414100          ORR      r1,r1,#0x8000
000028  6441              STR      r1,[r0,#0x44]
;;;1302   
;;;1303     /* Return function status */
;;;1304     return HAL_OK;
00002a  2000              MOVS     r0,#0
;;;1305   }
00002c  bd10              POP      {r4,pc}
;;;1306   
                          ENDP


                          AREA ||i.HAL_TIMEx_OnePulseN_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OnePulseN_Stop PROC
;;;1256     */
;;;1257   HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;1258   {
000002  4604              MOV      r4,r0
;;;1259   
;;;1260     /* Check the parameters */
;;;1261     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
;;;1262   
;;;1263     /* Disable the complementary One Pulse output */
;;;1264     TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2200              MOVS     r2,#0
000008  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1265   
;;;1266     /* Disable the Main Ouput */
;;;1267     __HAL_TIM_MOE_DISABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  6a03              LDR      r3,[r0,#0x20]
000010  f2411111          MOV      r1,#0x1111
000014  420b              TST      r3,r1
000016  f2404244          MOV      r2,#0x444
00001a  d106              BNE      |L27.42|
00001c  6a03              LDR      r3,[r0,#0x20]
00001e  4213              TST      r3,r2
000020  d103              BNE      |L27.42|
000022  6c43              LDR      r3,[r0,#0x44]
000024  f4234300          BIC      r3,r3,#0x8000
000028  6443              STR      r3,[r0,#0x44]
                  |L27.42|
;;;1268   
;;;1269     /* Disable the Peripheral */
;;;1270     __HAL_TIM_DISABLE(htim);
00002a  6820              LDR      r0,[r4,#0]
00002c  6a03              LDR      r3,[r0,#0x20]
00002e  420b              TST      r3,r1
000030  d106              BNE      |L27.64|
000032  6a01              LDR      r1,[r0,#0x20]
000034  4211              TST      r1,r2
000036  d103              BNE      |L27.64|
000038  6801              LDR      r1,[r0,#0]
00003a  f0210101          BIC      r1,r1,#1
00003e  6001              STR      r1,[r0,#0]
                  |L27.64|
;;;1271   
;;;1272     /* Return function status */
;;;1273     return HAL_OK;
000040  2000              MOVS     r0,#0
;;;1274   }
000042  bd10              POP      {r4,pc}
;;;1275   
                          ENDP


                          AREA ||i.HAL_TIMEx_OnePulseN_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OnePulseN_Stop_IT PROC
;;;1316     */
;;;1317   HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;1318   {
000002  4604              MOV      r4,r0
;;;1319     /* Check the parameters */
;;;1320     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
;;;1321   
;;;1322     /* Disable the TIM Capture/Compare 1 interrupt */
;;;1323     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000004  6800              LDR      r0,[r0,#0]
000006  68c2              LDR      r2,[r0,#0xc]
000008  f0220202          BIC      r2,r2,#2
00000c  60c2              STR      r2,[r0,#0xc]
;;;1324   
;;;1325     /* Disable the TIM Capture/Compare 2 interrupt */
;;;1326     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00000e  6820              LDR      r0,[r4,#0]
000010  68c2              LDR      r2,[r0,#0xc]
000012  f0220204          BIC      r2,r2,#4
000016  60c2              STR      r2,[r0,#0xc]
;;;1327   
;;;1328     /* Disable the complementary One Pulse output */
;;;1329     TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
000018  2200              MOVS     r2,#0
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1330   
;;;1331     /* Disable the Main Ouput */
;;;1332     __HAL_TIM_MOE_DISABLE(htim);
000020  6820              LDR      r0,[r4,#0]
000022  6a03              LDR      r3,[r0,#0x20]
000024  f2411111          MOV      r1,#0x1111
000028  420b              TST      r3,r1
00002a  f2404244          MOV      r2,#0x444
00002e  d106              BNE      |L28.62|
000030  6a03              LDR      r3,[r0,#0x20]
000032  4213              TST      r3,r2
000034  d103              BNE      |L28.62|
000036  6c43              LDR      r3,[r0,#0x44]
000038  f4234300          BIC      r3,r3,#0x8000
00003c  6443              STR      r3,[r0,#0x44]
                  |L28.62|
;;;1333   
;;;1334     /* Disable the Peripheral */
;;;1335     __HAL_TIM_DISABLE(htim);
00003e  6820              LDR      r0,[r4,#0]
000040  6a03              LDR      r3,[r0,#0x20]
000042  420b              TST      r3,r1
000044  d106              BNE      |L28.84|
000046  6a01              LDR      r1,[r0,#0x20]
000048  4211              TST      r1,r2
00004a  d103              BNE      |L28.84|
00004c  6801              LDR      r1,[r0,#0]
00004e  f0210101          BIC      r1,r1,#1
000052  6001              STR      r1,[r0,#0]
                  |L28.84|
;;;1336   
;;;1337     /* Return function status */
;;;1338     return HAL_OK;
000054  2000              MOVS     r0,#0
;;;1339   }
000056  bd10              POP      {r4,pc}
;;;1340   
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Start PROC
;;;870      */
;;;871    HAL_StatusTypeDef HAL_TIMEx_PWMN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;872    {
000002  4604              MOV      r4,r0
;;;873      /* Check the parameters */
;;;874      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;875    
;;;876      /* Enable the complementary PWM output  */
;;;877      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2204              MOVS     r2,#4
000008  f7fffffe          BL       TIM_CCxNChannelCmd
;;;878    
;;;879      /* Enable the Main Ouput */
;;;880      __HAL_TIM_MOE_ENABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  6c41              LDR      r1,[r0,#0x44]
000010  f4414100          ORR      r1,r1,#0x8000
000014  6441              STR      r1,[r0,#0x44]
;;;881    
;;;882      /* Enable the Peripheral */
;;;883      __HAL_TIM_ENABLE(htim);
000016  6820              LDR      r0,[r4,#0]
000018  6801              LDR      r1,[r0,#0]
00001a  f0410101          ORR      r1,r1,#1
00001e  6001              STR      r1,[r0,#0]
;;;884    
;;;885      /* Return function status */
;;;886      return HAL_OK;
000020  2000              MOVS     r0,#0
;;;887    }
000022  bd10              POP      {r4,pc}
;;;888    
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_PWMN_Start_DMA PROC
;;;1053     */
;;;1054   HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;1055   {
000002  4604              MOV      r4,r0
;;;1056     /* Check the parameters */
;;;1057     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;1058   
;;;1059     if((htim->State == HAL_TIM_STATE_BUSY))
000004  f890003d          LDRB     r0,[r0,#0x3d]
000008  4615              MOV      r5,r2                 ;1055
00000a  460e              MOV      r6,r1                 ;1055
00000c  2802              CMP      r0,#2
00000e  d005              BEQ      |L30.28|
;;;1060     {
;;;1061        return HAL_BUSY;
;;;1062     }
;;;1063     else if((htim->State == HAL_TIM_STATE_READY))
000010  f894003d          LDRB     r0,[r4,#0x3d]
000014  2801              CMP      r0,#1
000016  d105              BNE      |L30.36|
;;;1064     {
;;;1065       if(((uint32_t)pData == 0U) && (Length > 0U))
000018  b90d              CBNZ     r5,|L30.30|
00001a  b103              CBZ      r3,|L30.30|
                  |L30.28|
;;;1066       {
;;;1067         return HAL_ERROR;
;;;1068       }
;;;1069       else
;;;1070       {
;;;1071         htim->State = HAL_TIM_STATE_BUSY;
;;;1072       }
;;;1073     }
;;;1074     switch (Channel)
;;;1075     {
;;;1076       case TIM_CHANNEL_1:
;;;1077       {
;;;1078         /* Set the DMA Period elapsed callback */
;;;1079         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1080   
;;;1081         /* Set the DMA error callback */
;;;1082         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;1083   
;;;1084         /* Enable the DMA channel */
;;;1085         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;1086   
;;;1087         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1088         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1089       }
;;;1090       break;
;;;1091   
;;;1092       case TIM_CHANNEL_2:
;;;1093       {
;;;1094         /* Set the DMA Period elapsed callback */
;;;1095         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1096   
;;;1097         /* Set the DMA error callback */
;;;1098         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;1099   
;;;1100         /* Enable the DMA channel */
;;;1101         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;1102   
;;;1103         /* Enable the TIM Capture/Compare 2 DMA request */
;;;1104         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1105       }
;;;1106       break;
;;;1107   
;;;1108       case TIM_CHANNEL_3:
;;;1109       {
;;;1110         /* Set the DMA Period elapsed callback */
;;;1111         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1112   
;;;1113         /* Set the DMA error callback */
;;;1114         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;1115   
;;;1116         /* Enable the DMA channel */
;;;1117         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;1118   
;;;1119         /* Enable the TIM Capture/Compare 3 DMA request */
;;;1120         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1121       }
;;;1122       break;
;;;1123   
;;;1124       default:
;;;1125       break;
;;;1126     }
;;;1127   
;;;1128     /* Enable the complementary PWM output  */
;;;1129     TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
;;;1130   
;;;1131     /* Enable the Main Ouput */
;;;1132     __HAL_TIM_MOE_ENABLE(htim);
;;;1133   
;;;1134     /* Enable the Peripheral */
;;;1135     __HAL_TIM_ENABLE(htim);
;;;1136   
;;;1137     /* Return function status */
;;;1138     return HAL_OK;
;;;1139   }
00001c  bd70              POP      {r4-r6,pc}
                  |L30.30|
00001e  2002              MOVS     r0,#2                 ;1071
000020  f884003d          STRB     r0,[r4,#0x3d]         ;1071
                  |L30.36|
000024  4822              LDR      r0,|L30.176|
000026  4923              LDR      r1,|L30.180|
000028  b126              CBZ      r6,|L30.52|
00002a  2e04              CMP      r6,#4                 ;1074
00002c  d011              BEQ      |L30.82|
00002e  2e08              CMP      r6,#8                 ;1074
000030  d11e              BNE      |L30.112|
000032  e02e              B        |L30.146|
                  |L30.52|
000034  6a62              LDR      r2,[r4,#0x24]         ;1079
000036  6290              STR      r0,[r2,#0x28]         ;1082
000038  6a60              LDR      r0,[r4,#0x24]         ;1082
00003a  6301              STR      r1,[r0,#0x30]         ;1085
00003c  6822              LDR      r2,[r4,#0]            ;1085
00003e  4629              MOV      r1,r5                 ;1085
000040  3234              ADDS     r2,r2,#0x34           ;1085
000042  6a60              LDR      r0,[r4,#0x24]         ;1085
000044  f7fffffe          BL       HAL_DMA_Start_IT
000048  6820              LDR      r0,[r4,#0]            ;1088
00004a  68c1              LDR      r1,[r0,#0xc]          ;1088
00004c  f4417100          ORR      r1,r1,#0x200          ;1088
000050  e00d              B        |L30.110|
                  |L30.82|
000052  6aa2              LDR      r2,[r4,#0x28]         ;1095
000054  6290              STR      r0,[r2,#0x28]         ;1098
000056  6aa0              LDR      r0,[r4,#0x28]         ;1098
000058  6301              STR      r1,[r0,#0x30]         ;1101
00005a  6822              LDR      r2,[r4,#0]            ;1101
00005c  4629              MOV      r1,r5                 ;1101
00005e  3238              ADDS     r2,r2,#0x38           ;1101
000060  6aa0              LDR      r0,[r4,#0x28]         ;1101
000062  f7fffffe          BL       HAL_DMA_Start_IT
000066  6820              LDR      r0,[r4,#0]            ;1104
000068  68c1              LDR      r1,[r0,#0xc]          ;1104
00006a  f4416180          ORR      r1,r1,#0x400          ;1104
                  |L30.110|
00006e  60c1              STR      r1,[r0,#0xc]          ;1088
                  |L30.112|
000070  2204              MOVS     r2,#4                 ;1129
000072  4631              MOV      r1,r6                 ;1129
000074  6820              LDR      r0,[r4,#0]            ;1129
000076  f7fffffe          BL       TIM_CCxNChannelCmd
00007a  6820              LDR      r0,[r4,#0]            ;1132
00007c  6c41              LDR      r1,[r0,#0x44]         ;1132
00007e  f4414100          ORR      r1,r1,#0x8000         ;1132
000082  6441              STR      r1,[r0,#0x44]         ;1132
000084  6820              LDR      r0,[r4,#0]            ;1135
000086  6801              LDR      r1,[r0,#0]            ;1135
000088  f0410101          ORR      r1,r1,#1              ;1135
00008c  6001              STR      r1,[r0,#0]            ;1135
00008e  2000              MOVS     r0,#0                 ;1138
000090  bd70              POP      {r4-r6,pc}
                  |L30.146|
000092  6ae2              LDR      r2,[r4,#0x2c]         ;1111
000094  6290              STR      r0,[r2,#0x28]         ;1114
000096  6ae0              LDR      r0,[r4,#0x2c]         ;1114
000098  6301              STR      r1,[r0,#0x30]         ;1117
00009a  6822              LDR      r2,[r4,#0]            ;1117
00009c  4629              MOV      r1,r5                 ;1117
00009e  323c              ADDS     r2,r2,#0x3c           ;1117
0000a0  6ae0              LDR      r0,[r4,#0x2c]         ;1117
0000a2  f7fffffe          BL       HAL_DMA_Start_IT
0000a6  6820              LDR      r0,[r4,#0]            ;1120
0000a8  68c1              LDR      r1,[r0,#0xc]          ;1120
0000aa  f4416100          ORR      r1,r1,#0x800          ;1120
0000ae  e7de              B        |L30.110|
;;;1140   
                          ENDP

                  |L30.176|
                          DCD      TIM_DMADelayPulseCplt
                  |L30.180|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIMEx_PWMN_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Start_IT PROC
;;;927      */
;;;928    HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;929    {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b121              CBZ      r1,|L31.18|
;;;930      /* Check the parameters */
;;;931      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;932    
;;;933      switch (Channel)
000008  2904              CMP      r1,#4
00000a  d006              BEQ      |L31.26|
00000c  2908              CMP      r1,#8
00000e  d108              BNE      |L31.34|
000010  e01c              B        |L31.76|
                  |L31.18|
;;;934      {
;;;935        case TIM_CHANNEL_1:
;;;936        {
;;;937          /* Enable the TIM Capture/Compare 1 interrupt */
;;;938          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000012  68d0              LDR      r0,[r2,#0xc]
000014  f0400002          ORR      r0,r0,#2
;;;939        }
;;;940        break;
000018  e002              B        |L31.32|
                  |L31.26|
;;;941    
;;;942        case TIM_CHANNEL_2:
;;;943        {
;;;944          /* Enable the TIM Capture/Compare 2 interrupt */
;;;945          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00001a  68d0              LDR      r0,[r2,#0xc]
00001c  f0400004          ORR      r0,r0,#4
                  |L31.32|
000020  60d0              STR      r0,[r2,#0xc]          ;938
                  |L31.34|
;;;946        }
;;;947        break;
;;;948    
;;;949        case TIM_CHANNEL_3:
;;;950        {
;;;951          /* Enable the TIM Capture/Compare 3 interrupt */
;;;952          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
;;;953        }
;;;954        break;
;;;955    
;;;956        default:
;;;957        break;
;;;958      }
;;;959    
;;;960      /* Enable the TIM Break interrupt */
;;;961      __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
000022  6820              LDR      r0,[r4,#0]
000024  68c2              LDR      r2,[r0,#0xc]
000026  f0420280          ORR      r2,r2,#0x80
00002a  60c2              STR      r2,[r0,#0xc]
;;;962    
;;;963      /* Enable the complementary PWM output  */
;;;964      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
00002c  2204              MOVS     r2,#4
00002e  6820              LDR      r0,[r4,#0]
000030  f7fffffe          BL       TIM_CCxNChannelCmd
;;;965    
;;;966      /* Enable the Main Ouput */
;;;967      __HAL_TIM_MOE_ENABLE(htim);
000034  6820              LDR      r0,[r4,#0]
000036  6c41              LDR      r1,[r0,#0x44]
000038  f4414100          ORR      r1,r1,#0x8000
00003c  6441              STR      r1,[r0,#0x44]
;;;968    
;;;969      /* Enable the Peripheral */
;;;970      __HAL_TIM_ENABLE(htim);
00003e  6820              LDR      r0,[r4,#0]
000040  6801              LDR      r1,[r0,#0]
000042  f0410101          ORR      r1,r1,#1
000046  6001              STR      r1,[r0,#0]
;;;971    
;;;972      /* Return function status */
;;;973      return HAL_OK;
000048  2000              MOVS     r0,#0
;;;974    }
00004a  bd10              POP      {r4,pc}
                  |L31.76|
00004c  68d0              LDR      r0,[r2,#0xc]          ;952
00004e  f0400008          ORR      r0,r0,#8              ;952
000052  e7e5              B        |L31.32|
;;;975    
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Stop PROC
;;;898      */
;;;899    HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;900    {
000002  4604              MOV      r4,r0
;;;901      /* Check the parameters */
;;;902      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;903    
;;;904      /* Disable the complementary PWM output  */
;;;905      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2200              MOVS     r2,#0
000008  f7fffffe          BL       TIM_CCxNChannelCmd
;;;906    
;;;907      /* Disable the Main Ouput */
;;;908      __HAL_TIM_MOE_DISABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  6a03              LDR      r3,[r0,#0x20]
000010  f2411111          MOV      r1,#0x1111
000014  420b              TST      r3,r1
000016  f2404244          MOV      r2,#0x444
00001a  d106              BNE      |L32.42|
00001c  6a03              LDR      r3,[r0,#0x20]
00001e  4213              TST      r3,r2
000020  d103              BNE      |L32.42|
000022  6c43              LDR      r3,[r0,#0x44]
000024  f4234300          BIC      r3,r3,#0x8000
000028  6443              STR      r3,[r0,#0x44]
                  |L32.42|
;;;909    
;;;910      /* Disable the Peripheral */
;;;911      __HAL_TIM_DISABLE(htim);
00002a  6820              LDR      r0,[r4,#0]
00002c  6a03              LDR      r3,[r0,#0x20]
00002e  420b              TST      r3,r1
000030  d106              BNE      |L32.64|
000032  6a01              LDR      r1,[r0,#0x20]
000034  4211              TST      r1,r2
000036  d103              BNE      |L32.64|
000038  6801              LDR      r1,[r0,#0]
00003a  f0210101          BIC      r1,r1,#1
00003e  6001              STR      r1,[r0,#0]
                  |L32.64|
;;;912    
;;;913      /* Return function status */
;;;914      return HAL_OK;
000040  2000              MOVS     r0,#0
;;;915    }
000042  bd10              POP      {r4,pc}
;;;916    
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Stop_DMA PROC
;;;1151     */
;;;1152   HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1153   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b121              CBZ      r1,|L33.18|
;;;1154     /* Check the parameters */
;;;1155     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;1156   
;;;1157     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d006              BEQ      |L33.26|
00000c  2908              CMP      r1,#8
00000e  d108              BNE      |L33.34|
000010  e02a              B        |L33.104|
                  |L33.18|
;;;1158     {
;;;1159       case TIM_CHANNEL_1:
;;;1160       {
;;;1161         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1162         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000012  68d0              LDR      r0,[r2,#0xc]
000014  f4207000          BIC      r0,r0,#0x200
;;;1163       }
;;;1164       break;
000018  e002              B        |L33.32|
                  |L33.26|
;;;1165   
;;;1166       case TIM_CHANNEL_2:
;;;1167       {
;;;1168         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1169         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00001a  68d0              LDR      r0,[r2,#0xc]
00001c  f4206080          BIC      r0,r0,#0x400
                  |L33.32|
000020  60d0              STR      r0,[r2,#0xc]          ;1162
                  |L33.34|
;;;1170       }
;;;1171       break;
;;;1172   
;;;1173       case TIM_CHANNEL_3:
;;;1174       {
;;;1175         /* Disable the TIM Capture/Compare 3 DMA request */
;;;1176         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
;;;1177       }
;;;1178       break;
;;;1179   
;;;1180       default:
;;;1181       break;
;;;1182     }
;;;1183   
;;;1184     /* Disable the complementary PWM output */
;;;1185     TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000022  2200              MOVS     r2,#0
000024  6820              LDR      r0,[r4,#0]
000026  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1186   
;;;1187     /* Disable the Main Ouput */
;;;1188     __HAL_TIM_MOE_DISABLE(htim);
00002a  6820              LDR      r0,[r4,#0]
00002c  6a03              LDR      r3,[r0,#0x20]
00002e  f2411111          MOV      r1,#0x1111
000032  420b              TST      r3,r1
000034  f2404244          MOV      r2,#0x444
000038  d106              BNE      |L33.72|
00003a  6a03              LDR      r3,[r0,#0x20]
00003c  4213              TST      r3,r2
00003e  d103              BNE      |L33.72|
000040  6c43              LDR      r3,[r0,#0x44]
000042  f4234300          BIC      r3,r3,#0x8000
000046  6443              STR      r3,[r0,#0x44]
                  |L33.72|
;;;1189   
;;;1190     /* Disable the Peripheral */
;;;1191     __HAL_TIM_DISABLE(htim);
000048  6820              LDR      r0,[r4,#0]
00004a  6a03              LDR      r3,[r0,#0x20]
00004c  420b              TST      r3,r1
00004e  d106              BNE      |L33.94|
000050  6a01              LDR      r1,[r0,#0x20]
000052  4211              TST      r1,r2
000054  d103              BNE      |L33.94|
000056  6801              LDR      r1,[r0,#0]
000058  f0210101          BIC      r1,r1,#1
00005c  6001              STR      r1,[r0,#0]
                  |L33.94|
;;;1192   
;;;1193     /* Change the htim state */
;;;1194     htim->State = HAL_TIM_STATE_READY;
00005e  2001              MOVS     r0,#1
000060  f884003d          STRB     r0,[r4,#0x3d]
;;;1195   
;;;1196     /* Return function status */
;;;1197     return HAL_OK;
000064  2000              MOVS     r0,#0
;;;1198   }
000066  bd10              POP      {r4,pc}
                  |L33.104|
000068  68d0              LDR      r0,[r2,#0xc]          ;1176
00006a  f4206000          BIC      r0,r0,#0x800          ;1176
00006e  e7d7              B        |L33.32|
;;;1199   
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Stop_IT PROC
;;;986      */
;;;987    HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;988    {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b121              CBZ      r1,|L34.18|
;;;989      uint32_t tmpccer = 0U;
;;;990    
;;;991      /* Check the parameters */
;;;992      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;993    
;;;994      switch (Channel)
000008  2904              CMP      r1,#4
00000a  d006              BEQ      |L34.26|
00000c  2908              CMP      r1,#8
00000e  d108              BNE      |L34.34|
000010  e02f              B        |L34.114|
                  |L34.18|
;;;995      {
;;;996        case TIM_CHANNEL_1:
;;;997        {
;;;998          /* Disable the TIM Capture/Compare 1 interrupt */
;;;999          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000012  68d0              LDR      r0,[r2,#0xc]
000014  f0200002          BIC      r0,r0,#2
;;;1000       }
;;;1001       break;
000018  e002              B        |L34.32|
                  |L34.26|
;;;1002   
;;;1003       case TIM_CHANNEL_2:
;;;1004       {
;;;1005         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1006         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00001a  68d0              LDR      r0,[r2,#0xc]
00001c  f0200004          BIC      r0,r0,#4
                  |L34.32|
000020  60d0              STR      r0,[r2,#0xc]          ;999
                  |L34.34|
;;;1007       }
;;;1008       break;
;;;1009   
;;;1010       case TIM_CHANNEL_3:
;;;1011       {
;;;1012         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1013         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
;;;1014       }
;;;1015       break;
;;;1016   
;;;1017       default:
;;;1018       break;
;;;1019     }
;;;1020   
;;;1021     /* Disable the complementary PWM output  */
;;;1022     TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000022  2200              MOVS     r2,#0
000024  6820              LDR      r0,[r4,#0]
000026  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1023   
;;;1024     /* Disable the TIM Break interrupt (only if no more channel is active) */
;;;1025     tmpccer = htim->Instance->CCER;
00002a  6820              LDR      r0,[r4,#0]
00002c  6a02              LDR      r2,[r0,#0x20]
;;;1026     if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == RESET)
00002e  f2404144          MOV      r1,#0x444
000032  420a              TST      r2,r1
000034  d103              BNE      |L34.62|
;;;1027     {
;;;1028       __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
000036  68c2              LDR      r2,[r0,#0xc]
000038  f0220280          BIC      r2,r2,#0x80
00003c  60c2              STR      r2,[r0,#0xc]
                  |L34.62|
;;;1029     }
;;;1030   
;;;1031     /* Disable the Main Ouput */
;;;1032     __HAL_TIM_MOE_DISABLE(htim);
00003e  6820              LDR      r0,[r4,#0]
000040  6a03              LDR      r3,[r0,#0x20]
000042  f2411211          MOV      r2,#0x1111
000046  4213              TST      r3,r2
000048  d106              BNE      |L34.88|
00004a  6a03              LDR      r3,[r0,#0x20]
00004c  420b              TST      r3,r1
00004e  d103              BNE      |L34.88|
000050  6c43              LDR      r3,[r0,#0x44]
000052  f4234300          BIC      r3,r3,#0x8000
000056  6443              STR      r3,[r0,#0x44]
                  |L34.88|
;;;1033   
;;;1034     /* Disable the Peripheral */
;;;1035     __HAL_TIM_DISABLE(htim);
000058  6820              LDR      r0,[r4,#0]
00005a  6a03              LDR      r3,[r0,#0x20]
00005c  4213              TST      r3,r2
00005e  d106              BNE      |L34.110|
000060  6a02              LDR      r2,[r0,#0x20]
000062  420a              TST      r2,r1
000064  d103              BNE      |L34.110|
000066  6801              LDR      r1,[r0,#0]
000068  f0210101          BIC      r1,r1,#1
00006c  6001              STR      r1,[r0,#0]
                  |L34.110|
;;;1036   
;;;1037     /* Return function status */
;;;1038     return HAL_OK;
00006e  2000              MOVS     r0,#0
;;;1039   }
000070  bd10              POP      {r4,pc}
                  |L34.114|
000072  68d0              LDR      r0,[r2,#0xc]          ;1013
000074  f0200008          BIC      r0,r0,#8              ;1013
000078  e7d2              B        |L34.32|
;;;1040   
                          ENDP


                          AREA ||i.TIMEx_DMACommutationCplt||, CODE, READONLY, ALIGN=1

                  TIMEx_DMACommutationCplt PROC
;;;1669     */
;;;1670   void TIMEx_DMACommutationCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1671   {
;;;1672     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;1673   
;;;1674     htim->State= HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  f880103d          STRB     r1,[r0,#0x3d]
;;;1675   
;;;1676     HAL_TIMEx_CommutationCallback(htim);
00000a  f7fffffe          BL       HAL_TIMEx_CommutationCallback
;;;1677   }
00000e  bd10              POP      {r4,pc}
;;;1678   
                          ENDP


                          AREA ||i.TIM_CCxNChannelCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxNChannelCmd PROC
;;;1742     */
;;;1743   static void TIM_CCxNChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelNState)
000000  b510              PUSH     {r4,lr}
;;;1744   {
;;;1745     uint32_t tmp = 0U;
;;;1746   
;;;1747     tmp = TIM_CCER_CC1NE << Channel;
000002  2304              MOVS     r3,#4
;;;1748   
;;;1749     /* Reset the CCxNE Bit */
;;;1750     TIMx->CCER &=  ~tmp;
000004  6a04              LDR      r4,[r0,#0x20]
000006  408b              LSLS     r3,r3,r1              ;1747
000008  439c              BICS     r4,r4,r3
00000a  6204              STR      r4,[r0,#0x20]
;;;1751   
;;;1752     /* Set or reset the CCxNE Bit */
;;;1753     TIMx->CCER |=  (uint32_t)(ChannelNState << Channel);
00000c  6a03              LDR      r3,[r0,#0x20]
00000e  408a              LSLS     r2,r2,r1
000010  4313              ORRS     r3,r3,r2
000012  6203              STR      r3,[r0,#0x20]
;;;1754   }
000014  bd10              POP      {r4,pc}
;;;1755   
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_tim_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_tim_ex_c_e8ef3920____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___22_stm32f1xx_hal_tim_ex_c_e8ef3920____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_tim_ex_c_e8ef3920____REVSH|
#line 402
|__asm___22_stm32f1xx_hal_tim_ex_c_e8ef3920____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_tim_ex_c_e8ef3920____RRX|
#line 587
|__asm___22_stm32f1xx_hal_tim_ex_c_e8ef3920____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
